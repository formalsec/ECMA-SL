/* 9.4 Built-in Exotic Object Internal Methods and Slots */

/*
  |------------------------------|
  |                              |
  |  9.4.2 Array Exotic objects  |
  |                              |
  |------------------------------|
*/

/**
 * A String property name P (in the form of a String value) is an array index if and
 * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to 2^32−1.
 */
function IsArrayIndex(P) {
  if (Type(P) = "Symbol")
    return false;

  if (extern is_symbolic(P))
    return extern is_number(P);

  p_uint := ToUint32(P);
  p_str := ToString(p_uint);
  return ((p_str = P) && !(p_uint = ((2. ** 32.) - 1.))); /* (2^32)-1 = 4294967295 */
}

/**
 * 9.4.2.1 [[DefineOwnProperty]] (P, Desc)
 *
 * When the [[DefineOwnProperty]] internal method of an Array exotic object A is
 * called with property key P, and Property Descriptor Desc the following steps
 * are taken:
 */
function ArrayDefineOwnProperty(A, P, Desc) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) = true);
  /* 2. If P is "length", then */
  if (P = "length") {
    /* a. Return ArraySetLength(A, Desc). */
    return ArraySetLength(A, Desc);
  }
  /* 3. Else if P is an array index, then */
  else if (IsArrayIndex(P)) {
    /* a. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length"). */
    oldLenDesc := OrdinaryGetOwnProperty(A, "length");
    /* b. Assert: oldLenDesc will never be undefined or an accessor descriptor
       because Array objects are created with a length data property that
       cannot be deleted or reconfigured. */
    assert ((!(oldLenDesc = 'undefined)) &&& (!IsAccessorDescriptor(oldLenDesc)));
    /* c. Let oldLen be oldLenDesc.[[Value]]. */
    oldLen := oldLenDesc.Value;
    /* d. Let index be ToUint32(P). */
    index := ToUint32(P);
    /* e. Assert: index will never be an abrupt completion. */
    assert (!isAnAbruptCompletion(index));
    /* f. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, */
    if ((index >= oldLen) &&& (oldLenDesc.Writable = false))
      /* return false */
      return false;
    /* g. Let succeeded be OrdinaryDefineOwnProperty(A, P, Desc). */
    succeeded := OrdinaryDefineOwnProperty(A, P, Desc);
    /* h. Assert: succeeded is not an abrupt completion. */
    assert (!isAnAbruptCompletion(succeeded));
    /* i. If succeeded is false, */
    if (succeeded = false)
      /* return false */
      return false;
    /* j. If index ≥ oldLen */
    if (index >= oldLen) {
      /* i. Set oldLenDesc.[[Value]] to index + 1. */
      oldLenDesc.Value := index + 1.;
      /* ii. Let succeeded be OrdinaryDefineOwnProperty(A, "length", oldLenDesc). */
      succeeded := OrdinaryDefineOwnProperty(A, "length", oldLenDesc);
      /* iii. Assert: succeeded is true. */
      assert(succeeded);
    }
    /* k. Return true. */
    return true;
  }
  /* 4. Return OrdinaryDefineOwnProperty(A, P, Desc). */
  return OrdinaryDefineOwnProperty(A, P, Desc);
}

/**
 * 9.4.2.2 ArrayCreate (length, proto)
 *
 * The abstract operation ArrayCreate with argument length (a positive integer)
 * and optional argument proto is used to specify the creation of new Array
 * exotic objects. It performs the following steps:
 */
function ArrayCreate(length, proto) {
  /* 1. Assert: length is an integer Number ≥ 0. */
  assert ((IsInteger(length)) &&& (length >= 0.));
  /* 2. If length is -0, */
  if (isMinusZero(length))
    /* let length be +0 */
    length := 0.;
  /* 3. If length > 2^32 - 1, */
  if (length > (4294967295.))
    /* throw a RangeError exception */
    throw RangeErrorConstructorInternal();
  /* 4. If the proto argument was not passed, */
  if ((proto = null) ||| (proto = 'undefined))
    /* let proto be the intrinsic object %ArrayPrototype% */
    proto := |Intrinsics|.ArrayPrototype;
  /* 5. Let A be a newly created Array exotic object. */
  A := NewECMAScriptObject();
  /* 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1. */
  setAllInternalMethodsOfOrdinaryObject(A);
  /* 7. Set the [[DefineOwnProperty]] internal method of A as specified in 9.4.2.1. */
  A.DefineOwnProperty := "ArrayDefineOwnProperty";
  /* 8. Set the [[Prototype]] internal slot of A to proto. */
  A.Prototype := proto;
  /* 9. Set the [[Extensible]] internal slot of A to true. */
  A.Extensible := true;
  /* 10. Perform OrdinaryDefineOwnProperty(A, "length",
     PropertyDescriptor{[[Value]]: length, [[Writable]]: true,
     [[Enumerable]]: false, [[Configurable]]: false}). */
  completion := OrdinaryDefineOwnProperty(A, "length", newDataPropertyDescriptorFull(length, true, false, false));
  /* 11. Assert: the preceding step never produces an abrupt completion. */
  assert (!isAnAbruptCompletion(completion));
  /* 12. Return A. */
  return A;
}

/**
 * 9.4.2.3 ArraySpeciesCreate (originalArray, length)
 *
 * The abstract operation ArraySpeciesCreate with arguments originalArray and
 * length is used to specify the creation of a new Array object using a
 * constructor function that is derived from originalArray. It performs the
 * following steps:
 */
function ArraySpeciesCreate(originalArray, length) {
  /* 1. Assert: length is an integer Number ≥ 0. */
  assert ((IsInteger(length)) &&& (length >= 0.));
  /* 2. If length is -0, */
  if (isMinusZero(length))
    /* let length be +0 */
    length := 0.;
  /* 3. Let C be undefined. */
  C := 'undefined;
  /* 4. Let isArray be IsArray(originalArray). */
  isArray := IsArray(originalArray);
  /* 5. ReturnIfAbrupt(isArray). */
  @ReturnIfAbrupt(isArray);
  /* 6. If isArray is true, then */
  if (isArray = true) {
    /* a. Let C be Get(originalArray, "constructor"). */
    C := Get(originalArray, "constructor");
    /* b. ReturnIfAbrupt(C). */
    @ReturnIfAbrupt(C);
    /* c. If IsConstructor(C) is true, then */
    if (IsConstructor(C) = true) {
      /* i. Let thisRealm be the running execution context's Realm. */
      thisRealm := null; /* TODO: Provavelment depende do Rafael */
      /* ii. Let realmC be GetFunctionRealm(C). */
      /* realmC := GetFunctionRealm(C); */
      /* iii. ReturnIfAbrupt(realmC). */
      /* @ReturnIfAbrupt(realmC); */
      /* iv. If thisRealm and realmC are not the same Realm Record, then */
      if (false) { /* TODO */
        /* 1. If SameValue(C, realmC.[[intrinsics]].[[%Array%]]) is true, */
        if (SameValue(C, realmC.intrinsics.Array) = true) {/* TODO */
          /* let C be undefined */
          C := 'undefined;
        }
      }
    }
    /* d. If Type(C) is Object, then */
    if (Type(C) = "Object") {
      /* i. Let C be Get(C, @@species). */
      C := Get(C, getSpeciesPropertyName());
      /* ii. ReturnIfAbrupt(C). */
      @ReturnIfAbrupt(C);
      /* iii. If C is null, */
      if (C = 'null)
        /* let C be undefined */
        C := 'undefined;
    }
  }
  /* 7. If C is undefined, */
  if (C = 'undefined)
    /* return ArrayCreate(length) */
    return ArrayCreate(length, null);
  /* 8. If IsConstructor(C) is false, throw a TypeError exception. */
  if (IsConstructor(C) = false)
    throw TypeErrorConstructorInternal();
  /* 9. Return Construct(C, «length»). */
  return Construct(null, null, C, [length], null);
}
/**
 * NOTE If originalArray was created using the standard built-in Array
 * constructor for a Realm that is not the Realm of the running execution
 * context, then a new Array is created using the Realm of the running execution
 * context. This maintains compatibility with Web browsers that have
 * historically had that behaviour for the Array.prototype methods that now are
 * defined using ArraySpeciesCreate.
 */

/**
 * 9.4.2.4 ArraySetLength (A, Desc)
 *
 * When the abstract operation ArraySetLength is called with an Array exotic
 * object A, and Property Descriptor Desc the following steps are taken:
 */
function ArraySetLength(A, Desc) {
  /* 1. If the [[Value]] field of Desc is absent, then */
  if (!("Value" in_obj Desc))
    /* a. Return OrdinaryDefineOwnProperty(A, "length", Desc). */
    return OrdinaryDefineOwnProperty(A, "length", Desc);
  /* 2. Let newLenDesc be a copy of Desc. */
  newLenDesc := copyDescriptor(Desc);
  /* 3. Let newLen be ToUint32(Desc.[[Value]]). */
  newLen := ToUint32(Desc.Value);
  /* 4. ReturnIfAbrupt(newLen). */
  @ReturnIfAbrupt(newLen);
  /* 5. Let numberLen be ToNumber(Desc.[[Value]]). */
  numberLen := ToNumber(Desc.Value);
  /* 6. ReturnIfAbrupt(newLen). */
  @ReturnIfAbrupt(newLen);
  /* 7. If newLen ≠ numberLen, */
  if (!(newLen = numberLen))
    /* throw a RangeError exception */
    throw RangeErrorConstructorInternal();
  /* 8. Set newLenDesc.[[Value]] to newLen. */
  newLenDesc.Value := newLen;
  /* 9. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length"). */
  oldLenDesc := OrdinaryGetOwnProperty(A, "length");
  /* 10. Assert: oldLenDesc will never be undefined or an accessor descriptor
     because Array objects are created with a length data property that
     cannot be deleted or reconfigured. */
  assert ((!(oldLenDesc = 'undefined)) &&& (!IsAccessorDescriptor(oldLenDesc)));
  /* 11. Let oldLen be oldLenDesc.[[Value]]. */
  oldLen := oldLenDesc.Value;
  /* 12. If newLen ≥oldLen, then */
  if (newLen >= oldLen)
    /* a. Return OrdinaryDefineOwnProperty(A, "length", newLenDesc). */
    return OrdinaryDefineOwnProperty(A, "length", newLenDesc);
  /* 13. If oldLenDesc.[[Writable]] is false, */
  if (oldLenDesc.Writable = false)
    /* return false */
    return false;
  /* 14. If newLenDesc.[[Writable]] is absent or has the value true, */
  if ((!("Writable" in_obj newLenDesc)) ||| (newLenDesc.Writable)) {
    /* let newWritable be true */
    newWritable := true;
  }
  /* 15. Else, */
  else {
    /* a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted. */

    /* b. Let newWritable be false. */
    newWritable := false;
    /* c. Set newLenDesc.[[Writable]] to true. */
    newLenDesc.Writable := true;
  }
  /* 16. Let succeeded be OrdinaryDefineOwnProperty(A, "length", newLenDesc). */
  succeeded := OrdinaryDefineOwnProperty(A, "length", newLenDesc);
  /* 17. Assert: succeeded is not an abrupt completion. */
  assert (!isAnAbruptCompletion(succeeded));
  /* 18. If succeeded is false, */
  if (succeeded = false)
    /* return false */
    return false;
  /* 19. While newLen < oldLen repeat, */
  while (newLen < oldLen) {
    /* a. Set oldLen to oldLen – 1. */
    oldLen := oldLen - 1.;
    /* b. Let deleteSucceeded be A.[[Delete]](ToString(oldLen)). */
    deleteSucceeded := {A.Delete}(A, ToString(oldLen));
    /* c. Assert: deleteSucceeded is not an abrupt completion. */
    assert (!isAnAbruptCompletion(deleteSucceeded));
    /* d. If deleteSucceeded is false, then */
    if (deleteSucceeded = false) {
      /* i. Set newLenDesc.[[Value]] to oldLen + 1. */
      newLenDesc.Value := oldLen + 1.;
      /* ii. If newWritable is false, set newLenDesc.[[Writable]] to false. */
      if (newWritable = false)
        newLenDesc.Writable := false;
      /* iii. Let succeeded be OrdinaryDefineOwnProperty(A, "length", newLenDesc). */
      succeeded := OrdinaryDefineOwnProperty(A, "length", newLenDesc);
      /* iv. Assert: succeeded is not an abrupt completion. */
      assert (!isAnAbruptCompletion(succeeded));
      /* v. Return false. */
      return false;
    }
  }
  /* 20. If newWritable is false, then */
  if (newWritable = false)
    /* a. Return OrdinaryDefineOwnProperty(A, "length",
       PropertyDescriptor{[[Writable]]: false}). This call will always return
       true. */
    return OrdinaryDefineOwnProperty(A, "length", {Writable: false});
  /* 21. Return true. */
  return true;
}
/**
 * NOTE In steps 3 and 4, if Desc.[[Value]] is an object then its valueOf method
 * is called twice. This is legacy behaviour that was specified with this effect
 * starting with the 2nd Edition of this specification.
 */

/* 9.4.3 String Exotic Objects */

/**
 * 9.4.3.4 StringCreate( value, prototype)
 *
 * The abstract operation StringCreate with arguments value and prototype is used to specify
 * the creation of new exotic String objects. It performs the following steps:
 */
 function StringCreate(value, prototype) {
  /* 1. ReturnIfAbrupt(prototype). */
  @ReturnIfAbrupt(prototype);
  /* 2. Assert: Type(value) is String. */
  assert (Type(value) = "String");
  /* 3. Let S be a newly created String exotic object. */
  S := NewECMAScriptObject();
  setAllInternalMethodsOfOrdinaryObject(S);
  /* setInternalProperty(S, "Class", "String"); */
  /* 4. Set the [[StringData]] internal slot of S to value. */
  setInternalProperty(S, "StringData", value);
  /* 5. Set S’s essential internal methods to the default ordinary object definitions specified in 9.1. */
  setStringInternals(S);
  /**
    * All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is
    * either null or an object and is used for implementing inheritance. Data properties of the
    * [[Prototype]] object are inherited (are visible as properties of the child object) for the purposes
    * of get access, but not for set access. Accessor properties are inherited for both get access and
    * set access.
    *
    * Every ordinary object has a Boolean-valued [[Extensible]] internal slot that controls whether or
    * not properties may be added to the object. If the value of the [[Extensible]] internal slot is
    * false then additional properties may not be added to the object. In addition, if [[Extensible]]
    * is false the value of the [[Prototype]] internal slot of the object may not be modified. Once the
    * value of an object’s [[Extensible]] internal slot has been set to false it may not be subsequently
    * changed to true.
    *
    * In the following algorithm descriptions, assume O is an ordinary object, P is a property key value,
    * V is any ECMAScript language value, and Desc is a Property Descriptor record.
    */

  /* 6. Set the [[GetOwnProperty]] internal method of S as specified in 9.4.3.1. */
  setInternalProperty(S, "GetOwnProperty", "GetOwnPropertyString");
  /* 7. Set the [[HasProperty]] internal method of S as specified in 9.4.3.2. */
  setInternalProperty(S, "HasProperty", "HasPropertyString");
  /* 8. Set the [[OwnPropertyKeys]] internal method of S as specified in 9.4.3.3. */
  setInternalProperty(S, "OwnPropertyKeys", "OwnPropertyKeysString");
  /* 9. Set the [[Prototype]] internal slot of S to prototype. */
  setInternalProperty(S, "Prototype", prototype);
  /* 10. Set the [[Extensible]] internal slot of S to true. */
  setInternalProperty(S, "Extensible", true);
  /* 11. Let length be the number of code unit elements in value. */
  length := int_to_float(s_len_u (value));
  /* 12. Let status be DefinePropertyOrThrow(S, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: false,
  [[Enumerable]]: false, [[Configurable]]: false }). */
  setJSProperty(S, "length", newDataPropertyDescriptorFull(length, false, false, false));
  /*
  status := DefinePropertyOrThrow(S, "length", newDataPropertyDescriptorFull(length, false, false, false) );
  */
  /* 13. Assert: status is not an abrupt completion. */
  /*
  if (Type(status) = "Completion") {
    assert(!isAnAbruptCompletion(status))
  }
  */

  /* 14. Return S. */
  return S;
}

/* 9.1 Ordinary Object Internal Methods and Internal Slots */
function setStringInternals(S) {
  /* 9.1.1 [[GetPrototypeOf]] ( ) */
  setInternalProperty(S, "GetPrototypeOf", "OrdinaryObjectGetPrototypeOf");
  /* 9.1.2 [[SetPrototypeOf]] (V) */
  setInternalProperty(S, "SetPrototypeOf", "OrdinaryObjectSetPrototypeOf");
  /* 9.1.3 [[IsExtensible]] ( ) */
  setInternalProperty(S, "IsExtensible", "OrdinaryObjectIsExtensible");
  /* 9.1.4 [[PreventExtensions]] ( ) */
  setInternalProperty(S, "PreventExtensions", "OrdinaryObjectPreventExtensions");
  /* 9.1.5 [[GetOwnProperty]] (P) */
  /* 9.1.6 [[DefineOwnProperty]] (P, Desc) */
  setInternalProperty(S, "DefineOwnProperty", "OrdinaryObjectDefineOwnProperty");
  /* 9.1.7 [[HasProperty]](P) */
  /* 9.1.8 [[Get]] (P, Receiver) */
  setInternalProperty(S, "Get", "OrdinaryObjectGet");
  /* 9.1.9 [[Set]] ( P, V, Receiver) */
  setInternalProperty(S, "Set", "OrdinaryObjectSet");
  /* 9.1.10 [[Delete]] (P) */
  setInternalProperty(S, "Delete", "OrdinaryObjectDelete");
  /* 9.1.11 [[Enumerate]] () */
  setInternalProperty(S, "Enumerate", "OrdinaryObjectEnumerate");
  /* 9.1.12 [[OwnPropertyKeys]] ( ) */
  return 'null;
}

/* 9.4.3.1 [[GetOwnProperty]] ( P ) */
function GetOwnPropertyString(S, P) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) = true);
  /* 2. Let desc be OrdinaryGetOwnProperty(S, P). */
  desc := OrdinaryGetOwnProperty(S, P);
  /* 3. If desc is not undefined return desc. */
  if (!(desc = 'undefined))
    return desc;
  /* 4. Return StringGetIndexProperty(S, P). */
  return StringGetIndexProperty(S, P);
}

/* 9.4.3.1.1 StringGetIndexProperty (S, P) */
function StringGetIndexProperty(S, P) {
  /* 1. If Type(P) is not String, return undefined. */
  if (!(Type(P) = "String"))
    return 'undefined;
  /* 2. Let index be CanonicalNumericIndexString (P). */
  index := CanonicalNumericIndexString(P);
  /* 3. Assert: index is not an abrupt completion. */
  if (Type(index) = "Completion")
    assert(!isAnAbruptCompletion(index));
  /* 4. If index is undefined, return undefined. */
  if (index = 'undefined)
    return 'undefined;
  /* 5. If IsInteger(index) is false, return undefined. */
  if (IsInteger(index) = false)
    return 'undefined;
  /* 6. If index = −0, return undefined. */
  if (isMinusZero(index))
    return 'undefined;
  /* 7. Let str be the String value of the [[StringData]] internal slot of S. */
  str := S.StringData;
  /* 8. Let len be the number of elements in str. */
  len := s_len_u (str);
  /* 9. If index < 0 or len ≤ index, return undefined. */
  if ((index < 0.) || ((int_to_float len) <= index))
    return 'undefined;
  /* 10. Let resultStr be a String value of length 1, containing one code unit from str, specifically the code unit at index index. */
  resultStr := s_nth_u (str, int_of_float index);
  /* 11. Return a PropertyDescriptor{ [[Value]]: resultStr, [[Enumerable]]: true, [[Writable]]: false, [[Configurable]]: false }. */
  return newDataPropertyDescriptorFull(resultStr, false, true, false);
}

/* 9.4.3.2 [[HasProperty]](P) */
function HasPropertyString(S, P) {
  /* 1. Let elementDesc be StringGetIndexProperty(S, P). */
  elementDesc := StringGetIndexProperty(S, P);
  /* 2. If elementDesc is not undefined, return true. */
  if (!(elementDesc = 'undefined))
    return true;
  /* 3. Return OrdinaryHasProperty(S, P). */
  return OrdinaryHasProperty(S, P);
}

/* 9.4.3.3 [[OwnPropertyKeys]] ( ) */
function OwnPropertyKeysString(O) {
  /* 1. Let keys be a new empty List. */
  keys := [];
  /* 2. Let str be the String value of the [[StringData]] internal slot of O. */
  str := ToString(O.StringData);
  /* 3. Let len be the number of elements in str. */
  len := int_to_float(s_len_u (str));
  /* 4. For each integer i starting with 0 such that i < len, in ascending order, */
  i := 0.;
  while (i < len) {
    /* a. Add ToString(i) as the last element of keys */
    keys := l_add(keys, ToString(i));
    i := i + 1.;
  }

  numbers := [];
  strings := [];
  symbols := [];

  /* 5. For each own property key P of O such that P is an integer index and ToInteger(P) ≥ len, in ascending numeric index order, */
  foreach ( P : O.internalSlotsList ) {
    if (IsArrayIndex(P) &&& (ToInteger(P) >= len))
      /* Add P as the last element of keys. */
      numbers := l_add(numbers, P);

    /* For each own property key P of O that is a String but is not an integer index, in property creation order */
    else if (Type(P) = "String" &&& !(Type(P) = "Number") &&& in_list(P, obj_fields O.JSProperties))
        /* Add P as the last element of keys. */
        strings := l_add(strings, P);

    /* For each own property key P of O that is a Symbol, in property creation order */
    else if (in_list(P, (obj_fields O.SymbolKeys))) {
      /* Add P as the last element of keys. */
      symbols := l_add(symbols, O.SymbolKeys[P]);
    }
  }

  numbers := l_sort(numbers);
  keys := l_concat(keys, numbers);
  keys := l_concat(keys, strings);
  keys := l_concat(keys, symbols);

  /* 8. Return keys. */
  return keys;
}

/**
 * 9.4.4.6 CreateUnmappedArgumentsObject (argumentsList)
 *
 * The abstract operation CreateUnmappedArgumentsObject called with an argument
 * argumentsList performs the following steps:
 */
function CreateUnmappedArgumentsObject(func, parameterNames, argumentsList, env) {
  /* 1. Let len be the number of elements in argumentsList. */
  len := l_len argumentsList;
  /* 2. Let obj be ObjectCreate(%ObjectPrototype%, «‍[[ParameterMap]]»). */
  obj := ObjectCreate(getObjectPrototype(true), ["ParameterMap"]);
  /* 3. Set obj's [[ParameterMap]] internal slot to undefined. */
  obj.ParameterMap := 'undefined;
  /* 4. Perform DefinePropertyOrThrow(obj, "length",
     PropertyDescriptor{[[Value]]: len, [[Writable]]: true, [[Enumerable]]:
     false, [[Configurable]]: true}). */
  DefinePropertyOrThrow(obj, "length", newDataPropertyDescriptorFull(int_to_float len, true, false, true));
  /* 5. Let index be 0. */
  index := 0.;
  /* 6. Repeat while index < len, */
    /* Let val be argumentsList[index]. */
  foreach (val : argumentsList) {
      /*  Perform CreateDataProperty(obj, ToString(index), val). */
      CreateDataProperty(obj, ToString(index), val);
      index := index + 1.;
  }
  thrower := createThrowTypeErrorFunctionObject(getFunctionPrototype(true), true);
  /* 7. Perform DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor
     {[[Value]]:%ArrayProto_values%, [[Writable]]: true, [[Enumerable]]:
     false, [[Configurable]]: true}). */

  /* 8. Perform DefinePropertyOrThrow(obj, "caller", PropertyDescriptor
     {[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]:
     false, [[Configurable]]: false}). */
  status2 := DefinePropertyOrThrow(obj, "caller", newGetAndSetAccessorPropertyDescriptorFull(thrower, thrower, false, false));
  /* 9. Perform DefinePropertyOrThrow(obj, "callee", PropertyDescriptor
     {[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]:
     false, [[Configurable]]: false}). */
  status3 := DefinePropertyOrThrow(obj, "callee",  newGetAndSetAccessorPropertyDescriptorFull(thrower, thrower, false, false));
  /* 10. Assert: the above property definitions will not produce an abrupt
     completion. */
  assert (!(isAnAbruptCompletion(status3)) ||| !(isAnAbruptCompletion(status2)));
  /* 11. Return obj */
  return obj;
}

/**
 * 9.4.4.7 CreateMappedArgumentsObject (func, formals, argumentsList, env)
 *
 * The abstract operation CreateMappedArgumentsObject is called with object
 * func, parsed grammar phrase formals, List argumentsList, and Environment
 * Record env. The following steps are performed:
 */
function CreateMappedArgumentsObject(func, formals, argumentsList, env) {
  /* 1. Assert: formals does not contain a rest parameter, any binding
     patterns, or any initializers. It may contain duplicate identifiers. */

  /* 2. Let len be the number of elements in argumentsList. */
  len := l_len(argumentsList);
  /* 3. Let obj be a newly created arguments exotic object with a
     [[ParameterMap]] internal slot. */
  obj := NewECMAScriptObject();
  obj.ParameterMap := 'undefined;
  setAllInternalMethodsOfOrdinaryObject(obj);

  /* 9. Set the remainder of obj's essential internal methods to the default
     ordinary object definitions specified in 9.1. */
  /* 10. Set the [[Prototype]] internal slot of obj to %ObjectPrototype%. */
  obj.Prototype := getObjectPrototype(false);
  /* 11. Set the [[Extensible]] internal slot of obj to true. */
  obj.Extensible := true;
  /* 12. Let parameterNames be the BoundNames of formals. */
  parameterNames := formals;
  /* 13. Let numberOfParameters be the number of elements in parameterNames */
  numberOfParameters := l_len(parameterNames);
  /* 14. Let index be 0. */
  index := 0;
  /* 15. Repeat while index < len , */
  while (index < len) {
    /* a. Let val be argumentsList[index]. */
    val := l_nth(argumentsList, index);
    /* b. Perform CreateDataProperty(obj, ToString(index), val). */
    CreateDataProperty(obj, ToString(int_to_float index), val);
    index := index + 1;
  }

  /* 16. Perform DefinePropertyOrThrow(obj, "length",
     PropertyDescriptor{[[Value]]: len, [[Writable]]: true, [[Enumerable]]:
     false, [[Configurable]]: true}). */
  DefinePropertyOrThrow(obj, "length", newDataPropertyDescriptorFull(int_to_float len, true, false, true));
  /* 17. Let map be ObjectCreate(null). */
  map := ObjectCreate(getObjectPrototype(false), null);
  /* 18. Let mappedNames be an empty List. */
  mappedNames := [];
  /* 19. Let index be numberOfParameters - 1. */
  index := numberOfParameters - 1;
  /* 4. Set the [[GetOwnProperty]] internal method of obj as specified in 9.4.4.1. */
  obj.GetOwnProperty := "ArgumentsObjectGetOwnProperty";
  /* 5. Set the [[DefineOwnProperty]] internal method of obj as specified in 9.4.4.2. */
  obj.DefineOwnProperty := "ArgumentsObjectDefineOwnProperty";
  /* 6. Set the [[Get]] internal method of obj as specified in 9.4.4.3. */
  obj.Get := "ArgumentsObjectGet";
  /* 7. Set the [[Set]] internal method of obj as specified in 9.4.4.4. */
  obj.Set := "ArgumentsObjectSet";
  /* 8. Set the [[Delete]] internal method of obj as specified in 9.4.4.5. */
  obj.Delete := "ArgumentsObjectDelete";
  /* 20. Repeat while index ≥ 0 , */
  while (index >= 0) {
    /* a. Let name be parameterNames[index]. */
    name := l_nth(parameterNames, index);
    /* b. If name is not an element of mappedNames, then */
    if (!(in_list(name, mappedNames))) {
      mappedNames := l_add(mappedNames, name);
      /* If index < len, then */
      if (index < len) {
        /* 1. Let g be MakeArgGetter(name, env). */
        g := MakeArgGetter(name, env);
        /* 2. Let p be MakeArgSetter(name, env). */
        p := MakeArgSetter(name, env);
        /* Call map.[[DefineOwnProperty]](ToString(index),
        PropertyDescriptor{[[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true}). */
        {map.DefineOwnProperty}(map, ToString(int_to_float index), newGetAndSetAccessorPropertyDescriptorFull(g, p, false,true));
      }
    }
    /* c. Let index be index − 1 */
    index := index - 1;
  }

  /* 21. Set the [[ParameterMap]] internal slot of obj to map. */
  obj.ParameterMap := map;
  setInternalProperty(obj, "DefineOwnProperty", "ArgumentsObjectDefineOwnProperty");
  /* 22. Perform DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor
     {[[Value]]:%ArrayProto_values%, [[Writable]]: true, [[Enumerable]]:
     false, [[Configurable]]: true}). */
  status1 := DefinePropertyOrThrow(obj, getWellKnownSymbol("Symbol.iterator"), newDataPropertyDescriptorFull(|Intrinsics|["ArrayProto_values"], true, false, true));
  /* 23. Perform DefinePropertyOrThrow(obj, "callee", PropertyDescriptor
     {[[Value]]: func, [[Writable]]: true, [[Enumerable]]: false,
     [[Configurable]]: true}). */
  status2 := DefinePropertyOrThrow(obj, "callee", newDataPropertyDescriptorFull(func, true, false, true));
  /* 24. Assert: the above property definitions will not produce an abrupt completion. */
  assert (!(isAnAbruptCompletion(status1) ||| isAnAbruptCompletion(status2)));
  /* 25. Return obj */
  return obj;
}

/**
 * 9.4.4.1 [[GetOwnProperty]] (P)
 *
 * The [[GetOwnProperty]] internal method of an arguments exotic object when
 * called with a property key P performs the following steps:
 */
function ArgumentsObjectGetOwnProperty(O, P) {
  /* 1. Let args be the arguments object. */
  args := O;
  /* 2. Let desc be OrdinaryGetOwnProperty(args, P). */
  desc := OrdinaryGetOwnProperty(args, P);
  /* 3. If desc is undefined, */
  if (desc = 'undefined)
    /* return desc */
    return desc;
  /* 4. Let map be the value of the [[ParameterMap]] internal slot of the arguments object. */
  map := args.ParameterMap;
  /* 5. Let isMapped be HasOwnProperty(map, P). */
  isMapped := HasOwnProperty(map, P);
  /* 6. Assert: isMapped is never an abrupt completion. */
  assert (!(isAnAbruptCompletion(isMapped)));
  /* 7. If the value of isMapped is true, then */
  if (isMapped = true) {
    /* a. Set desc.[[Value]] to Get(map, P). */
    desc.Value := Get(map, P);
  }
  /* 8. If IsDataDescriptor(desc) is true and P is "caller" and desc.[[Value]] is a strict mode Function object, */
  if (IsDataDescriptor(desc) = true &&  P = "caller" && DescriptorValueIsStrictFunction(desc) = true)
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 9. Return desc. */
  return desc;
}
/**
 * If an implementation does not provide a built-in caller property for argument
 * exotic objects then step 8 of this algorithm is must be skipped.
 */

/**
 * ArgumentsObjectDefineOwnProperty
 * 9.4.4.2 [[DefineOwnProperty]] (P, Desc)
 *
 * The [[DefineOwnProperty]] internal method of an arguments exotic object when
 * called with a property key P and Property Descriptor Desc performs the
 * following steps:
 */
function ArgumentsObjectDefineOwnProperty(O, P, Desc) {
  /* 1. Let args be the arguments object. */
  args := O;
  /* 2. Let map be the value of the [[ParameterMap]] internal slot of the
     arguments object. */
  map := args.ParameterMap;
  /* 3. Let isMapped be HasOwnProperty(map, P). */
  isMapped := HasOwnProperty(map, P);
  /* 4. Let allowed be OrdinaryDefineOwnProperty(args, P, Desc). */
  allowed := OrdinaryDefineOwnProperty(args, P, Desc);
  /* 5. ReturnIfAbrupt(allowed). */
  @ReturnIfAbrupt(allowed);
  /* 6. If allowed is false, */
  if (allowed = false)
    /* return false */
    return false;
  /* 7. If the value of isMapped is true, then */
  if (isMapped = true) {
    /* a. If IsAccessorDescriptor(Desc) is true, then */
    if (IsAccessorDescriptor(Desc) = true) {
      /* i. Call map.[[Delete]](P). */
      {map.Delete}(map, P);
    /* b. Else */
    } else {
      /* If Desc.[[Value]] is present, then */
      if ("Value" in_obj Desc) {
        /* Let setStatus be Set(map, P, Desc.[[Value]], false). */
        setStatus := Set(map, P, Desc.Value, false);
        /* Assert: setStatus is true because formal parameters mapped by argument objects are always writable. */
        assert(setStatus = true);
      }
      if ("Writable" in_obj Desc) {
        if (Desc.Writable = false)
          {map.Delete}(map, P);
      }
    }
  }
  /* 8. Return true. */
  return true;
}

/**
 * ArgumentsObjectGet
 * 9.4.4.3 [[Get]] (P, Receiver)
 *
 * The [[Get]] internal method of an arguments exotic object when called with a
 * property key P and ECMAScript language value Receiver performs the following
 * steps:
 */
function ArgumentsObjectGet(O,P, Receiver) {
  /* 1. Let args be the arguments object. */
  args := O;
  /* 2. Let map be the value of the [[ParameterMap]] internal slot of the
     arguments object. */
  map := args.ParameterMap;
  /* 3. Let isMapped be HasOwnProperty(map, P). */
  isMapped := HasOwnProperty(map, P);
  /* 4. Assert: isMapped is not an abrupt completion. */
  assert (!isAnAbruptCompletion(isMapped));
  /* 5. If the value of isMapped is false, then */
  if (isMapped = false) {
    /* a. Return the result of calling the default ordinary object [[Get]]
       internal method (9.1.8) on args passing P and Receiver as the
       arguments. */
    return OrdinaryObjectGet(O, P, Receiver);
  }
  /* 6. Else map contains a formal parameter mapping for P, */
    /* a. Return Get(map, P). */;
  return Get(map, P);
}

/**
 * ArgumentsObjectDelete
 * 9.4.4.3 [[Delete]] (P)
 *
 * The [[Delete]] internal method of an arguments exotic object
 * when called with a property key P performs the following steps:
 */

function ArgumentsObjectDelete(argumentsObject, P) {
  /* The [[Delete]] internal method of an arguments object for a non-strict mode function with formal parameters
     when called with a property name P and Boolean flag Throw performs the following steps: */
  Throw := true;
  /* 1. Let map be the value of the [[ParameterMap]] internal property of the arguments object. */
  map := argumentsObject.ParameterMap;
  /* 2. Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the argument. */
  isMapped := HasOwnProperty(map, P);
  /* 3. Let result be the result of calling the default [[Delete]] internal method (8.12.7) on the arguments object passing P and Throw as the arguments. */
  result := OrdinaryObjectDelete(argumentsObject, P);
  /* 4. If result is true and the value of isMapped is not undefined, then */
  if ((result = true) &&& (isMapped = true))
    /* a. Call the [[Delete]] internal method of map passing P, and false as the arguments. */
    {map.Delete}(map, P);
  /* 5. Return result. */
  return result;
}


/**
 + ArgumentsObjectSet
 * 9.4.4.4 [[Set]] (P, V, Receiver)
 *
 * The [[Set]] internal method of an arguments exotic object when called with
 * property key P, value V, and ECMAScript language value Receiver performs the
 * following steps:
 */
function ArgumentsObjectSet(O, P, V, Receiver) {
  /* 1. Let args be the arguments object. */
  args := O;
  /* 2. If SameValue(args, Receiver) is false, then */
  if (SameValue(args, Receiver) = false) {
    /* a. Let isMapped be false. */
    isMapped := false;
  /* 3. Else, */
  } else {
    /* a. Let map be the value of the [[ParameterMap]] internal slot of the arguments object.*/
    map := args.ParameterMap;
    /* b. Let isMapped be HasOwnProperty(map, P). */
    isMapped := HasOwnProperty(map, P);
    /* c. Assert: isMapped is not an abrupt completion. */
    assert(!(isAnAbruptCompletion(isMapped)));
  }
  /* 4. If isMapped is true, then */
  if (isMapped = true) {
    /* a. Let setStatus be Set(map, P, V, false). */
    setStatus := Set(map, P, V, false);
    /* b. Assert: setStatus is true because formal parameters mapped by argument
       objects are always writable. */
    assert((setStatus = true));
  }
  /* 5. Return the result of calling the default ordinary object [[Set]]
     internal method (9.1.9) on args passing P, V and Receiver as the
     arguments. */
  return OrdinaryObjectSet(args, P, V, Receiver);
}

function MakeArgGetter(name, lexicalEnvironment) {
  /* The abstract operation MakeArgGetter called with String name and environment record env creates a function
     object that when executed returns the value bound for name in env. It performs the following steps: */

  /* 1. Let body be the result of concatenating the Strings "return ", name, and ";". */
  body := lambda (scope, this, newTarget, strict, args) [name, lexicalEnvironment] {
    envRec := getEnvironmentRecord(lexicalEnvironment);
    val := getBindingValue(envRec, name);
    return val;
  };
  /* 2. Return the result of creating a function object as described in 13.2 using no FormalParameterList, body for
        FunctionBody, env as Scope, and true for Strict. */
  return CreateBuiltInFunctionObject([], body, lexicalEnvironment, true, null);
}

function MakeArgSetter(name, lexicalEnvironment) {
  /* The abstract operation MakeArgSetter called with String name and environment record env creates a function
     object that when executed sets the value bound for name in env. It performs the following steps: */

  /* 1. Let param be the String name concatenated with the String "_arg". */
  /* 2. Let body be the String "<name> = <param>;" with <name> replaced by the value of name and <param>
        replaced by the value of param. */
  body := lambda (scope, this, newTarget, strict, args) [name, lexicalEnvironment] {
    param := l_nth(args, 0);
    envRec := getEnvironmentRecord(lexicalEnvironment);
    setBindingValue(envRec, name, param);
    return 'undefined;
  };

  /* 3. Return the result of creating a function object as described in 13.2 using a List containing the single String
        param as FormalParameterList, body for FunctionBody, env as Scope, and true for Strict. */
  return CreateBuiltInFunctionObject(["param"], body, lexicalEnvironment, true, null);
}

/*
 * |--------------------------------|
 * | Integer Indexed Exotic objects |
 * |--------------------------------|
*/

/**
 * 9.4.5.1 [[GetOwnProperty]] (P)
 *
 * When the [[GetOwnProperty]] internal method of an Integer Indexed exotic
 * object O is called with property key P the following steps are taken:
 */
function IntegerIndexedGetOwnProperty(O, P) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) = true);
  /* 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot. */
  assert ((Type(O) = "Object") &&& ("ViewedArrayBuffer" in_obj O));
  /* 3. If Type(P) is String, then */
  if (Type(P) = "String") {
    /* a. Let numericIndex be CanonicalNumericIndexString(P). */
    numericIndex := CanonicalNumericIndexString(P);
    /* b. Assert: numericIndex is not an abrupt completion. */
    assert (!isAnAbruptCompletion(numericIndex));
    /* c. If numericIndex is not undefined, then */
    if (!(numericIndex = 'undefined)) {
      /* i. Let value be IntegerIndexedElementGet (O, numericIndex). */
      value := IntegerIndexedElementGet(O, numericIndex);
      /* ii. ReturnIfAbrupt(value). */
      @ReturnIfAbrupt(value);
      /* iii. If value is undefined, */
      if (value = 'undefined)
        /* return undefined */
        return 'undefined;
      /* iv. Return a PropertyDescriptor{ [[Value]]: value, [[Enumerable]]: true,
         [[Writable]]: true, [[Configurable]]: false }. */
      return newDataPropertyDescriptorFull(value, true, true, false);
    }
  }
  /* 4. Return OrdinaryGetOwnProperty(O, P). */
  return OrdinaryGetOwnProperty(O, P);
}

/**
 * 9.4.5.2 [[HasProperty]] (P)
 *
 * When the [[HasProperty]] internal method of an Integer Indexed exotic object
 * O is called with property key P, the following steps are taken:
 */
function IntegerIndexedHasProperty(O, P) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) = true);
  /* 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot. */
  assert ((Type(O) = "Object") &&& ("ViewedArrayBuffer" in_obj O));
  /* 3. If Type(P) is String, then */
  if (Type(P) = "String") {
    /* a. Let numericIndex be CanonicalNumericIndexString(P). */
    numericIndex := CanonicalNumericIndexString(P);
    /* b. Assert: numericIndex is not an abrupt completion. */
    assert (!isAnAbruptCompletion(numericIndex));
    /* c. If numericIndex is not undefined, then */
    if (!(numericIndex = 'undefined)) {
      /* i. Let buffer be the value of O's [[ViewedArrayBuffer]] internal slot. */
      buffer := O.ViewedArrayBuffer;
      /* ii. If IsDetachedBuffer(buffer) is true, */
      if (IsDetachedBuffer(buffer) = true)
        /* throw a TypeError exception */
        throw TypeErrorConstructorInternal();
      /* iii. If IsInteger(numericIndex) is false, return false */
      if (!(IsInteger(numericIndex)))
        return false;
      /* iv. If numericIndex = -0, */
      if (isMinusZero(numericIndex))
        /* return false */
        return false;
      /* v. If numericIndex < 0, */
      if (numericIndex < 0.)
        /* return false */
        return false;
      /* vi. If numericIndex ≥ the value of O's [[ArrayLength]] internal slot, */
      if (numericIndex >= O.ArrayLength)
        /* return false */
        return false;
      /* vii. Return true. */
      return true;
    }
  }
  /* 4. Return OrdinaryHasProperty(O, P). */
  return OrdinaryHasProperty(O, P);
}

/**
 * 9.4.5.3 [[DefineOwnProperty]] (P, Desc)
 *
 * When the [[DefineOwnProperty]] internal method of an Integer Indexed exotic
 * object O is called with property key P, and Property Descriptor Desc the
 * following steps are taken:
 */
function IntegerIndexedDefineOwnProperty(O, P, Desc) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) = true);
  /* 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot. */
  assert ((Type(O) = "Object") &&& ("ViewedArrayBuffer" in_obj O));
  /* 3. If Type(P) is String, then */
  if (Type(P) = "String") {
    /* a. Let numericIndex be CanonicalNumericIndexString (P). */
    numericIndex := CanonicalNumericIndexString(P);
    /* b. Assert: numericIndex is not an abrupt completion. */
    assert (!isAnAbruptCompletion(numericIndex));
    /* c. If numericIndex is not undefined, then */
    if (!(numericIndex = 'undefined)) {
      /* i. If IsInteger(numericIndex) is false, return false */
      if (!(IsInteger(numericIndex)))
        return false;
      /* ii. Let intIndex be numericIndex. */
      intIndex := numericIndex;
      /* iii. If intIndex = -0, */
      if (isMinusZero(intIndex))
        /* return false */
        return false;
      /* iv. If intIndex < 0, */
      if (intIndex < 0.)
        /* return false */
        return false;
      /* v. Let length be the value of O's [[ArrayLength]] internal slot. */
      length := O.ArrayLength;
      /* vi. If intIndex ≥ length, */
      if (intIndex >= length)
        /* return false */
        return false;
      /* vii. If IsAccessorDescriptor(Desc) is true, return false. */
      if (IsAccessorDescriptor(Desc))
        return false;
      /* viii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is
         true, return false. */
      if (("Configurable" in_obj Desc) &&& (Desc.Configurable = true))
        return false;
      /* ix. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is
         false, return false. */
      if (("Enumerable" in_obj Desc) &&& (Desc.Enumerable = false))
        return false;
      /* x. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, */
      if (("Writable" in_obj Desc) &&& (Desc.Writable = false))
        /* return false */
        return false;
      /* xi. If Desc has a [[Value]] field, then */
      if ("Value" in_obj Desc) {
        /* 1. Let value be Desc.[[Value]]. */
        value := Desc.Value;
        /* 2. Return IntegerIndexedElementSet (O, intIndex, value). */
        return IntegerIndexedElementSet(O, intIndex, value);
      }
      /* xii. Return true. */
      return true;
    }
  }
  /* 4. Return OrdinaryDefineOwnProperty(O, P, Desc). */
  return OrdinaryDefineOwnProperty(O, P, Desc);
}

/**
 * 9.4.5.4 [[Get]] (P, Receiver)
 *
 * When the [[Get]] internal method of an Integer Indexed exotic object O is
 * called with property key P and ECMAScript language value Receiver the
 * following steps are taken:
 */
function IntegerIndexedGet(O, P, Receiver) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) = true);
  /* 2. If Type(P) is String and if SameValue(O, Receiver) is true, then */
  if ((Type(P) = "String") &&& (SameValue(O, Receiver))) {
    /* a. Let numericIndex be CanonicalNumericIndexString (P). */
    numericIndex := CanonicalNumericIndexString(P);
    /* b. Assert: numericIndex is not an abrupt completion. */
    assert (!isAnAbruptCompletion(numericIndex));
    /* c. If numericIndex is not undefined, then */
    if (!(numericIndex = 'undefined))
      /* i. Return IntegerIndexedElementGet (O, numericIndex). */
      return IntegerIndexedElementGet(O, numericIndex);
  }
  /* 3. Return the result of calling the default ordinary object [[Get]]
     internal method (9.1.8) on O passing P and Receiver as arguments. */
  return OrdinaryObjectGet(O, P, Receiver);
}

/**
 * 9.4.5.5 [[Set]] (P, V, Receiver)
 *
 * When the [[Set]] internal method of an Integer Indexed exotic object O is
 * called with property key P, value V, and ECMAScript language value Receiver,
 * the following steps are taken:
 */
function IntegerIndexedSet(O, P, V, Receiver) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) = true);
  /* 2. If Type(P) is String and if SameValue(O, Receiver) is true, then */
  if ((Type(P) = "String") &&& (SameValue(O, Receiver))) {
    /* a. Let numericIndex be CanonicalNumericIndexString (P). */
    numericIndex := CanonicalNumericIndexString(P);
    /* b. Assert: numericIndex is not an abrupt completion. */
    assert (!isAnAbruptCompletion(numericIndex));
    /* c. If numericIndex is not undefined, then */
    if (!(numericIndex = 'undefined))
      /* i. Return IntegerIndexedElementSet (O, numericIndex, V). */
      return IntegerIndexedElementSet(O, numericIndex, V);
  }
  /* 3. Return the result of calling the default ordinary object [[Set]]
     internal method (9.1.8) on O passing P, V, and Receiver as arguments. */
  return OrdinaryObjectSet(O, P, V, Receiver);
}

/**
 * 9.4.5.6 [[OwnPropertyKeys]]
 *
 * When the [[OwnPropertyKeys]] internal method of an Integer Indexed exotic
 * object O is called the following steps are taken:
 */
function IntegerIndexedOwnPropertyKeys(O) {
  /* 1. Let keys be a new empty List. */
  keys := [];
  /* 2. Assert: O is an Object that has [[ViewedArrayBuffer]],
     [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
     slots. */
  assert ((Type(O) = "Object") &&& ("ViewedArrayBuffer" in_obj O) &&& ("ArrayLength" in_obj O) &&& ("ByteOffset" in_obj O) &&& ("TypedArrayName" in_obj O));
  /* 3. Let len be the value of O's [[ArrayLength]] internal slot. */
  len := O.ArrayLength;

  /* 4. For each integer i starting with 0 such that i < len, in ascending order, */
  i := 0.;
  while (i < len) {
    /* a. Add ToString(i) as the last element of keys.*/
    keys := l_concat(keys, [ToString(i)]);
    i := i + 1.;
  }

  /* 5. For each own property key P of O such that Type(P) is String and P is not an integer index, in property creation order */
  foreach (P : obj_fields O.JSProperties) {
    if ((Type(P) = "String") &&& !IsIntegerIndex(P)) {
      /* a. Add P as the last element of keys. */
      keys := l_concat(keys, [P]);
    }
  }

  /* 6. For each own property key P of O such that Type(P) is Symbol, in property creation order */
  foreach(P : obj_fields O.JSPropertiesSymbols) {
    P := O.SymbolKeys[P];
    if (Type(P) = "Symbol") {
      /* a. Add P as the last element of keys. */
      keys := l_concat(keys, [P]);
    }
  }
  /* 7. Return keys. */
  return keys;
}

/**
 * 9.4.5.7 IntegerIndexedObjectCreate (prototype, internalSlotsList)
 *
 * The abstract operation IntegerIndexedObjectCreate with arguments prototype
 * and internalSlotsList is used to specify the creation of new Integer Indexed
 * exotic objects. The argument internalSlotsList is a List of the names of
 * additional internal slots that must be defined as part of the object.
 * IntegerIndexedObjectCreate performs the following steps:
 */
function IntegerIndexedObjectCreate(prototype, internalSlotsList) {
  /* 1. Let A be a newly created object with an internal slot for each name in
     internalSlotsList. */
  A := NewECMAScriptObject();
  foreach (name : internalSlotsList)
    A[name] := 'undefined;
  /* 2. Set A's essential internal methods to the default ordinary object
     definitions specified in 9.1. */
  setAllInternalMethodsOfOrdinaryObject(A);
  /* 3. Set the [[GetOwnProperty]] internal method of A as specified in
     9.4.5.1. */
  setInternalProperty(A, "GetOwnProperty", "IntegerIndexedGetOwnProperty");
  /* 4. Set the [[HasProperty]] internal method of A as specified in 9.4.5.2. */
  setInternalProperty(A, "HasProperty", "IntegerIndexedHasProperty");
  /* 5. Set the [[DefineOwnProperty]] internal method of A as specified in
     9.4.5.3. */
  setInternalProperty(A, "DefineOwnProperty", "IntegerIndexedDefineOwnProperty");
  /* 6. Set the [[Get]] internal method of A as specified in 9.4.5.4. */
  setInternalProperty(A, "Get", "IntegerIndexedGet");
  /* 7. Set the [[Set]] internal method of A as specified in 9.4.5.5. */
  setInternalProperty(A, "Set", "IntegerIndexedSet");
  /* 8. Set the [[OwnPropertyKeys]] internal method of A as specified in
     9.4.5.6. */
  setInternalProperty(A, "OwnPropertyKeys", "IntegerIndexedOwnPropertyKeys");
  /* 9. Set the [[Prototype]] internal slot of A to prototype. */
  A.Prototype := prototype;
  /* 10. Set the [[Extensible]] internal slot of A to true. */
  A.Extensible := true;
  /* 11. Return A. */
  return A;
}

/**
 * 9.4.5.8 IntegerIndexedElementGet (O, index)
 *
 * The abstract operation IntegerIndexedElementGet with arguments O and index
 * performs the following steps:
 */
function IntegerIndexedElementGet(O, index) {
  /* 1. Assert: Type(index) is Number. */
  assert (Type(index) = "Number");
  /* 2. Assert: O is an Object that has [[ViewedArrayBuffer]],
     [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
     slots. */
  assert ((Type(O) = "Object") &&& ("ViewedArrayBuffer" in_obj O) &&& ("ArrayLength" in_obj O) &&& ("ByteOffset" in_obj O) &&& ("TypedArrayName" in_obj O));
  /* 3. Let buffer be the value of O's [[ViewedArrayBuffer]] internal slot. */
  buffer := O.ViewedArrayBuffer;
  /* 4. If IsDetachedBuffer(buffer) is true, */
  if (IsDetachedBuffer(buffer) = true)
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 5. If IsInteger(index) is false, return undefined */
  if (!IsInteger(index))
    return 'undefined;
  /* 6. If index = -0, */
  if (isMinusZero(index))
    /* return undefined */
    return 'undefined;
  /* 7. Let length be the value of O's [[ArrayLength]] internal slot. */
  length := O.ArrayLength;
  /* 8. If index < 0 or index ≥ length, */
  if ((index < 0.) ||| (index >= length))
    /* return undefined */
    return 'undefined;
  /* 9. Let offset be the value of O's [[ByteOffset]] internal slot. */
  offset := O.ByteOffset;
  /* 10. Let arrayTypeName be the String value of O's [[TypedArrayName]]
     internal slot. */
  arrayTypeName := O.TypedArrayName;
  /* 11. Let elementSize be the Number value of the Element Size value
     specified in Table 49 for arrayTypeName. */
  elementSize := |ElementTable|[arrayTypeName].size;
  /* 12. Let indexedPosition = (index × elementSize) + offset. */
  indexedPosition := (index * elementSize) + offset;
  /* 13. Let elementType be the String value of the Element Type value in Table
     49 for arrayTypeName. */
  elementType := |ElementTable|[arrayTypeName].type;
  /* 14. Return GetValueFromBuffer(buffer, indexedPosition, elementType). */
  return GetValueFromBuffer(buffer, int_of_float indexedPosition, elementType, 'undefined);
}

/**
 * 9.4.5.9 IntegerIndexedElementSet (O, index, value)
 *
 * The abstract operation IntegerIndexedElementSet with arguments O, index, and
 * value performs the following steps:
 */
function IntegerIndexedElementSet(O, index, value) {
  /* 1. Assert: Type(index) is Number. */
  assert (Type(index) = "Number");
  /* 2. Assert: O is an Object that has [[ViewedArrayBuffer]],
     [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
     slots. */
  assert ((Type(O) = "Object") &&& ("ViewedArrayBuffer" in_obj O) &&& ("ArrayLength" in_obj O) &&& ("ByteOffset" in_obj O) &&& ("TypedArrayName" in_obj O));
  /* 3. Let numValue be ToNumber(value). */
  numValue := ToNumber(value);
  /* 4. ReturnIfAbrupt(numValue). */
  @ReturnIfAbrupt(numValue);
  /* 5. Let buffer be the value of O's [[ViewedArrayBuffer]] internal slot. */
  buffer := O.ViewedArrayBuffer;
  /* 6. If IsDetachedBuffer(buffer) is true, */
  if (IsDetachedBuffer(buffer) = true)
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 7. If IsInteger(index) is false, return false */
  if (!IsInteger(index))
    return false;
  /* 8. If index = -0, */
  if (isMinusZero(index))
    /* return false */
    return false;
  /* 9. Let length be the value of O's [[ArrayLength]] internal slot. */
  length := O.ArrayLength;
  /* 10. If index < 0 or index ≥ length, */
  if ((index < 0.) ||| (index >= length))
    /* return false */
    return false;
  /* 11. Let offset be the value of O's [[ByteOffset]] internal slot. */
  offset := O.ByteOffset;
  /* 12. Let arrayTypeName be the String value of O's [[TypedArrayName]] internal slot. */
  arrayTypeName := O.TypedArrayName;
  /* 13. Let elementSize be the Number value of the Element Size value specified in Table 49 for arrayTypeName. */
  elementSize := |ElementTable|[arrayTypeName].size;
  /* 14. Let indexedPosition = (index × elementSize) + offset. */
  indexedPosition := (index * elementSize) + offset;
  /* 15. Let elementType be the String value of the Element Type value in Table 49 for arrayTypeName. */
  elementType := |ElementTable|[arrayTypeName].type;
  /* 16. Perform SetValueInBuffer(buffer, indexedPosition, elementType, numValue). */
  SetValueInBuffer(buffer, int_of_float indexedPosition, elementType, numValue, 'undefined);
  /* 17. Return true. */
  return true;
}

/**
 * An integer index is a String-valued property key that is a canonical numeric String (see 7.1.16)
 * and whose numeric value is either +0 or a positive integer ≤ 253−1.
 * An array index is an integer index whose numeric value i is in the range +0 ≤ i < 232−1.
 */
function IsIntegerIndex(idx) {
  canonicalNumericIndexString := CanonicalNumericIndexString(idx);
  if (canonicalNumericIndexString = 'undefined)
    return false;
  return (canonicalNumericIndexString >= 0.) &&& (canonicalNumericIndexString <= (253. - 1.));
}
