/**
* 9.5 Proxy Object Internal Methods and Internal Slots
*
*  Author : Tomas Tavares
*/

/**
*  A proxy object is an exotic object whose essential internal methods are partially implemented using ECMAScript code.
*  Every proxy objects has an internal slot called [[ProxyHandler]]. The value of [[ProxyHandler]] is an object, called
*  the proxy’s handler object, or null. Methods (see Table 30) of a handler object may be used to augment the implementation
*  for one or more of the proxy object’s internal methods. Every proxy object also has an internal slot called [[ProxyTarget]]
*  whose value is either an object or the null value. This object is called the proxy’s target object.
*
*    Table 30 — Proxy Handler Methods
*
*            ------------------------------------------------------
*            |    Internal Method  	 |       Handler Method       |
*            ------------------------|-----------------------------
*            | [[GetPrototypeOf]] 	 |       getPrototypeOf       |
*            | [[SetPrototypeOf]]  	 |        setPrototypeOf      |
*            | [[IsExtensible]] 	 |        isExtensible        |
*            | [[PreventExtensions]] |      preventExtensions     |
*            | [[GetOwnProperty]] 	 |   getOwnPropertyDescriptor |
*            | [[HasProperty]] 	     |             has            |
*            | [[Get]] 	             |             get            |
*            | [[Set]] 	             |             set            |
*            | [[Delete]] 	         |        deleteProperty      |
*            | [[DefineOwnProperty]] | 	     defineProperty       |
*            | [[Enumerate]]      	 |          enumerate         |
*            | [[OwnPropertyKeys]] 	 |           ownKeys          |
*            | [[Call]] 	         |            apply           |
*            | [[Construct]] 	     |          construct         |
*            ------------------------------------------------------
*
*  When a handler method is called to provide the implementation of a proxy object internal method, the handler method
*  is passed the proxy’s target object as a parameter. A proxy’s handler object does not necessarily have a method
*  corresponding to every essential internal method. Invoking an internal method on the proxy results in the invocation
*  of the corresponding internal method on the proxy’s target object if the handler object does not have a method
*  corresponding to the internal trap.
*
*  The [[ProxyHandler]] and [[ProxyTarget]] internal slots of a proxy object are always initialized when the object is
*  created and typically may not be modified. Some proxy objects are created in a manner that permits them to be subsequently
*  revoked. When a proxy is revoked, its [[ProxyHandler]] and [[ProxyTarget]] internal slots are set to null causing subsequent
*  invocations of internal methods on that proxy object to throw a TypeError exception.
*
*  Because proxy objects permit the implementation of internal methods to be provided by arbitrary ECMAScript code, it is
*  possible to define a proxy object whose handler methods violates the invariants defined in 6.1.7.3. Some of the
*  internal method invariants defined in 6.1.7.3 are essential integrity invariants. These invariants are explicitly
*  enforced by the proxy object internal methods specified in this section. An ECMAScript implementation must be robust
*  in the presence of all possible invariant violations.
*
*  In the following algorithm descriptions, assume O is an ECMAScript proxy object, P is a property key value, V
*  is any ECMAScript language value and Desc is a Property Descriptor record
*
*/

function IsProxy(O) {
  return "ProxyHandler" in_obj O;
}


/**
* 9.5.1 [[GetPrototypeOf]] ( )
*
*  When the [[GetPrototypeOf]] internal method of a Proxy exotic object O
*  is called the following steps are taken:
*
*/

function GetPrototypeOfProxy (O) {
  /* 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.*/
  handler := O.ProxyHandler;
  /* 2. If handler is null, throw a TypeError exception.*/
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 3. Assert: Type(handler) is Object.*/
  assert (Type(handler) == "Object");
  /* 4. Let target be the value of the [[ProxyTarget]] internal slot of O.*/
  target := O.ProxyTarget;
  /* 5. Let trap be GetMethod(handler, "getPrototypeOf").*/
  trap := GetMethod(handler, "getPrototypeOf");
  /* 6. ReturnIfAbrupt(trap).*/
  @ReturnIfAbrupt(trap);
  /* 7. If trap is undefined, then*/
  if (trap == 'undefined)
    /* a. Return target.[[GetPrototypeOf]]().*/
    return {target.GetPrototypeOf}(target);
  /* 8. Let handlerProto be Call(trap, handler, «target»).*/
  handlerProto := Call(null, null, trap, handler, [target]);
  /* 9. ReturnIfAbrupt(handlerProto).*/
  @ReturnIfAbrupt(handlerProto);
  /* 10. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.*/
  if (!((Type(handlerProto) == "Object") ||| (Type(handlerProto) == "Null")))
    throw TypeErrorConstructorInternal();
  /* 11. Let extensibleTarget be IsExtensible(target).*/
  extensibleTarget := IsExtensible(target);
  /* 12. ReturnIfAbrupt(extensibleTarget).*/
  @ReturnIfAbrupt(extensibleTarget);
  /* 13. If extensibleTarget is true, return handlerProto.*/
  if (extensibleTarget == true)
    return handlerProto;
  /* 14. Let targetProto be target.[[GetPrototypeOf]]().*/
  targetProto := {target.GetPrototypeOf}(target);
  /* 15. ReturnIfAbrupt(targetProto).*/
  @ReturnIfAbrupt(targetProto);
  /* 16. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.*/
  if (SameValue(handlerProto, targetProto) == false)
    throw TypeErrorConstructorInternal();
  /* 17. Return handlerProto.*/
  return handlerProto;
}

/**
*  NOTE [[GetPrototypeOf]] for proxy objects enforces the following invariant:
*
*   The result of [[GetPrototypeOf]] must be either an Object or null.
*
*   If the target object is not extensible, [[GetPrototypeOf]] applied to the proxy object must return
*   the same value as [[GetPrototypeOf]] applied to the proxy object’s target object.
*/



/**
* 9.5.2 [[SetPrototypeOf]] (V)
*
*  When the [[SetPrototypeOf]] internal method of a Proxy exotic object O is called with argument V the following
*  steps are taken:
*
*/

function SetPrototypeOfProxy (O, V) {
  /* 1. Assert: Either Type(V) is Object or Type(V) is Null. */
  assert ((Type(V) == "Object") ||| (Type(V) == "Null"));
  /* 2. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 3. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 4. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 5. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 6. Let trap be GetMethod(handler, "setPrototypeOf"). */
  trap := GetMethod(handler, "setPrototypeOf");
  /* 7. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 8. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[SetPrototypeOf]](V). */
    return {target.SetPrototypeOf}(target, V);
  /* 9. Let booleanTrapResult be ToBoolean(Call(trap, handler, «target, V»)). */
  booleanTrapResult := ToBoolean(Call(null, null, trap, handler, [target, V]));
  /* 10. ReturnIfAbrupt(booleanTrapResult). */
  @ReturnIfAbrupt(booleanTrapResult);
  /* 11. Let extensibleTarget be IsExtensible(target). */
  extensibleTarget := IsExtensible(target);
  /* 12. ReturnIfAbrupt(extensibleTarget). */
  @ReturnIfAbrupt(extensibleTarget);
  /* 13. If extensibleTarget is true, return booleanTrapResult. */
  if (extensibleTarget == true)
    return booleanTrapResult;
  /* 14. Let targetProto be target.[[GetPrototypeOf]](). */
  targetProto := {target.GetPrototypeOf}(target);
  /* 15. ReturnIfAbrupt(targetProto). */
  @ReturnIfAbrupt(targetProto);
  /* 16. If booleanTrapResult is true and SameValue(V, targetProto) is false, throw a TypeError exception. */
  if ((booleanTrapResult == true) &&& (SameValue(V, targetProto) == false))
    throw TypeErrorConstructorInternal();
  /* 17. Return booleanTrapResult. */
  return booleanTrapResult;
}

/**
* NOTE [[SetPrototypeOf]] for proxy objects enforces the following invariant:
*
*  The result of [[SetPrototypeOf]] is a Boolean value.
*
*  If the target object is not extensible, the argument value must be the same
*  as the result of [[GetPrototypeOf]] applied to target object
*/



/**
* 9.5.3 [[IsExtensible]] ( )
*
*  When the [[IsExtensible]] internal method of a Proxy exotic object O is
*  called the following steps are taken:
*/

function IsExtensibleProxy (O) {
  /* 1. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 2. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 3. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 4. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 5. Let trap be GetMethod(handler, "isExtensible"). */
  trap := GetMethod(handler, "isExtensible");
  /* 6. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 7. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[IsExtensible]](). */
    return {target.IsExtensible}(target);
  /* 8. Let booleanTrapResult be ToBoolean(Call(trap, handler, «target»)). */
  booleanTrapResult := ToBoolean(Call(null, null, trap, handler, [target]));
  /* 9. ReturnIfAbrupt(booleanTrapResult). */
  @ReturnIfAbrupt(booleanTrapResult);
  /* 10. Let targetResult be target.[[IsExtensible]](). */
  targetResult := {target.IsExtensible}(target);
  /* 11. ReturnIfAbrupt(targetResult). */
  @ReturnIfAbrupt(targetResult);
  /* 12. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception. */
  if (SameValue(booleanTrapResult, targetResult) == false)
    throw TypeErrorConstructorInternal();
  /* 13. Return booleanTrapResult. */
  return booleanTrapResult;
}

/*
* NOTE [[IsExtensible]] for proxy objects enforces the following invariant:
*
*  The result of [[IsExtensible]] is a Boolean value.
*
*  [[IsExtensible]] applied to the proxy object must return the same value as [[IsExtensible]]
*   applied to the proxy object’s target object with the same argument.
*
*/



/**
* 9.5.4 [[PreventExtensions]] ( )
*
*  When the [[PreventExtensions]] internal method of a Proxy exotic object
*  O is called the following steps are taken:
*
*/

function PreventExtensionsProxy (O) {
  /* 1. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 2. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 3. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 4. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 5. Let trap be GetMethod(handler, "preventExtensions"). */
  trap := GetMethod(handler, "preventExtensions");
  /* 6. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 7. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[PreventExtensions]](). */
    return {target.PreventExtensions}(target);
  /* 8. Let booleanTrapResult be ToBoolean(Call(trap, handler, «target»)). */
  booleanTrapResult := ToBoolean(Call(null, null, trap, handler, [target]));
  /* 9. ReturnIfAbrupt(booleanTrapResult). */
  @ReturnIfAbrupt(booleanTrapResult);
  /* 10. If booleanTrapResult is true, then */
  if (booleanTrapResult == true) {
    /* a. Let targetIsExtensible be target.[[IsExtensible]](). */
    targetIsExtensible := {target.IsExtensible}(target);
    /* b. ReturnIfAbrupt(targetIsExtensible). */
    @ReturnIfAbrupt(targetIsExtensible);
    /* c. If targetIsExtensible is true, throw a TypeError exception. */
    if (targetIsExtensible == true)
      throw TypeErrorConstructorInternal();
  }
  /* 12. Return booleanTrapResult. */
  return booleanTrapResult;
}

/*
* NOTE [[PreventExtensions]] for proxy objects enforces the following invariant:
*
*  The result of [[PreventExtensions]] is a Boolean value.
*
*  [[PreventExtensions]] applied to the proxy object only returns true if [[IsExtensible]]
*  applied to the proxy object’s target object is false.
*
*/



/**
* 9.5.5 [[GetOwnProperty]] (P)
*
*  When the [[GetOwnProperty]] internal method of a Proxy exotic object O is called
*  with property key P, the following steps are taken:
*
*/

function GetOwnPropertyProxy (O, P) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) == true);
  /* 2. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 3. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 4. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 5. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 6. Let trap be GetMethod(handler, "getOwnPropertyDescriptor"). */
  trap := GetMethod(handler, "getOwnPropertyDescriptor");
  /* 7. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 8. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[GetOwnProperty]](P). */
    return {target.GetOwnProperty}(target, P);
  /* 9. Let trapResultObj be Call(trap, handler, «target, P»). */
  trapResultObj := Call(null, null, trap, handler, [target, P]);
  /* 10. ReturnIfAbrupt(trapResultObj). */
  @ReturnIfAbrupt(trapResultObj);
  /* 11. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception. */
  t := Type(trapResultObj);
  if (!(t == "Object" ||| t == "Undefined"))
    throw TypeErrorConstructorInternal();
  /* 12. Let targetDesc be target.[[GetOwnProperty]](P). */
  targetDesc := {target.GetOwnProperty}(target, P);
  /* 13. ReturnIfAbrupt(targetDesc). */
  @ReturnIfAbrupt(targetDesc);
  /* 14. If trapResultObj is undefined, then */
  if (trapResultObj == 'undefined) {
    /* a. If targetDesc is undefined, return undefined. */
    if (targetDesc == 'undefined)
      return 'undefined;
    /* b. If targetDesc.[[Configurable]] is false, throw a TypeError exception. */
    if (targetDesc.Configurable == false)
      throw TypeErrorConstructorInternal();
    /* c. Let extensibleTarget be IsExtensible(target). */
    extensibleTarget := IsExtensible(target);
    /* d. ReturnIfAbrupt(extensibleTarget). */
    @ReturnIfAbrupt(extensibleTarget);
    /* e. Assert: Type(extensibleTarget) is Boolean. */
    assert (Type(extensibleTarget) == "Boolean");
    /* f. If extensibleTarget is false, throw a TypeError exception. */
    if (extensibleTarget == false)
      throw TypeErrorConstructorInternal();
    /* g. Return undefined. */
    return 'undefined;
  }
  /* 15. Let extensibleTarget be IsExtensible(target). */
  extensibleTarget := IsExtensible(target);
  /* 16. ReturnIfAbrupt(extensibleTarget). */
  @ReturnIfAbrupt(extensibleTarget);
  /* 17. Let resultDesc be ToPropertyDescriptor(trapResultObj). */
  resultDesc := ToPropertyDescriptor(trapResultObj);
  /* 18. ReturnIfAbrupt(resultDesc). */
  @ReturnIfAbrupt(resultDesc);
  /* 19. Call CompletePropertyDescriptor(resultDesc). */
  CompletePropertyDescriptor(resultDesc);
  /* 20. Let valid be IsCompatiblePropertyDescriptor (extensibleTarget, resultDesc, targetDesc). */
  valid := IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc);
  /* 21. If valid is false, throw a TypeError exception. */
  if (valid == false)
      throw TypeErrorConstructorInternal();
  /* 22. If resultDesc.[[Configurable]] is false, then */
  if (resultDesc.Configurable == false) {
    /* a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then */
    if (targetDesc == 'undefined ||| targetDesc.Configurable == true)
      /* i. Throw a TypeError exception. */
      throw TypeErrorConstructorInternal();
  }
  /* 23. Return resultDesc. */
  return resultDesc;
}

/**
* NOTE [[GetOwnProperty]] for proxy objects enforces the following invariants:
*
*  The result of [[GetOwnProperty]] must be either an Object or undefined.
*
*  A property cannot be reported as non-existent, if it exists as a
*  non-configurable own property of the target object.
*
*  A property cannot be reported as non-existent, if it exists as an own property
*  of the target object and the target object is not extensible.
*
*  A property cannot be reported as existent, if it does not exists as an own property
*  of the target object and the target object is not extensible.
*
*  A property cannot be reported as non-configurable, if it does not exists as an own
*  property of the target object or if it exists as a configurable own property of
*  the target object.
*
*/



/**
*
* 9.5.6 [[DefineOwnProperty]] (P, Desc)
*
*  When the [[DefineOwnProperty]] internal method of a Proxy exotic object O is called
*  with property key P and Property Descriptor Desc, the following steps are taken:
*
*/

function DefineOwnPropertyProxy (O, P, Desc) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) == true);
  /* 2. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 3. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 4. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 5. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 6. Let trap be GetMethod(handler, "defineProperty"). */
  trap := GetMethod(handler, "defineProperty");
  /* 7. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 8. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[DefineOwnProperty]](P, Desc). */
    return {target.DefineOwnProperty}(target, P, Desc);
  /* 9. Let descObj be FromPropertyDescriptor(Desc). */
  descObj := FromPropertyDescriptor(Desc);
  /* 10. Let booleanTrapResult be ToBoolean(Call(trap, handler, «target, P, descObj»)). */
  booleanTrapResult := ToBoolean(Call(null, null, trap, handler, [target, P, descObj]));
  /* 11. ReturnIfAbrupt(booleanTrapResult). */
  @ReturnIfAbrupt(booleanTrapResult);
  /* 12. If booleanTrapResult is false, return false. */
  if (booleanTrapResult == false)
      return false;
  /* 13. Let targetDesc be target.[[GetOwnProperty]](P). */
  targetDesc := {target.GetOwnProperty}(target, P);
  /* 14. ReturnIfAbrupt(targetDesc). */
  @ReturnIfAbrupt(targetDesc);
  /* 15. Let extensibleTarget be IsExtensible(target). */
  extensibleTarget := IsExtensible(target);
  /* 16. ReturnIfAbrupt(extensibleTarget). */
  @ReturnIfAbrupt(extensibleTarget);
  /* 17. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then */
  if (("Configurable" in_obj Desc) &&& (Desc.Configurable == false))
    /* a. Let settingConfigFalse be true. */
    settingConfigFalse := true;
  /* 18. Else let settingConfigFalse be false. */
  else
    settingConfigFalse := false;
  /* 19. If targetDesc is undefined, then */
  if (targetDesc == 'undefined) {
    /* a. If extensibleTarget is false, throw a TypeError exception. */
    if (extensibleTarget == false)
      throw TypeErrorConstructorInternal();
    /* b. If settingConfigFalse is true, throw a TypeError exception. */
    if (settingConfigFalse == true)
      throw TypeErrorConstructorInternal();
  /* 20. Else targetDesc is not undefined, */
  } else {
    /* a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc , targetDesc) is false, throw a TypeError exception. */
    if (IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) == false)
      throw TypeErrorConstructorInternal();
    /* b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception. */
    if ((settingConfigFalse == true) &&& (targetDesc.Configurable == true))
      throw TypeErrorConstructorInternal();
  }
  /* 21. Return true. */
  return true;
}

/*
* NOTE [[DefineOwnProperty]] for proxy objects enforces the following invariants:
*
*  The result of [[DefineOwnProperty]] is a Boolean value.
*
*  A property cannot be added, if the target object is not extensible.
*
*  A property cannot be non-configurable, unless there exists a corresponding non-configurable
*  own property of the target object.
*
*  If a property has a corresponding target object property then applying the Property
*  Descriptor of the property to the target object using [[DefineOwnProperty]] will not throw an exception.
*
*/


/**
* 9.5.7 [[HasProperty]] (P)
*
*  When the [[HasProperty]] internal method of a Proxy exotic object O is called with property key P,
*  the following steps are taken:
*
*/

function HasPropertyProxy (O, P) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) == true);
  /* 2. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 3. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 4. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 5. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 6. Let trap be GetMethod(handler, "has"). */
  trap := GetMethod(handler, "has");
  /* 7. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 8. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[HasProperty]](P). */
    return {target.HasProperty}(target, P);
  /* 9. Let booleanTrapResult be ToBoolean(Call(trap, handler, «target, P»)). */
  booleanTrapResult := ToBoolean(Call(null, null, trap, handler, [target, P]));
  /* 10. ReturnIfAbrupt(booleanTrapResult). */
  @ReturnIfAbrupt(booleanTrapResult);
  /* 11. If booleanTrapResult is false, then */
  if (booleanTrapResult == false) {
    /* a. Let targetDesc be target.[[GetOwnProperty]](P). */
    targetDesc := {target.GetOwnProperty}(target, P);
    /* b. ReturnIfAbrupt(targetDesc). */
    @ReturnIfAbrupt(targetDesc);
    /* c. If targetDesc is not undefined, then */
    if (targetDesc != 'undefined) {
      /* i. If targetDesc.[[Configurable]] is false, throw a TypeError exception. */
      if (targetDesc.Configurable == false)
        throw TypeErrorConstructorInternal();
      /* ii. Let extensibleTarget be IsExtensible(target). */
      extensibleTarget := IsExtensible(target);
      /* iii. ReturnIfAbrupt(extensibleTarget). */
      @ReturnIfAbrupt(extensibleTarget);
      /* iv. If extensibleTarget is false, throw a TypeError exception. */
      if (extensibleTarget == false)
        throw TypeErrorConstructorInternal();
    }
  }
  /* 12. Return booleanTrapResult. */
  return booleanTrapResult;
}

/**
* NOTE [[HasProperty]] for proxy objects enforces the following invariants:
*
*  The result of [[HasProperty]] is a Boolean value.
*
*  A property cannot be reported as non-existent, if it exists as a
*  non-configurable own property of the target object.
*
*  A property cannot be reported as non-existent, if it exists as an own
*  property of the target object and the target object is not extensible.
*
*/



/**
* 9.5.8 [[Get]] (P, Receiver)
*
*  When the [[Get]] internal method of a Proxy exotic object O is called with property
*  key P and ECMAScript language value Receiver the following steps are taken:
*
*/

function GetProxy (O, P, Receiver) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) == true);
  /* 2. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 3. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 4. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 5. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 6. Let trap be GetMethod(handler, "get"). */
  trap := GetMethod(handler, "get");
  /* 7. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 8. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[Get]](P, Receiver). */
    return {target.Get}(target, P, Receiver);
  /* 9. Let trapResult be Call(trap, handler, «target, P, Receiver»). */
  trapResult := Call(null, null, trap, handler, [target, P, Receiver]);
  /* 10. ReturnIfAbrupt(trapResult). */
  @ReturnIfAbrupt(trapResult);
  /* 11. Let targetDesc be target.[[GetOwnProperty]](P). */
  targetDesc := {target.GetOwnProperty}(target, P);
  /* 12. ReturnIfAbrupt(targetDesc). */
  @ReturnIfAbrupt(targetDesc);
  /* 13. If targetDesc is not undefined, then */
  if (targetDesc != 'undefined) {
    /* a. If IsDataDescriptor(targetDesc) and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then */
    if ((IsDataDescriptor(targetDesc) == true) &&& (targetDesc.Configurable == false) &&& (targetDesc.Writable == false)) {
      /* i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception. */
      if (SameValue(trapResult, targetDesc.Value) == false)
        throw TypeErrorConstructorInternal();
    }
    /* b. If IsAccessorDescriptor(targetDesc) and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, then */
    if ((IsAccessorDescriptor(targetDesc) == true) &&& (targetDesc.Configurable == false) &&& (targetDesc.Get == 'undefined)) {
      /* i. If trapResult is not undefined, throw a TypeError exception. */
      if (trapResult != 'undefined)
        throw TypeErrorConstructorInternal();
    }
  }
  /* 14. Return trapResult. */
  return trapResult;
}

/*
* NOTE [[Get]] for proxy objects enforces the following invariants:
*
*  The value reported for a property must be the same as the value of the corresponding target object
*  property if the target object property is a non-writable, non-configurable own data property.
*
*  The value reported for a property must be undefined if the corresponding target object property
*  is a non-configurable own accessor property that has undefined as its [[Get]] attribute.
*
*/



/**
*
* 9.5.9 [[Set]] ( P, V, Receiver)
*
*  When the [[Set]] internal method of a Proxy exotic object O is
*  called with property key P, value V, and ECMAScript language
*  value Receiver, the following steps are taken:
*
*/

function SetProxy (O, P, V, Receiver) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) == true);
  /* 2. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 3. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
      throw TypeErrorConstructorInternal();
  /* 4. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 5. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 6. Let trap be GetMethod(handler, "set"). */
  trap := GetMethod(handler, "set");
  /* 7. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 8. If trap is undefined, then */
  if (trap == 'undefined)
      /* a. Return target.[[Set]](P, V, Receiver). */
      return {target.Set}(target, P, V, Receiver);
  /* 9. Let booleanTrapResult be ToBoolean(Call(trap, handler, «target, P, V, Receiver»)). */
  booleanTrapResult := ToBoolean(Call(null, null, trap, handler, [target, P, V, Receiver]));
  /* 10. ReturnIfAbrupt(booleanTrapResult). */
  @ReturnIfAbrupt(booleanTrapResult);
  /* 11. If booleanTrapResult is false, return false. */
  if (booleanTrapResult == false)
    return false;
  /* 12. Let targetDesc be target.[[GetOwnProperty]](P). */
  targetDesc := {target.GetOwnProperty}(target, P);
  /* 13. ReturnIfAbrupt(targetDesc). */
  @ReturnIfAbrupt(targetDesc);
  /* 14. If targetDesc is not undefined, then */
  if (targetDesc != 'undefined) {
    /* a. If IsDataDescriptor(targetDesc) and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then */
    if ((IsDataDescriptor(targetDesc) == true) &&& (targetDesc.Configurable == false) &&& (targetDesc.Writable == false)) {
      /* i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception. */
      if (SameValue(V, targetDesc.Value) == false)
        throw TypeErrorConstructorInternal();
    }
    /* b. If IsAccessorDescriptor(targetDesc) and targetDesc.[[Configurable]] is false, then */
    if ((IsAccessorDescriptor(targetDesc) == true) &&& targetDesc.Configurable == false) {
      /* i. If targetDesc.[[Set]] is undefined, throw a TypeError exception. */
      if (targetDesc.Set == 'undefined)
        throw TypeErrorConstructorInternal();
    }
  }
  /* 15. Return true. */
  return true;
}

/*
* NOTE [[Set]] for proxy objects enforces the following invariants:
*
*  The result of [[Set]] is a Boolean value.
*
*  Cannot change the value of a property to be different from the value of
*  the corresponding target object property if the corresponding target object
*  property is a non-writable, non-configurable own data property.
*
*  Cannot set the value of a property if the corresponding target object
*  property is a non-configurable own accessor property that has undefined
*  as its [[Set]] attribute.
*
*/



/**
* 9.5.10 [[Delete]] (P)
*
*  When the [[Delete]] internal method of a Proxy exotic object O is
*  called with property key P the following steps are taken:
*
*/

function DeleteProxy (O, P) {
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert (IsPropertyKey(P) == true);
  /* 2. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 3. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 4. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 5. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 6. Let trap be GetMethod(handler, "deleteProperty"). */
  trap := GetMethod(handler, "deleteProperty");
  /* 7. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 8. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[Delete]](P). */
    return {target.Delete}(target, P);
  /* 9. Let booleanTrapResult be ToBoolean(Call(trap, handler, «target, P»)). */
  booleanTrapResult := ToBoolean(Call(null, null, trap, handler, [target, P]));
  /* 10. ReturnIfAbrupt(booleanTrapResult). */
  @ReturnIfAbrupt(booleanTrapResult);
  /* 11. If booleanTrapResult is false, return false. */
  if (booleanTrapResult == false)
    return false;
  /* 12. Let targetDesc be target.[[GetOwnProperty]](P). */
  targetDesc := {target.GetOwnProperty}(target, P);
  /* 13. ReturnIfAbrupt(targetDesc). */
  @ReturnIfAbrupt(targetDesc);
  /* 14. If targetDesc is undefined, return true. */
  if (targetDesc == 'undefined)
    return true;
  /* 15. If targetDesc.[[Configurable]] is false, throw a TypeError exception. */
  if (targetDesc.Configurable == false)
    throw TypeErrorConstructorInternal();
  /* 16. Return true. */
  return true;
}

/*
* NOTE [[Delete]] for proxy objects enforces the following invariant:
*
*  The result of [[Delete]] is a Boolean value.
*
*  A property cannot be reported as deleted, if it exists as a
*  non-configurable own property of the target object.
*
*/



/**
* 9.5.11 [[Enumerate]] ()
*
*  When the [[Enumerate]] internal method of a Proxy exotic object O
*  is called the following steps are taken:
*
*/

function EnumerateProxy (O) {
  /* 1. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 2. If handler is null, throw a TypeError exception. */
  if (handler == 'null)
    throw TypeErrorConstructorInternal();
  /* 3. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 4. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 5. Let trap be GetMethod(handler, "enumerate"). */
  trap := GetMethod(handler, "enumerate");
  /* 6. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 7. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[Enumerate]](). */
    return {target.Enumerate}(target);
  /* 8. Let trapResult be Call(trap, handler, «target»). */
  trapResult := Call(null, null, trap, handler, [target]);
  /* 9. ReturnIfAbrupt(trapResult). */
  @ReturnIfAbrupt(trapResult);
  /* 11. If Type(trapResult) is not Object, throw a TypeError exception. */
  if (Type(trapResult) != "Object")
    throw TypeErrorConstructorInternal();
  /* 12. Return trapResult. */
  return trapResult;
}

/*
* NOTE [[Enumerate]] for proxy objects enforces the following invariants:
*
*    The result of [[Enumerate]] must be an Object.
*/

/**
 * 9.5.12 [[OwnPropertyKeys]]
 *
 * When the [[OwnPropertyKeys]] internal method of a Proxy exotic object O is
 * called the following steps are taken:
 */
function OwnPropertyKeysProxy(O) {
  /* 1. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 2. If handler is null, */
  if (handler == 'null)
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 3. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 4. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 5. Let trap be GetMethod(handler, "ownKeys"). */
  trap := GetMethod(handler, "ownKeys");
  /* 6. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 7. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return target.[[OwnPropertyKeys]](). */
    return {target.OwnPropertyKeys}(target);
  /* 8. Let trapResultArray be Call(trap, handler, «target»). */
  trapResultArray := Call(null, null, trap, handler, [target]);
  /* 9. Let trapResult be CreateListFromArrayLike(trapResultArray, «‍String, Symbol»). */
  trapResult := CreateListFromArrayLike(trapResultArray, ["String", "Symbol"]);
  /* 10. ReturnIfAbrupt(trapResult). */
  @ReturnIfAbrupt(trapResult);
  /* 11. Let extensibleTarget be IsExtensible(target). */
  extensibleTarget := IsExtensible(target);
  /* 12. ReturnIfAbrupt(extensibleTarget). */
  @ReturnIfAbrupt(extensibleTarget);
  /* 13. Let targetKeys be target.[[OwnPropertyKeys]](). */
  targetKeys := {target.OwnPropertyKeys}(target);
  /* 14. ReturnIfAbrupt(targetKeys). */
  @ReturnIfAbrupt(targetKeys);
  /* 15. Assert: targetKeys is a List containing only String and Symbol values. */
  assert (true/* TODO: Instruction not yet implemented. */);
  /* 16. Let targetConfigurableKeys be an empty List. */
  targetConfigurableKeys := [];
  /* 17. Let targetNonconfigurableKeys be an empty List. */
  targetNonconfigurableKeys := [];
  /* 18. Repeat, for each element key of targetKeys, */
  foreach (key : targetKeys) {
    /* a. Let desc be target.[[GetOwnProperty]](key). */
    desc := {target.GetOwnProperty}(target, key);
    /* b. ReturnIfAbrupt(desc). */
    @ReturnIfAbrupt(desc);
    /* c. If desc is not undefined and desc.[[Configurable]] is false, then */
    if ((desc != 'undefined) &&& (desc.Configurable == false)) {
      /* i. Append key as an element of targetNonconfigurableKeys. */
      targetNonconfigurableKeys := l_add(targetNonconfigurableKeys, key);
    /* d. Else, */
    } else {
      /* i. Append key as an element of targetConfigurableKeys. */
      targetConfigurableKeys := l_add(targetConfigurableKeys, key);
    }
  }
  /* 19. If extensibleTarget is true and targetNonconfigurableKeys is empty, then */
  if (extensibleTarget &&& (l_len(targetNonconfigurableKeys) == 0)) {
    /* a. Return trapResult. */
    return trapResult;
  }
  /* 20. Let uncheckedResultKeys be a new List which is a copy of trapResult. */
  uncheckedResultKeys := [];
  foreach (elem : trapResult)
    uncheckedResultKeys := l_add(uncheckedResultKeys, elem);
  /* 21. Repeat, for each key that is an element of targetNonconfigurableKeys, */
  foreach (key : targetNonconfigurableKeys) {
    /* a. If key is not an element of uncheckedResultKeys, throw a TypeError exception. */
    if (!(in_list(key, uncheckedResultKeys)))
      throw TypeErrorConstructorInternal();
    /* b. Remove key from uncheckedResultKeys */
    uncheckedResultKeys := l_remove(uncheckedResultKeys, key);
  }
  /* 22. If extensibleTarget is true, */
  if (extensibleTarget == true)
    /* return trapResult */
    return trapResult;
  /* 23. Repeat, for each key that is an element of targetConfigurableKeys, */
  foreach (key : targetConfigurableKeys) {
    /* a. If key is not an element of uncheckedResultKeys, throw a TypeError exception. */
    if (!(in_list(key, uncheckedResultKeys)))
        throw TypeErrorConstructorInternal();
    /* b. Remove key from uncheckedResultKeys */
    uncheckedResultKeys := l_remove(uncheckedResultKeys, key);
  }
  /* 24. If uncheckedResultKeys is not empty, */
  if (l_len(uncheckedResultKeys) != 0)
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 25. Return trapResult. */
  return trapResult;
}
/**
 * NOTE [[OwnPropertyKeys]] for proxy objects enforces the following invariants:
 *
 * The result of [[OwnPropertyKeys]] is a List.
 *
 * The Type of each result List element is either String or Symbol.
 *
 * The result List must contain the keys of all non-configurable own properties
 * of the target object.
 *
 * If the target object is not extensible, then the result List must contain all
 * the keys of the own properties of the target object and no other values.
 */


/**
 * 9.5.13 [[Call]] (thisArgument, argumentsList)
 *
 * The [[Call]] internal method of a Proxy exotic object O is called with
 * parameters thisArgument and argumentsList, a List of ECMAScript language
 * values. The following steps are taken:
 */
function CallProxy(externalScope, ref, O, thisArgument, NewTarget, argumentsList) {
  /* 1. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 2. If handler is null, */
  if (handler == 'null)
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 3. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 4. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 5. Let trap be GetMethod(handler, "apply"). */
  trap := GetMethod(handler, "apply");
  /* 6. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 7. If trap is undefined, then */
  if (trap == 'undefined)
    /* a. Return Call(target, thisArgument, argumentsList). */
    return Call(null, null, target, thisArgument, argumentsList);
  /* 8. Let argArray be CreateArrayFromList(argumentsList). */
  argArray := CreateArrayFromList(argumentsList);
  /* 9. Return Call(trap, handler, «target, thisArgument, argArray»). */
  return Call(null, null, trap, handler, [target, thisArgument, argArray]);
}
/**
 * NOTE A Proxy exotic object only has a [[Call]] internal method if the initial
 * value of its [[ProxyTarget]] internal slot is an object that has a [[Call]]
 * internal method.
 */

/**
 * 9.5.14 [[Construct]] (argumentsList, newTarget)
 *
 * The [[Construct]] internal method of a Proxy exotic object O is called with
 * parameters argumentsList which is a possibly empty List of ECMAScript
 * language values and newTarget. The following steps are taken:
 */
function ConstructProxy(externalScope, ref, O, argumentsList, newTarget) {
  /* 1. Let handler be the value of the [[ProxyHandler]] internal slot of O. */
  handler := O.ProxyHandler;
  /* 2. If handler is null, */
  if (handler == 'null)
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 3. Assert: Type(handler) is Object. */
  assert (Type(handler) == "Object");
  /* 4. Let target be the value of the [[ProxyTarget]] internal slot of O. */
  target := O.ProxyTarget;
  /* 5. Let trap be GetMethod(handler, "construct"). */
  trap := GetMethod(handler, "construct");
  /* 6. ReturnIfAbrupt(trap). */
  @ReturnIfAbrupt(trap);
  /* 7. If trap is undefined, then */
  if (trap == 'undefined) {
    /* a. Assert: target has a [[Construct]] internal method. */
    assert ("Construct" in_obj target);
    /* b. Return Construct(target, argumentsList, newTarget). */
    return Construct(null, null, target, argumentsList, newTarget);
  }
  /* 8. Let argArray be CreateArrayFromList(argumentsList). */
  argArray := CreateArrayFromList(argumentsList);
  /* 9. Let newObj be Call(trap, handler, «target, argArray, newTarget »). */
  newObj := Call(null, null, trap, handler, [target, argArray, newTarget]);
  /* 10. ReturnIfAbrupt(newObj). */
  @ReturnIfAbrupt(newObj);
  /* 11. If Type(newObj) is not Object, */
  if (Type(newObj) != "Object")
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal();
  /* 12. Return newObj. */
  return newObj;
}
/**
 * NOTE 1 A Proxy exotic object only has a [[Construct]] internal method if the
 * initial value of its [[ProxyTarget]] internal slot is an object that has a
 * [[Construct]] internal method.
 *
 * NOTE 2 [[Construct]] for proxy objects enforces the following invariants:
 */


/**
* 9.5.15 ProxyCreate(target, handler)
*
*  The abstract operation ProxyCreate with arguments target and handler is used to specify the creation
*  of new Proxy exotic objects. It performs the following steps:
*
*/

function ProxyCreate(target, handler) {
  /* 1. If Type(target) is not Object, throw a TypeError exception. */
  if (Type(target) != "Object")
    throw TypeErrorConstructorInternal();
  /* 2. If target is a Proxy exotic object and the value of the [[ProxyHandler]] internal slot
        of target is null, throw a TypeError exception. */
  if (IsProxy(target) &&& (target.ProxyHandler == 'null))
    throw TypeErrorConstructorInternal();
  /* 3. If Type(handler) is not Object, throw a TypeError exception. */
  if (Type(handler) != "Object")
    throw TypeErrorConstructorInternal();
  /* 4. If handler is a Proxy exotic object and the value of the [[ProxyHandler]] internal slot
        of handler is null, throw a TypeError exception. */
  if (IsProxy(handler) &&& (handler.ProxyHandler == 'null))
    throw TypeErrorConstructorInternal();
  /* 5.Let P be a newly created object. */
  P := NewECMAScriptObject();
  setAllInternalMethodsOfOrdinaryObject(P);
  /* 6. Set P’s essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in 9.5. */
  setInternalProperty(P, "GetPrototypeOf", "GetPrototypeOfProxy");
  setInternalProperty(P, "SetPrototypeOf", "SetPrototypeOfProxy");
  setInternalProperty(P, "IsExtensible", "IsExtensibleProxy");
  setInternalProperty(P, "PreventExtensions", "PreventExtensionsProxy");
  setInternalProperty(P, "GetOwnProperty", "GetOwnPropertyProxy");
  setInternalProperty(P, "HasProperty", "HasPropertyProxy");
  setInternalProperty(P, "Get", "GetProxy");
  setInternalProperty(P, "Set", "SetProxy");
  setInternalProperty(P, "Delete", "DeleteProxy");
  setInternalProperty(P, "DefineOwnProperty", "DefineOwnPropertyProxy");
  setInternalProperty(P, "Enumerate", "EnumerateProxy");
  setInternalProperty(P, "OwnPropertyKeys", "OwnPropertyKeysProxy");
  /* 7. If IsCallable(target) is true, then */
  if (IsCallable(target) == true) {
    /* a. Set the [[Call]] internal method of P as specified in 9.5.13. */
    P.Call := "CallProxy";
    /* b. If target has a [[Construct]] internal method, then */
    if ("Construct" in_obj target)
      /* i. Set the [[Construct]] internal method of P as specified in 9.5.14. */
      P.Construct := "ConstructProxy";
  }
  /* 8. Set the [[ProxyTarget]] internal slot of P to target. */
  P.ProxyTarget := target;
  /* 9. Set the [[ProxyHandler]] internal slot of P to handler. */
  P.ProxyHandler := handler;
  /* 10. Return P. */
  return P;
}
