/* Auxiliary functions used to deal with Lexical Environments and Environment Records */

/* to get global object we will probably need to access the only global record */
function getGlobalObject(lexicalEnvironment) {
  if (!("EnvRec" in_obj lexicalEnvironment))
    return lexicalEnvironment;
  lex := lexicalEnvironment;
  outer := getOuterEnvironmentReference(lexicalEnvironment);
  while (outer != 'null) {
    lex := outer;
    outer := getOuterEnvironmentReference(lex);
  }

  return getBindingObject(getEnvironmentRecord(lex));
}

function getGlobalEnvironment(globalObject) {
  return globalObject.GlobalEnv;
}

function setGlobalEnvironment(globalObject, globalEnv) {
  globalObject.GlobalEnv := globalEnv;
  return;
}

function newLexicalEnvironment() {
  return {
    /* environment‘s outer environment reference */
    OuterEnvRef: 'undefined,
    /* environment‘s Environment Record */
    EnvRec: 'undefined
  };
}

function newDeclarativeEnvironmentRecord() {
  env := {
  	HasBinding: 						"HasBindingDeclarativeRecord",
  	CreateMutableBinding: 	"CreateMutableBindingDeclarativeRecord",
  	CreateImmutableBinding: "CreateImmutableBindingDeclarativeRecord",
  	InitializeBinding: 			"InitializeBindingDeclarativeRecord",
    SetMutableBinding: 			"SetMutableBindingDeclarativeRecord",
    GetBindingValue: 				"GetBindingValueDeclarativeRecord",
    DeleteBinding: 					"DeleteBindingDeclarativeRecord",
    HasThisBinding: 				"HasThisBindingDeclarativeRecord",
    HasSuperBinding: 				"HasSuperBindingDeclarativeRecord",
    WithBaseObject:  				"WithBaseObjectDeclarativeRecord"
  };

  return env;
}

function newFunctionEnvironmentRecord() {
	env := newDeclarativeEnvironmentRecord();

	env.BindThisValue 	:= "BindThisValue";
	env.GetThisBinding 	:= "GetThisBinding";
	env.GetSuperBase 		:= "GetSuperBase";
	env.HasThisBinding 	:= "HasThisBindingFunctionRecord";
	env.HasSuperBinding := "HasSuperBindingFunctionRecord";

	return env;
}

function newModuleEnvironmentRecord() {
	env := newDeclarativeEnvironmentRecord();

	env.GetBindingValue 		:= "GetBindingValueModuleRecord";
	env.DeleteBinding 			:= "DeleteBindingModuleRecord";
	env.HasThisBinding  		:= "HasThisBindingModuleRecord";
	env.GetThisBinding  		:= "GetThisBindingModuleRecord";
	env.CreateImportBinding := "CreateImportBinding";

	return env;
}

function newObjectEnvironmentRecord(bindingObj) {
  /* An object environment record binds the set of identifier names that directly correspond to the property names
     of its binding object. Property names that are not an IdentifierName are not included in the set of bound identifiers.
     Both own and inherited properties are included in the set regardless of the setting of their [[Enumerable]] attribute. */
  objEnvRec := {
    bindingObject: bindingObj,
    withEnvironment: false,
    provideThis: false,

    HasBinding: 						"HasBindingObjectRecord",
  	CreateMutableBinding: 	"CreateMutableBindingObjectRecord",
  	CreateImmutableBinding: "CreateImmutableBindingObjectRecord",
  	InitializeBinding: 			"InitializeBindingObjectRecord",
    SetMutableBinding: 			"SetMutableBindingObjectRecord",
    GetBindingValue: 				"GetBindingValueObjectRecord",
    DeleteBinding: 					"DeleteBindingObjectRecord",
    HasThisBinding: 				"HasThisBindingObjectRecord",
    HasSuperBinding: 				"HasSuperBindingObjectRecord",
    WithBaseObject:  				"WithBaseObjectObjectRecord"
  };

  return objEnvRec;
}

function newGlobalEnvironmentRecord() {
	env := {
		HasBinding: 										"HasBindingGlobalRecord",
		CreateMutableBinding:						"CreateMutableBindingGlobalRecord",
		CreateImmutableBinding: 				"CreateImmutableBindingGlobalRecord",
		InitializeBinding: 							"InitializeBindingGlobalRecord",
		SetMutableBinding: 							"SetMutableBindingGlobalRecord",
		GetBindingValue: 								"GetBindingValueGlobalRecord",
		DeleteBinding: 									"DeleteBindingGlobalRecord",
		HasThisBinding: 								"HasThisBindingGlobalRecord",
		HasSuperBinding: 								"HasSuperBindingGlobalRecord",
		WithBaseObject:  								"WithBaseObjectGlobalRecord",

		GetThisBinding:  								"GetThisBindingGlobalRecord",
		HasVarDeclaration:							"HasVarDeclaration",
		HasLexicalDeclaration:					"HasLexicalDeclaration",
		HasRestrictedGlobalProperty: 		"HasRestrictedGlobalProperty",
		CanDeclareGlobalVar:   					"CanDeclareGlobalVar",
		CanDeclareGlobalFunction:   		"CanDeclareGlobalFunction",
		CreateGlobalVarBinding: 				"CreateGlobalVarBinding",
		CreateGlobalFunctionBinding:    "CreateGlobalFunctionBinding"
	};

	return env;
}

function getBindingObject(objectEnvRec) {
  return objectEnvRec.bindingObject;
}

function setProvideThis(objectEnvironment, value) {
  getEnvironmentRecord(objectEnvironment).provideThis := value;

  return value; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function getProvideThis(objectEnvRec) {
  return objectEnvRec.provideThis;
}

function getEnvironmentRecord(lexicalEnvironment) {
  return lexicalEnvironment.EnvRec;
}

function getOuterEnvironmentReference(lexicalEnvironment) {
  return lexicalEnvironment.OuterEnvRef;
}

function setEnvironmentRecord(lexicalEnvironment, environmentRecord) {
  lexicalEnvironment.EnvRec := environmentRecord;
  return environmentRecord; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function setOuterLexicalEnvironmentReference(lexicalEnvironment, outerLexicalEnvironment) {
  lexicalEnvironment.OuterEnvRef := outerLexicalEnvironment;
  return outerLexicalEnvironment; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function createMutableBinding(declarativeEnvRec, name, value) {
  declarativeEnvRec[name] := newMutableBinding(value);
  return; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function createImmutableBinding(declarativeEnvRec, name) {
  declarativeEnvRec[name] := newImmutableBinding('undefined);
  return 'undefined; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function newBinding(initialised, value, deletable, modifiable, strict) {
  return [initialised, value, deletable, modifiable, strict];
}

function newMutableBinding(value) {
  return newBinding(false, value, false, true, false);
}

function newImmutableBinding(value) {
  return newBinding(false, value, false, false, false);
}

function isUninitialisedBinding(envRec, name) {
  binding := envRec[name];
  return !(l_nth(binding, 0));
}

function getBindingValue(envRec, name) {
  binding := envRec[name];
  return l_nth(binding, 1);
}

function isMutableBinding(envRec, name) {
  binding := envRec[name];
  return l_nth(binding, 3);
}

function isStrictBinding(envRec, name) {
  binding := envRec[name];
  return l_nth(binding, 4);
}

function setBindingValue(envRec, name, value) {
  binding := envRec[name];
  newBinding := newBinding(l_nth(binding, 0), value, l_nth(binding, 2), l_nth(binding, 3), l_nth(binding, 4));
  envRec[name] := newBinding;
  return; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function setBindingInitialised(envRec, name, initialised) {
  binding := envRec[name];
  newBinding := newBinding(initialised, l_nth(binding, 1), l_nth(binding, 2), l_nth(binding, 3), l_nth(binding, 4));
  envRec[name] := newBinding;
  return; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function setBindingDeletable(envRec, name, deletable) {
  binding := envRec[name];
  newBinding := newBinding(l_nth(binding, 0), l_nth(binding, 1), deletable, l_nth(binding, 3), l_nth(binding, 4));
  envRec[name] := newBinding;
  return; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function setBindingStrict(envRec, name, strict) {
  binding := envRec[name];
  newBinding := newBinding(l_nth(binding, 0), l_nth(binding, 1), l_nth(binding, 2), l_nth(binding, 3), strict);
  envRec[name] := newBinding;
  return; /* TODO the return statement is necessary because of the Monitor. Check why! */
}

function hasUninitialisedImmutableBinding(envRec, name) {
  return (name in_obj envRec) &&& isUninitialisedBinding(envRec, name);
}

function isBindingCannotBeDeleted(envRec, name) {
  binding := envRec[name];
  return !l_nth(binding, 2);
}



/*
8.1 Lexical Environments

A Lexical Environment is a specification type used to define the association of Identifiers to specific variables
and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of
an Environment Record and a possibly null reference to an outer Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of ECMAScript code such as a
FunctionDeclaration, a BlockStatement, or a Catch clause of a TryStatement and a new Lexical Environment is
created each time such code is evaluated.

An Environment Record records the identifier bindings that are created within the scope of its associated
Lexical Environment. It is referred to as the Lexical Environment’s EnvironmentRecord

The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer
reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds
the inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical
Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical
Environments. For example, if a FunctionDeclaration contains two nested FunctionDeclarations then the Lexical
Environments of each of the nested functions will have as their outer Lexical Environment the Lexical
Environment of the current evaluation of the surrounding function.

A global environment is a Lexical Environment which does not have an outer environment. The global
environment’s outer environment reference is null. A global environment’s EnvironmentRecord may be
prepopulated with identifier bindings and includes an associated global object whose properties provide some
of the global environment’s identifier bindings. This global object is the value of a global environment’s this
binding. As ECMAScript code is executed, additional properties may be added to the global object and the
initial properties may be modified.

A module environment is a Lexical Environment that contains the bindings for the top level declarations of a
Module. It also contains the bindings that are explicitly imported by the Module. The outer environment
of a module environment is a global environment.

A function environment is a Lexical Environment that corresponds to the invocation of an ECMAScript function
object. A function environment may establish a new this binding. A function environment also captures the
state necessary to support super method invocations.

Lexical Environments and Environment Record values are purely specification mechanisms and need not
correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript
program to directly access or manipulate such values.
*/

/*
8.1.1.1 Declarative Environment Records

Each declarative Environment Record is associated with an ECMAScript program scope containing variable,
constant, let, class, module, import, and/or function declarations. A declarative Environment Record binds the
set of identifiers defined by the declarations contained within its scope.

The behaviour of the concrete specification methods for declarative Environment Records is defined by the
following algorithms.
*/

/* 8.1.1.1.1 HasBinding(N) */
/* The concrete Environment Record method HasBinding for declarative Environment Records simply
   determines if the argument identifier is one of the identifiers bound by the record:
*/
function HasBindingDeclarativeRecord(envRec, N) {
	/* Let envRec be the declarative Environment Record for which the method was invoked. */

	/* If envRec has a binding for the name that is the value of N, return true. */
	if (N in_obj envRec)
		return true;
	/* Return false. */
	return false;
}

/* 8.1.1.1.2 CreateMutableBinding (N, D) */
/* The concrete Environment Record method CreateMutableBinding for declarative Environment Records creates
   a new mutable binding for the name N that is uninitialized. A binding must not already exist in this
   Environment Record for N. If Boolean argument D is provided and has the value true the new binding is marked
   as being subject to deletion.
*/
function CreateMutableBindingDeclarativeRecord(envRec, N, D) {
    /* Let envRec be the declarative Environment Record for which the method was invoked. */

    /* Assert: envRec does not already have a binding for N. */
    assert (!(N in_obj envRec));
    /* Create a mutable binding in envRec for N and record that it is uninitialized. If D is true record that the
       newly created binding may be deleted by a subsequent DeleteBinding call. */
    createMutableBinding(envRec, N, 'undefined);
    if (D == true)
    	setBindingDeletable(envRec, N, true);
    else
      setBindingDeletable(envRec, N, false);

    /* Return NormalCompletion(empty). */
    return NormalCompletion('empty);
}

/* 8.1.1.1.3 CreateImmutableBinding (N, S) */
/* The concrete Environment Record method CreateImmutableBinding for declarative Environment Records
   creates a new immutable binding for the name N that is uninitialized. A binding must not already exist in this
   Environment Record for N. If Boolean argument S is provided and has the value true the new binding is
   marked as a strict binding.
*/
function CreateImmutableBindingDeclarativeRecord(envRec, N, S) {
	/* Let envRec be the declarative Environment Record for which the method was invoked. */

	/* Assert: envRec does not already have a binding for N. */
	assert (!(N in_obj envRec));

	/* Create an immutable binding in envRec for N and record that it is uninitialized. If S is true record that
	the newly created binding is a strict binding. */
	createImmutableBinding(envRec, N);

	if (S == true)
		setBindingStrict(envRec, N, true);
	/* Return NormalCompletion(empty). */
	return NormalCompletion('empty);
}

/* 8.1.1.1.4 InitializeBinding (N,V) */
/* The concrete Environment Record method InitializeBinding for declarative Environment Records is used to set
   the bound value of the current binding of the identifier whose name is the value of the argument N to the value
   of argument V. An uninitialized binding for N must already exist.
*/
function InitializeBindingDeclarativeRecord(envRec, N, V) {
	/* Let envRec be the declarative Environment Record for which the method was invoked. */

	/* Assert: envRec must have an uninitialized binding for N. */
	assert (isUninitialisedBinding(envRec, N));
	/* Set the bound value for N in envRec to V. */
	setBindingValue(envRec, N, V);
	/* Record that the binding for N in envRec has been initialized. */
	setBindingInitialised(envRec, N, true);
	/* Return NormalCompletion(empty). */
	return NormalCompletion('empty);
}

/* 8.1.1.1.5 SetMutableBinding (N,V,S) */
/* The concrete Environment Record method SetMutableBinding for declarative Environment Records attempts
   to change the bound value of the current binding of the identifier whose name is the value of the argument N
   to the value of argument V. A binding for N normally already exist, but in rare cases it may not. If the binding is
   an immutable binding, a TypeError is thrown if S is true.
*/
function SetMutableBindingDeclarativeRecord(envRec, N, V, S) {
	/* Let envRec be the declarative Environment Record for which the method was invoked. */

	/* If envRec does not have a binding for N, then */
	if (!(HasBindingDeclarativeRecord(envRec, N))) {
    /* If S is true throw a ReferenceError exception. */
    if (S == true)
      throw ReferenceErrorConstructorInternal();
    /* Perform envRec.CreateMutableBinding(N, true). */
    {envRec.CreateMutableBinding}(envRec, N, true);
    /* Perform envRec.InitializeBinding(N, V). */
    {envRec.InitializeBinding}(envRec, N, V);
    /* Return NormalCompletion(empty). */
    return NormalCompletion('empty);
	}

	/* If the binding for N in envRec is a strict binding, let S be true. */
	if (isStrictBinding(envRec, N))
		S := true;

	/* If the binding for N in envRec has not yet been initialized throw a ReferenceError exception. */
	if (isUninitialisedBinding(envRec, N)) {
		throw ReferenceErrorConstructorInternal();
	/* Else if the binding for N in envRec is a mutable binding, change its bound value to V. */
  } else if (isMutableBinding(envRec, N)) {
		setBindingValue(envRec, N, V);  
	/* Else this must be an attempt to change the value of an immutable binding so if S is true throw a TypeError exception. */
  } else {
		if (S == true)
			throw TypeErrorConstructorInternal();
	}
	/* Return NormalCompletion(empty). */
	return NormalCompletion('empty);
}

/* 8.1.1.1.6 GetBindingValue(N,S) */
/* The concrete Environment Record method GetBindingValue for declarative Environment Records simply
   returns the value of its bound identifier whose name is the value of the argument N. If the binding
   exists but is uninitialized a ReferenceError is thrown, regardless of the value of S.
*/
function GetBindingValueDeclarativeRecord(envRec, N, S) {
	/* Let envRec be the declarative Environment Record for which the method was invoked. */

	/* Assert: envRec has a binding for N. */
	assert (HasBindingDeclarativeRecord(envRec, N));
	/* If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception. */
	if (isUninitialisedBinding(envRec, N))
		throw ReferenceErrorConstructorInternal();
	/* Return the value currently bound to N in envRec. */
	return getBindingValue(envRec, N);
}

/* 8.1.1.1.7 DeleteBinding (N) */
/* The concrete Environment Record method DeleteBinding for declarative Environment Records can only delete
   bindings that have been explicitly designated as being subject to deletion.
*/
function DeleteBindingDeclarativeRecord(envRec, N) {
	/* Let envRec be the declarative Environment Record for which the method was invoked. */

	/* Assert: envRec has a binding for the name that is the value of N. */
	assert (HasBindingDeclarativeRecord(envRec, N));
	/* If the binding for N in envRec cannot be deleted, return false. */
	if (isBindingCannotBeDeleted(envRec, N))
		return false;
	/* Remove the binding for N from envRec. */
	delete envRec[N];
	/* Return true. */
	return true;
}

/* 8.1.1.1.8 HasThisBinding () */
/* Regular declarative Environment Records do not provide a this binding. */
function HasThisBindingDeclarativeRecord(envRec) {
	return false;
}

/* 8.1.1.1.9 HasSuperBinding () */
/* Regular declarative Environment Records do not provide a super binding. */
function HasSuperBindingDeclarativeRecord(envRec) {
	return false;
}

/* 8.1.1.1.10 WithBaseObject() */
/* Declarative Environment Records always return undefined as their WithBaseObject. */
function WithBaseObjectDeclarativeRecord(envRec) {
	return 'undefined;
}

/*
8.1.1.2 Object Environment Records

Each object Environment Record is associated with an object called its binding object. An object Environment
Record binds the set of string identifier names that directly correspond to the property names of its binding
object. Property keys that are not strings in the form of an IdentifierName are not included in the set of bound
identifiers. Both own and inherited properties are included in the set regardless of the setting of their
[[Enumerable]] attribute. Because properties can be dynamically added and deleted from objects, the set of
identifiers bound by an object Environment Record may potentially change as a side-effect of any operation
that adds or deletes properties. Any bindings that are created as a result of such a side-effect are considered to
be a mutable binding even if the Writable attribute of the corresponding property has the value false.
Immutable bindings do not exist for object Environment Records.

Object Environment Records created for with statements (13.11) can provide their binding object as an
implicit this value for use in function calls. The capability is controlled by a withEnvironment Boolean value
that is associated with each object Environment Record. By default, the value of withEnvironment is false for
any object Environment Record.

The behaviour of the concrete specification methods for object Environment Records is defined by the
following algorithms.
*/

/* 8.1.1.2.1 HasBinding(N) */
/* The concrete Environment Record method HasBinding for object Environment Records determines if its
   associated binding object has a property whose name is the value of the argument N:
*/
function HasBindingObjectRecord(envRec, N) {
	/* Let envRec be the object Environment Record for which the method was invoked. */

	/* Let bindings be the binding object for envRec. */
	bindings := getBindingObject(envRec);
	/* Let foundBinding be HasProperty(bindings, N) */
	foundBinding := HasProperty(bindings, N);
	/* ReturnIfAbrupt(foundBinding). */
	@ReturnIfAbrupt(foundBinding);
	/* If foundBinding is false, return false. */
	if (foundBinding == false)
		return false;
	/* If the withEnvironment flag of envRec is false, return true. */
	if (envRec.withEnvironment == false)
		return true;
	/* Let unscopables be Get(bindings, @@unscopables). */
	unscopables := Get(bindings, getUnscopablesPropertyName());
	/* ReturnIfAbrupt(unscopables). */
	@ReturnIfAbrupt(unscopables);
	/* If Type(unscopables) is Object, then */
	if (Type(unscopables) == "Object") {
	    /* Let blocked be ToBoolean(Get(unscopables, N)). */
	    blocked := ToBoolean(Get(unscopables, N));
	    /* ReturnIfAbrupt(blocked). */
	    @ReturnIfAbrupt(blocked);
	    /* If blocked is true, return false. */
	    if (blocked == true)
	    	return false;
	}
	/* Return true. */
	return true;
}

/* 8.1.1.2.2 CreateMutableBinding (N, D) */
/* The concrete Environment Record method CreateMutableBinding for object Environment Records creates in
   an Environment Record’s associated binding object a property whose name is the String value and initializes it
   to the value undefined. If Boolean argument D is provided and has the value true the new property’s
   [[Configurable]] attribute is set to true, otherwise it is set to false.
*/
function CreateMutableBindingObjectRecord(envRec, N, D) {
    /* Let envRec be the object Environment Record for which the method was invoked. */

    /* Let bindings be the binding object for envRec. */
    bindings := getBindingObject(envRec);
    /* If D is true then let configValue be true otherwise let configValue be false. */
    if (D == true)
      configValue := true;
    else
      configValue := false;
    /* TODO check pq e que isto e preciso  */
    createMutableBinding(envRec, N, 'undefined);
    /* Return DefinePropertyOrThrow(bindings, N,
    PropertyDescriptor{[[Value]]:undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configValue}). */
    return DefinePropertyOrThrow(bindings, N, newDataPropertyDescriptorFull('undefined, true, true, configValue));
}

/* 8.1.1.2.3 CreateImmutableBinding (N, S) */
/* The concrete Environment Record method CreateImmutableBinding is never used within this specification in
   association with Object Environment Records.
*/
function CreateImmutableBindingObjectRecord(envRec, N, S) {
  assert false;
}

/* 8.1.1.2.4 InitializeBinding (N,V) */
/* The concrete Environment Record method InitializeBinding for object Environment Records is used to set the
   bound value of the current binding of the identifier whose name is the value of the argument N to the value of
   argument V. An uninitialized binding for N must already exist.
*/
function InitializeBindingObjectRecord(envRec, N, V) {
	/* Let envRec be the object Environment Record for which the method was invoked. */

	/* Assert: envRec must have an uninitialized binding for N. */
	assert (isUninitialisedBinding(envRec, N));
	/* Record that the binding for N in envRec has been initialized. */
	setBindingInitialised(envRec, N, true);
	/* Return envRec.SetMutableBinding(N, V, false). */
	return {envRec.SetMutableBinding}(envRec, N, V, false);
	/*NOTE In this specification, all uses of CreateMutableBinding for object Environment Records are
		   immediately followed by a call to InitializeBinding for the same name. Hence, implementations
		   do not need to explicitly track the initialization state of individual object Environment Record
		   bindings.
	*/
}

/* 8.1.1.2.5 SetMutableBinding (N,V,S) */
/* The concrete Environment Record method SetMutableBinding for object Environment Records attempts to set
   the value of the Environment Record’s associated binding object’s property whose name is the value of the
   argument N to the value of argument V. A property named N normally already exists but if it does not or is not
   currently writable, error handling is determined by the value of the Boolean argument S.
*/
function SetMutableBindingObjectRecord(envRec, N, V, S) {
    /* Let envRec be the object Environment Record for which the method was invoked. */

    /* Let bindings be the binding object for envRec. */
    bindings := getBindingObject(envRec);
    /* Return Set(bindings, N, V, S). */
    return Set(bindings, N, V, S);
}

/* 8.1.1.2.6 GetBindingValue(N,S) */
/* The concrete Environment Record method GetBindingValue for object Environment Records returns the value
   of its associated binding object’s property whose name is the String value of the argument identifier N.
   The property should already exist but if it does not the result depends upon the value of the S argument:
*/
function GetBindingValueObjectRecord(envRec, N, S) {
	/* Let envRec be the object Environment Record for which the method was invoked. */

	/* Let bindings be the binding object for envRec. */
	bindings := getBindingObject(envRec);
	/* Let value be HasProperty(bindings, N). */
	value := HasProperty(bindings, N);
	/* ReturnIfAbrupt(value). */
	@ReturnIfAbrupt(value);
	/* If value is false, then */
	if (value == false) {
    /* If S is false, return the value undefined, otherwise throw a ReferenceError exception. */
    if (S == false)
      return 'undefined;
    else
      throw ReferenceErrorConstructorInternal();
	}
	/* Return Get(bindings, N). */
	V:= Get(bindings, N);
  @ReturnIfAbrupt(V);
  return V;
}

/* 8.1.1.2.7 DeleteBinding (N) */
/* The concrete Environment Record method DeleteBinding for object Environment Records can only delete
   bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the
   value true.
*/
function DeleteBindingObjectRecord(envRec, N) {
	/* Let envRec be the object Environment Record for which the method was invoked. */

	/* Let bindings be the binding object for envRec. */
	bindings := getBindingObject(envRec);
	/* Return bindings.[[Delete]](N). */
	return {bindings.Delete}(bindings, N);
}

/* 8.1.1.2.8 HasThisBinding () */
/* Regular object Environment Records do not provide a this binding. */
function HasThisBindingObjectRecord(envRec) {
	return false;
}

/* 8.1.1.2.9 HasSuperBinding () */
/* Regular object Environment Records do not provide a super binding. */
function HasSuperBindingObjectRecord(envRec) {
	return false;
}

/* 8.1.1.2.10 WithBaseObject() */
/* Object Environment Records return undefined as their WithBaseObject unless their withEnvironment flag is
   true.
*/
function WithBaseObjectObjectRecord(envRec) {
    /* Let envRec be the object Environment Record for which the method was invoked. */

    /* If the withEnvironment flag of envRec is true, return the binding object for envRec. */
    if (envRec.withEnvironment == true)
    	return getBindingObject(envRec);
    /* Otherwise, return undefined. */
    return 'undefined;
}

/*
8.1.1.3 Function Environment Records

A function Environment Record is a declarative Environment Record that is used to represent the top-level
scope of a function and, if the function is not an ArrowFunction, provides a this binding. If a function is not an
ArrowFunction function and references super, its function Environment Record also contains the state that is
used to perform super method invocations from within the function.
*/

/*
Function Environment Records support all of the declarative Environment Record methods listed in Table 15
and share the same specifications for all of those methods except for HasThisBinding and HasSuperBinding. In
addition, function Environment Records support the methods listed in Table 17: */

/* 8.1.1.3.1 BindThisValue(V) */
function BindThisValue(envRec, V) {
    /* Let envRec be the function Environment Record for which the method was invoked. */

    /* Assert: envRec.[[thisBindingStatus]] is not "lexical". */
    assert (envRec.thisBindingStatus != "lexical");
    /* If envRec.[[thisBindingStatus]] is "initialized", throw a ReferenceError exception. */
    if (envRec.thisBindingStatus == "initialized")
    	throw ReferenceErrorConstructorInternal();

    /* Set envRec.[[thisValue]] to V. */
    envRec.__thisValue := V;
    /* Set envRec.[[thisBindingStatus]] to "initialized". */
    envRec.thisBindingStatus := "initialized";
    /* Return V. */
    return V;
}

/* 8.1.1.3.2 HasThisBinding () */
function HasThisBindingFunctionRecord(envRec) {
    /* Let envRec be the function Environment Record for which the method was invoked. */

    /* If envRec.[[thisBindingStatus]] is "lexical", return false; otherwise, return true. */
    if (envRec.thisBindingStatus == "lexical")
    	return false;
    return true;
}

/* 8.1.1.3.3 HasSuperBinding () */
function HasSuperBindingFunctionRecord(envRec) {
	/* Let envRec be the function Environment Record for which the method was invoked. */

    /* If envRec.[[thisBindingStatus]] is "lexical", return false. */
    if (envRec.thisBindingStatus == "lexical")
    	return false;
    /* If envRec.[[HomeObject]] has the value undefined, return false, otherwise, return true. */
    if (envRec.HomeObject == 'undefined)
    	return false;
    return true;
}

/* 8.1.1.3.4 GetThisBinding () */
function GetThisBinding(envRec) {
	/* Let envRec be the function Environment Record for which the method was invoked. */

	/* Assert: envRec.[[thisBindingStatus]] is not "lexical". */
	assert (envRec.thisBindingStatus != "lexical");
	/* If envRec.[[thisBindingStatus]] is "uninitialized", throw a ReferenceError exception. */
	if (envRec.thisBindingStatus == "uninitialized")
		throw ReferenceErrorConstructorInternal();
	/* Return envRec.[[thisValue]]. */
	return envRec.__thisValue;
}

/* 8.1.1.3.5 GetSuperBase () */
function GetSuperBase(envRec) {
	/* Let envRec be the function Environment Record for which the method was invoked. */

	/* Let home be the value of envRec.[[HomeObject]]. */
	home := envRec.HomeObject;
	/* If home has the value undefined, return undefined. */
	if (home == 'undefined)
		return 'undefined;
	/* Assert: Type(home) is Object. */
	assert (Type(home) == "Object");
	/* Return home.[[GetPrototypeOf]](). */
	return {home.GetPrototypeOf}(home);
}

/*
8.1.1.4 Global Environment Records

A global Environment Record is used to represent the outer most scope that is shared by all of the ECMAScript
Script elements that are processed in a common Realm (8.2). A global Environment Record provides the
bindings for built-in globals (clause 18), properties of the global object, and for all top-level declarations
(13.2.8, 13.2.10) that occur within a Script.

A global Environment Record is logically a single record but it is specified as a composite encapsulating an
object Environment Record and a declarative Environment Record. The object Environment Record has as its
base object the global object of the associated Realm. This global object is the value returned by the global
Environment Record’s GetThisBinding concrete method. The object Environment Record component of a
global Environment Record contains the bindings for all built-in globals (clause 18) and all bindings
introduced by a FunctionDeclaration, GeneratorDeclaration, or VariableStatement contained in global code. The
bindings for all other ECMAScript declarations in global code are contained in the declarative Environment
Record component of the global Environment Record.

Properties may be created directly on a global object. Hence, the object Environment Record component of a
global Environment Record may contain both bindings created explicitly by FunctionDeclaration,
GeneratorDeclaration, or VariableDeclaration declarations and binding created implicitly as properties of the
global object. In order to identify which bindings were explicitly created using declarations, a global
Environment Record maintains a list of the names bound using its CreateGlobalVarBindings and
CreateGlobalFunctionBindings concrete methods.

Global Environment Records have the additional fields listed in Table 18 and the additional methods listed in
Table 19.
*/

/* 8.1.1.4.1 HasBinding(N) */
/* The concrete Environment Record method HasBinding for global Environment Records simply determines if
   the argument identifier is one of the identifiers bound by the record:
*/
function HasBindingGlobalRecord(envRec, N) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;
  /* If DclRec.HasBinding(N) is true, return true. */
  if ({DclRec.HasBinding}(DclRec, N) == true)
    return true;
  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Return ObjRec.HasBinding(N). */
  return {ObjRec.HasBinding}(ObjRec, N);
}

/* 8.1.1.4.2 CreateMutableBinding (N, D) */
/* The concrete Environment Record method CreateMutableBinding for global Environment Records creates a
   new mutable binding for the name N that is uninitialized. The binding is created in the associated
   DeclarativeRecord. A binding for N must not already exist in the DeclarativeRecord. If Boolean argument D is
   provided and has the value true the new binding is marked as being subject to deletion.
*/
function CreateMutableBindingGlobalRecord(envRec, N, D) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;
  /* If DclRec.HasBinding(N) is true, throw a TypeError exception. */
  if ({DclRec.HasBinding}(DclRec, N) == true)
    throw TypeErrorConstructorInternal();
  /* Return DclRec.CreateMutableBinding(N, D). */
  return {DclRec.CreateMutableBinding}(DclRec, N, D);
}

/* 8.1.1.4.3 CreateImmutableBinding (N, S) */
/* The concrete Environment Record method CreateImmutableBinding for global Environment Records creates a
   new immutable binding for the name N that is uninitialized. A binding must not already exist in this
   Environment Record for N. If Boolean argument S is provided and has the value true the new binding is
   marked as a strict binding.
*/
function CreateImmutableBindingGlobalRecord(envRec, N, S) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;
  /* If DclRec.HasBinding(N) is true, throw a TypeError exception. */
  if ({DclRec.HasBinding}(DclRec, N) == true)
    throw TypeErrorConstructorInternal();
  /* Return DclRec.CreateImmutableBinding(N, S). */
  return {DclRec.CreateImmutableBinding}(DclRec, N, S);
}

/* 8.1.1.4.4 InitializeBinding (N,V) */
/* The concrete Environment Record method InitializeBinding for global Environment Records is used to set the
   bound value of the current binding of the identifier whose name is the value of the argument N to the value of
   argument V. An uninitialized binding for N must already exist.
*/
function InitializeBindingGlobalRecord(envRec, N, V) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;
  /* If DclRec.HasBinding(N) is true, then */
  if ({DclRec.HasBinding}(DclRec, N) == true)
    /* Return DclRec.InitializeBinding(N, V). */
    return {DclRec.InitializeBinding}(DclRec, N, V);
  /* Assert: If the binding exists it must be in the object Environment Record. */
  assert (isObjectEnvRec(envRec));
  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Return ObjRec.InitializeBinding(N, V). */
  return {ObjRec.InitializeBinding}(ObjRec, N, V);
}

function isObjectEnvRec(envRec) {
  return ("ObjectRecord" in_obj envRec);
}

/* 8.1.1.4.5 SetMutableBinding (N,V,S) */
/*
The concrete Environment Record method SetMutableBinding for global Environment Records attempts to
change the bound value of the current binding of the identifier whose name is the value of the argument N to
the value of argument V. If the binding is an immutable binding, a TypeError is thrown if S is true. A property
named N normally already exists but if it does not or is not currently writable, error handling is determined by
the value of the Boolean argument S.
*/
function SetMutableBindingGlobalRecord(envRec, N, V, S) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;
  /* If DclRec.HasBinding(N) is true, then */
  if ({DclRec.HasBinding}(DclRec, N) == true)
    /* Return DclRec.SetMutableBinding(N, V, S). */
    return {DclRec.SetMutableBinding}(DclRec, N, V, S);
  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Return ObjRec.SetMutableBinding(N, V, S). */
  return {ObjRec.SetMutableBinding}(ObjRec, N, V, S);
}

/* 8.1.1.4.6 GetBindingValue(N,S) */
/*
The concrete Environment Record method GetBindingValue for global Environment Records returns the value
of its bound identifier whose name is the value of the argument N. If the binding is an uninitialized binding
throw a ReferenceError exception. A property named N normally already exists but if it does not or is not
currently writable, error handling is determined by the value of the Boolean argument S.
*/
function GetBindingValueGlobalRecord(envRec, N, S) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;
  /* If DclRec.HasBinding(N) is true, then */
  if ({DclRec.HasBinding}(DclRec, N) == true)
    /* Return DclRec.GetBindingValue(N, S). */
    return {DclRec.GetBindingValue}(DclRec, N, S);

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Return ObjRec.GetBindingValue(N, S). */
  return {ObjRec.GetBindingValue}(ObjRec, N, S);
}

/* 8.1.1.4.7 DeleteBinding (N) */
/*
The concrete Environment Record method DeleteBinding for global Environment Records can only delete
bindings that have been explicitly designated as being subject to deletion.
*/
function DeleteBindingGlobalRecord(envRec, N) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;
  /* If DclRec.HasBinding(N) is true, then */
  if ({DclRec.HasBinding}(DclRec, N) == true)
      /* Return DclRec.DeleteBinding(N). */
      return {DclRec.DeleteBinding}(DclRec, N);

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Let globalObject be the binding object for ObjRec. */
  globalObject := getBindingObject(ObjRec);
  /* Let existingProp be HasOwnProperty(globalObject, N). */
  existingProp := HasOwnProperty(globalObject, N);
  /* ReturnIfAbrupt(existingProp). */
  @ReturnIfAbrupt(existingProp);
  /* If existingProp is true, then */
  if (existingProp == true) {
    /* Let status be ObjRec.DeleteBinding(N). */
    status := {ObjRec.DeleteBinding}(ObjRec, N);
    /* ReturnIfAbrupt(status). */
    @ReturnIfAbrupt(status);
    /* If status is true, then */
    if (status == true) {
        /* Let varNames be envRec.[[VarNames]]. */
        varNames := envRec.VarNames;
        /* If N is an element of varNames, remove that element from the varNames. */
        if (in_list(N, varNames)) {
          newVarNames := [];
          foreach (name : varNames)
            if (name != N)
              newVarNames := l_add(newVarNames, name);
          envRec.VarNames := newVarNames;
        }
    }

    /* Return status. */
    return status;
  }

  /* Return true. */
  return true;
}

/* 8.1.1.4.8 HasThisBinding () */
/* Global Environment Records always provide a this binding whose value is the associated global object. */
function HasThisBindingGlobalRecord(envRec) {
	return true;
}

/* 8.1.1.4.9 HasSuperBinding () */
/*
function HasSuperBinding(envRec) {
	return false
}
*/

/* 8.1.1.4.10 WithBaseObject() */
/* Global Environment Records always return undefined as their WithBaseObject */
function WithBaseObjectGlobalRecord(envRec) {
	return 'undefined;
}

/* 8.1.1.4.11 GetThisBinding () */
function GetThisBindingGlobalRecord(envRec) {
    /* Let envRec be the global Environment Record for which the method was invoked. */

    /* Let ObjRec be envRec.[[ObjectRecord]]. */
    ObjRec := envRec.ObjectRecord;
    /* Let bindings be the binding object for ObjRec. */
    bindings := getBindingObject(ObjRec);
    /* Return bindings. */
    return bindings;
}

/* 8.1.1.4.12 HasVarDeclaration (N) */
/*
The concrete Environment Record method HasVarDeclaration for global Environment Records determines if
the argument identifier has a binding in this record that was created using a VariableStatement
or a FunctionDeclaration :
*/
function HasVarDeclaration(envRec, N) {
    /* Let envRec be the global Environment Record for which the method was invoked. */

    /* Let varDeclaredNames be envRec.[[VarNames]]. */
    varDeclaredNames := envRec.VarNames;
    /* If varDeclaredNames contains the value of N, return true. */
    if (in_list(N, varDeclaredNames))
    	return true;
    /* Return false. */
    return false;
}

/* 8.1.1.4.13 HasLexicalDeclaration (N) */
/*
The concrete Environment Record method HasLexicalDeclaration for global Environment Records determines
if the argument identifier has a binding in this record that was created using a lexical declaration such as a
LexicalDeclaration or a ClassDeclaration :
*/
function HasLexicalDeclaration(envRec, N) {
    /* Let envRec be the global Environment Record for which the method was invoked. */

    /* Let DclRec be envRec.[[DeclarativeRecord]]. */
    DclRec := envRec.DeclarativeRecord;
    /* Return DclRec.HasBinding(N). */
    return {DclRec.HasBinding}(DclRec, N);
}

/* 8.1.1.4.14 HasRestrictedGlobalProperty (N) */
/*
The concrete Environment Record method HasRestrictedGlobalProperty for global Environment Records
determines if the argument identifier is the name of a property of the global object that must not be shadowed
by a global lexically binding:
*/
function HasRestrictedGlobalProperty(envRec, N) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Let globalObject be the binding object for ObjRec. */
  globalObject := getBindingObject(ObjRec);
  /* Let existingProp be globalObject.[[GetOwnProperty]](N). */
  existingProp := {globalObject.GetOwnProperty}(globalObject, N);
  /* ReturnIfAbrupt(existingProp). */
  @ReturnIfAbrupt(existingProp);
  /* If existingProp is undefined, return false. */
  if (existingProp == 'undefined)
    return false;
  /* If existingProp.[[Configurable]] is true, return false. */
  if (existingProp.Configurable == true)
    return false;
  /* Return true. */
  return true;

  /* NOTE Properties may exist upon a global object that were directly created rather than being declared
        using a var or function declaration. A global lexical binding may not be created that has the same
        name as a non-configurable property of the global object. The global property undefined is an
        example of such a property.
  */
}

/* 8.1.1.4.15 CanDeclareGlobalVar (N) */
/*
The concrete Environment Record method CanDeclareGlobalVar for global Environment Records determines if
a corresponding CreateGlobalVarBinding call would succeed if called for the same argument N. Redundant var
declarations and var declarations for pre-existing global object properties are allowed.
*/
function CanDeclareGlobalVar(envRec, N) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Let globalObject be the binding object for ObjRec. */
  globalObject := getBindingObject(ObjRec);
  /* Let hasProperty be HasOwnProperty(globalObject, N). */
  hasProperty := HasOwnProperty(globalObject, N);
  /* ReturnIfAbrupt(hasProperty). */
  @ReturnIfAbrupt(hasProperty);
  /* If hasProperty is true, return true. */
  if (hasProperty == true)
    return true;
  /* Return IsExtensible(globalObject). */
  return IsExtensible(globalObject);
}

/* 8.1.1.4.16 CanDeclareGlobalFunction (N) */
/*
The concrete Environment Record method CanDeclareGlobalFunction for global Environment Records
determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same
argument N.
*/
function CanDeclareGlobalFunction(envRec, N) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Let globalObject be the binding object for ObjRec. */
  globalObject := getBindingObject(ObjRec);
  /* Let existingProp be globalObject.[[GetOwnProperty]](N). */
  existingProp := {globalObject.GetOwnProperty}(globalObject, N);
  /* ReturnIfAbrupt(existingProp). */
  @ReturnIfAbrupt(existingProp);
  /* If existingProp is undefined, return IsExtensible(globalObject). */
  if (existingProp == 'undefined)
    return IsExtensible(globalObject);
  /* If existingProp.[[Configurable]] is true, return true. */
  if (existingProp.Configurable == true)
    return true;
  /* If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true. */
  if ((IsDataDescriptor(existingProp) == true) &&& (existingProp.Writable == true) &&& (existingProp.Enumerable == true))
    return true;
  /* Return false. */
  return false;
}

/* 8.1.1.4.17 CreateGlobalVarBinding (N, D) */
/*
The concrete Environment Record method CreateGlobalVarBinding for global Environment Records creates
and initializes a mutable binding in the associated object Environment Record and records the bound name
in the associated [[VarNames]] List. If a binding already exists, it is reused and assumed to be initialized.
*/
function CreateGlobalVarBinding(envRec, N, D) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Let globalObject be the binding object for ObjRec. */
  globalObject := getBindingObject(ObjRec);
  /* Let hasProperty be HasOwnProperty(globalObject, N). */
  hasProperty := HasOwnProperty(globalObject, N);
  /* ReturnIfAbrupt(hasProperty). */
  @ReturnIfAbrupt(hasProperty);
  /* Let extensible be IsExtensible(globalObject). */
  extensible := IsExtensible(globalObject);
  /* ReturnIfAbrupt(extensible). */
  @ReturnIfAbrupt(extensible);
  /* If hasProperty is false and extensible is true, then */
  if ((hasProperty == false) &&& (extensible == true)) {
    /* Let status be ObjRec.CreateMutableBinding(N, D). */
    status := {ObjRec.CreateMutableBinding}(ObjRec, N, D);
    /* ReturnIfAbrupt(status). */
    @ReturnIfAbrupt(status);
    /* Let status be ObjRec.InitializeBinding(N, undefined). */
    status := {ObjRec.InitializeBinding}(ObjRec, N, 'undefined);
    /* ReturnIfAbrupt(status). */
    @ReturnIfAbrupt(status);
  }

  /* Let varDeclaredNames be envRec.[[VarNames]]. */
  varDeclaredNames := envRec.VarNames;
  /* If varDeclaredNames does not contain the value of N, then */
  if (!((in_list(N, varDeclaredNames)))) {
    /* Append N to varDeclaredNames. */
    varDeclaredNames := l_add(varDeclaredNames, N);
  }

  /* Return NormalCompletion(empty). */
  return NormalCompletion('empty);
}

/* 8.1.1.4.18 CreateGlobalFunctionBinding (N, V, D) */
/*
The concrete Environment Record method CreateGlobalFunctionBinding for global Environment Records
creates and initializes a mutable binding in the associated object Environment Record and records the bound
name in the associated [[VarNames]] List. If a binding already exists, it is replaced.
*/
function CreateGlobalFunctionBinding(envRec, N, V, D) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;
  /* Let globalObject be the binding object for ObjRec. */
  globalObject := getBindingObject(ObjRec);
  /* Let existingProp be globalObject.[[GetOwnProperty]](N). */
  existingProp := {globalObject.GetOwnProperty}(globalObject, N);
  /* ReturnIfAbrupt(existingProp). */
  @ReturnIfAbrupt(existingProp);
  /* If existingProp is undefined or existingProp.[[Configurable]] is true, then */
  if ((existingProp == 'undefined) ||| (existingProp.Configurable == true)) {
    /* Let desc be the PropertyDescriptor{[[Value]]:V, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: D}. */
    desc := newDataPropertyDescriptorFull(V, true, true, D);
  /* Else, */
  } else {
    /* Let desc be the PropertyDescriptor{[[Value]]:V }. */
    desc := { Value:V };
  }

  /* Let status be DefinePropertyOrThrow(globalObject, N, desc). */
  status := DefinePropertyOrThrow(globalObject, N, desc);
  /* ReturnIfAbrupt(status). */
  @ReturnIfAbrupt(status);
  /* Let status be Set(globalObject, N, V, false). */
  status := Set(globalObject, N, V, false);

  /* Record that the binding for N in ObjRec has been initialized. */
  /* TODO check como por o binding a initialized */
  /* setBindingInitialised(ObjRec, N, true); */

  /* ReturnIfAbrupt(status). */
  @ReturnIfAbrupt(status);
  /* Let varDeclaredNames be envRec.[[VarNames]]. */
  varDeclaredNames := envRec.VarNames;
  /* If varDeclaredNames does not contain the value of N, then */
  if (!((in_list(N, varDeclaredNames))))
    /* Append N to varDeclaredNames. */
    varDeclaredNames := l_add(varDeclaredNames, N);

  /* Return NormalCompletion(empty). */
  return NormalCompletion('empty);

  /* NOTE Global function declarations are always represented as own properties of the global object. If
        possible, an existing own property is reconfigured to have a standard set of attribute values.
        Steps 10-12 are equivalent to what calling the InitializeBinding concrete method would do and if
        globalObject is a Proxy will produce the same sequence of Proxy trap calls.
  */
}

/* 8.1.1.5 Module Environment Records */
/*
A module Environment Record is a declarative Environment Record that is used to represent the outer scope
of an ECMAScript Module. In additional to normal mutable and immutable bindings, module Environment
Records also provide immutable import bindings which are bindings that provide indirect access to a target
binding that exists in another Environment Record.

Module Environment Records support all of the declarative Environment Record methods listed in Table 15
and share the same specifications for all of those methods except for GetBindingValue, DeleteBinding,
HasThisBinding and GetThisBinding. In addition, module Environment Records support the methods listed in
Table 20:
*/

/* 8.1.1.5.1 GetBindingValue(N,S) */
/*
The concrete Environment Record method GetBindingValue for module Environment Records returns the
value of its bound identifier whose name is the value of the argument N. However, if the binding is an indirect
binding the value of the target binding is returned. If the binding exists but is uninitialized a ReferenceError
is thrown, regardless of the value of S.
*/
function GetBindingValueModuleRecord(envRec, N, S) {
    /* Let envRec be the module Environment Record for which the method was invoked. */

    /* Assert: envRec has a binding for N. */
    assert (HasBindingDeclarativeRecord(envRec, N));

    /* If the binding for N is an indirect binding, then */
        /* Let M and N2 be the indirection values provided when this binding for N was created. */

        /* Let targetEnv be M.[[Environment]]. */

        /* If targetEnv is undefined, throw a ReferenceError exception. */

        /* Let targetER be targetEnv’s EnvironmentRecord. */

        /* Return targetER.GetBindingValue(N2, S). */

    /* If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception. */

    /* Return the value currently bound to N in envRec. */

} /* TODO MODULE ENVIRONMENT RECORDS */

/* 8.1.1.5.2 DeleteBinding (N) */
/*
The concrete Environment Record method DeleteBinding for module Environment Records refuses to delete
bindings.
*/
function DeleteBindingModuleRecord(envRec, N) {
    /* Let envRec be the module Environment Record for which the method was invoked. */

	/* If envRec does not have a binding for the name that is the value of N, return true. */
	if (!(HasBindingDeclarativeRecord(envRec, N)))
		return true;

  /* Return false. */
  return false;
}

/* 8.1.1.5.3 HasThisBinding () */
/* Module Environment Records provide a this binding. */
function HasThisBindingModuleRecord(envRec) {
	return true;
}

/* 8.1.1.5.4 GetThisBinding () */
function GetThisBindingModuleRecord(envRec) {
	return 'undefined;
}

/* 8.1.1.5.5 CreateImportBinding (N, M, N2) */
/*
The concrete Environment Record method CreateImportBinding for module Environment Records creates a
new initialized immutable indirect binding for the name N. A binding must not already exist in this
Environment Record for N. M is a Module Record (see 15.2.1.15), and N2 is the name of a binding that exists in
M’s module Environment Record. Accesses to the value of the new binding will indirectly access the bound
value of value of the target binding.
*/
function CreateImportBinding(envRec, N, M, N2) {
  /* Let envRec be the module Environment Record for which the method was invoked. */

  /* Assert: envRec does not already have a binding for N. */

  /* Assert: M is a Module Record. */

  /* Assert: When M.[[Environment]] is instantiated it will have a direct binding for N2. */

  /* Create an immutable indirect binding in envRec for N that references M and N2 as its target binding and record that the binding is initialized. */

  /* Return NormalCompletion(empty). */
  return NormalCompletion('empty);
}

/*
8.1.2 Lexical Environment Operations

The following abstract operations are used in this specification to operate upon lexical environments:
*/

/* 8.1.2.1 GetIdentifierReference (lex, name, strict) */
/*
The abstract operation GetIdentifierReference is called with a Lexical Environment lex, a String name, and a
Boolean flag strict. The value of lex may be null. When called, the following steps are performed:
*/
function GetIdentifierReference(lex, name, strict) {
  /* If lex is the value null, then */
  if (lex == 'null ||| lex == null ||| lex == 'undefined)
    /* Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict. */
    return newValueReference('undefined, name, strict);

  /* Let envRec be lex’s EnvironmentRecord. */
  envRec := getEnvironmentRecord(lex);
  /* Let exists be envRec.HasBinding(name). */
  exists := {envRec.HasBinding}(envRec, name);
  /* ReturnIfAbrupt(exists). */
  @ReturnIfAbrupt(exists);
  /* If exists is true, then */
  if (exists == true) {
    /* Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict. */
    return newValueReference(envRec, name, strict);
  /* Else */
  } else {
    /* Let outer be the value of lex’s outer environment reference. */
    outer := getOuterEnvironmentReference(lex);
    /* Return GetIdentifierReference(outer, name, strict). */
    return GetIdentifierReference(outer, name, strict);
  }
}

/* 8.1.2.2 NewDeclarativeEnvironment (E) */
/*
When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E
the following steps are performed:
*/
function NewDeclarativeEnvironment(E) {
  /* Let env be a new Lexical Environment. */
  env := newLexicalEnvironment();
  /* Let envRec be a new declarative Environment Record containing no bindings. */
  envRec := newDeclarativeEnvironmentRecord();
  /* Set env’s EnvironmentRecord to be envRec. */
  setEnvironmentRecord(env, envRec);
  /* Set the outer lexical environment reference of env to E. */
  setOuterLexicalEnvironmentReference(env, E);
  /* Return env. */
  return env;
}

/* 8.1.2.3 NewObjectEnvironment (O, E) */
/*
When the abstract operation NewObjectEnvironment is called with an Object O and a Lexical Environment E as
arguments, the following steps are performed:
*/
function NewObjectEnvironment(O, E) {
  /* Let env be a new Lexical Environment. */
  env := newLexicalEnvironment();
  /* Let envRec be a new object Environment Record containing O as the binding object. */
  envRec := newObjectEnvironmentRecord(O);
  /* Set env’s EnvironmentRecord to envRec. */
  setEnvironmentRecord(env, envRec);
  /* Set the outer lexical environment reference of env to E. */
  setOuterLexicalEnvironmentReference(env, E);
  /* Return env. */
  return env;
}

/* 8.1.2.4 NewFunctionEnvironment ( F, newTarget ) */
/*
When the abstract operation NewFunctionEnvironment is called with arguments F and newTarget the
following steps are performed:
*/
function NewFunctionEnvironment(F, newTarget) {
  /* 1. Assert: F is an ECMAScript function. */
  assert (isESFunctionObject(F));
  /* Assert: Type(newTarget) is Undefined or Object. */
  assert ((Type(newTarget) == "Undefined") ||| (Type(newTarget) == "Object") );
  /* 3. Let env be a new Lexical Environment. */
  env := newLexicalEnvironment();
  /* 4. Let envRec be a new function Environment Record containing no bindings. */
  envRec := newFunctionEnvironmentRecord();
  /* 5. Set envRec.[[FunctionObject]] to F. */
  envRec.FunctionObject := F;
  /* 6. If F's [[ThisMode]] internal slot is lexical, */
  if (F.ThisMode == "lexical") {
    /* set envRec.[[thisBindingStatus]] to "lexical" */
    envRec.thisBindingStatus := "lexical";
  /* 7. Else, */
  } else {
    /* Set envRec.[[thisBindingStatus]] to "uninitialized" */
    envRec.thisBindingStatus := "uninitialized";
  }
  /* 8. Let home be the value of F's [[HomeObject]] internal slot. */
  home := F.HomeObject;
  /* 9. Set envRec.[[HomeObject]] to home. */
  envRec.HomeObject := home;
  /* 10. Set envRec.[[NewTarget]] to newTarget. */
  envRec.__NewTarget := newTarget;
  /* 11. Set env's EnvironmentRecord to be envRec. */
  setEnvironmentRecord(env, envRec);
  /* 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot. */
  setOuterLexicalEnvironmentReference(env, F.Environment);
  /* 13. Return env. */
  return env;
}

/* 8.1.2.5 NewGlobalEnvironment ( G ) */
/*
When the abstract operation NewGlobalEnvironment is called with an ECMAScript Object G as its argument,
the following steps are performed:
*/
function NewGlobalEnvironment(G) {
    /* Let env be a new Lexical Environment. */
    env := newLexicalEnvironment();
    /* Let objRec be a new object Environment Record containing G as the binding object. */
    objRec := newObjectEnvironmentRecord(G);
    /* Let dclRec be a new declarative Environment Record containing no bindings. */
    dclRec := newDeclarativeEnvironmentRecord();
    /* Let globalRec be a new global Environment Record. */
    globalRec := newGlobalEnvironmentRecord();
    /* Set globalRec.[[ObjectRecord]] to objRec. */
    globalRec.ObjectRecord := objRec;
    /* Set globalRec.[[DeclarativeRecord]] to dclRec. */
    globalRec.DeclarativeRecord := dclRec;
    /* Set globalRec.[[VarNames]] to a new empty List. */
    globalRec.VarNames := [];
    /* Set env’s EnvironmentRecord to globalRec. */
    setEnvironmentRecord(env, globalRec);
    /* Set the outer lexical environment reference of env to null */
    setOuterLexicalEnvironmentReference(env, 'null);
    /* Return env. */
    return env;
}

/* 8.1.2.6 NewModuleEnvironment (E) */
/*
When the abstract operation NewModuleEnvironment is called with a Lexical Environment argument E the
following steps are performed:
*/
function NewModuleEnvironment(E) {
    /* Let env be a new Lexical Environment. */
    env := newLexicalEnvironment();
    /* Let envRec be a new module Environment Record containing no bindings. */
    envRec := newModuleEnvironmentRecord();
    /* Set env’s EnvironmentRecord to be envRec. */
    setEnvironmentRecord(env, envRec);
    /* Set the outer lexical environment reference of env to E. */
    setOuterLexicalEnvironmentReference(env, E);
    /* Return env. */
    return env;
}
