/* Auxiliary functions */

/* Sort according to section 9.1.12 of ES6 */
function sortProprtiesES6(internalSlotsList) {
  num_list := [];
  str_list := [];
  i := 0;
  len := l_len internalSlotsList;
  while (i < len) {
    P := l_nth(internalSlotsList, i);
    num := ToNumber(P);
    /* Only positive integer numbers are */
    if (!(num = NaN) &&& (ToUint32(num) = num) &&& !(P in_list num_list)) {
      num_list := l_add(num_list, P)
    } elif (!(P in_list str_list)) {
      str_list := l_add(str_list, P)
    };
    i := i + 1
  };
  num_list := l_sort (num_list);
  str_list := l_reverse str_list;
  return l_concat(num_list, str_list)
};
function getOwnEnumerablePropertiesNames(obj) {
  sortedPeoperties := sortProprtiesES6(obj.internalSlotsList); /* ordered properties according to ES6 */

  K := [];
  namedOwnProperties := sortedPeoperties;
  lnamedOwnProperties := l_len namedOwnProperties;
  index := 0;
  while (index < lnamedOwnProperties) {
    P := l_nth(namedOwnProperties, index);
    P_desc := getJSProperty(obj, P);
    if (isEnumerablePropertyDescriptor(P_desc)) {
      K := l_add(K, P)
    };
    index := index + 1
  };
  return K
};
function concatenateListStrElmsWithSeparator(list, separator) {
  j := 0;
  pLen := l_len list;
  properties := "";
  while (j < pLen) {
    el := l_nth(list, j);
    if (el = 'null) {
      el := "null"
    };
    properties := s_concat([properties, el]);
    if (j < (pLen - 1)) {
        properties := s_concat([properties, separator])
    };
    j := j + 1
  };
  return properties
};



function initJsonObject(globalObject, ObjectPrototype, strict) {
  JsonObject := NewECMAScriptObject();
  setAllInternalMethodsOfOrdinaryObject(JsonObject);

  /* The value of the [[Prototype]] internal property of the JSON object is
     the standard built-in Object prototype object (15.2.4).
     The value of the [[Class]] internal property of the JSON object is "JSON".
     The value of the [[Extensible]] internal property of the JSON object is set to true. */
  setInternalProperty(JsonObject, "Prototype", ObjectPrototype);
  setInternalProperty(JsonObject, "Class", "JSON");
  setInternalProperty(JsonObject, "Extensible", true);

  /* The JSON object does not have a [[Construct]] internal property; it is
     not possible to use the JSON object as a constructor with the new operator.

     The JSON object does not have a [[Call]] internal property; it is not possible
     to invoke the JSON object as a function. */

  parse_fo := CreateBuiltInFunctionObject(["text", "reviver"], "jsonParse", globalObject, strict, null);
  setConfigurability(parse_fo, "length", true); /* ES6 */
  setJSProperty(parse_fo, "name", newDataPropertyDescriptorFull("parse", false, false, true));
  createBuiltInProperty(JsonObject, "parse", parse_fo);

  stringify_fo := CreateBuiltInFunctionObject(["value", "replacer", "space"], "jsonStringify", globalObject, strict, null);
  setConfigurability(stringify_fo, "length", true); /* ES6 */
  setJSProperty(stringify_fo, "name", newDataPropertyDescriptorFull("stringify", false, false, true));
  createBuiltInPropertyWithFullDescriptor(stringify_fo, "name", "stringify", false, false, true);
  createBuiltInProperty(JsonObject, "stringify", stringify_fo);

  /* 24.3.3 JSON [ @@toStringTag ] */
  descriptor := newDataPropertyDescriptorFull("JSON", false, false, true);
  setJSProperty(JsonObject, getToStringTagPropertyName(), descriptor); 

  return JsonObject
};



/**
 * ES6: ECMA-404: https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf
 */
function parseJSONText(global, this, NewTarget, strict, args) {
  JText := l_nth(args, 0);
  /*if ((JText = 'null) ||| (JText = null) ||| (JText = null) ||| (JText = null)){
    return JText
  };*/

  
  if (s_len JText = 0) {
    throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, ["JSON.parse: Unexpected end of JSON input"])
  };
  tokens := getTokens(global, this, getSyntaxErrorConstructor(), strict, [JText]);
  ret := parseJSONValue(global, this, getSyntaxErrorConstructor(), strict, tokens);
  tokens := l_nth(ret, 1);
  if (!((l_len tokens) = 0)) {
    throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, ["JSON.parse: Invalid syntax."])
  } else {
    return l_nth(ret, 0)
  }
};

function isDigit(c) {
  c_code := to_char_code_u (c);
  return ((c_code >= 48) &&& (c_code <= 57))
};

function unescapeJSONString(S) {
  i := 0;
  len := s_len_u(S);
  S2 := "";
  while (i < len) {
    c := s_nth_u(S, i);
    if (c = "\\") {
      if (i < (len - 1)) {
        c2 := s_nth_u(S, i + 1);
        if (c2 = "u") {
          if (i < (len - 5)) {
            str := s_substr_u(S, i, 6);
            u := utf8_decode str;
            S2 := s_concat([S2, u]);
            i := i + 4
          } else {
            throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict,
              ["JSON.parse: Invalid unicode escape sequence."])
          }
        } elif ((c2 = "\\") ||| (c2 = "/") ||| (c2 = "\"")) {
          S2 := s_concat([S2, c2])
        } elif (c2 = "b") {
          S2 := s_concat([S2, "\b"])
        } elif (c2 = "f") {
          S2 := s_concat([S2, "\f"])
        } elif (c2 = "n") {
          S2 := s_concat([S2, "\n"])
        } elif (c2 = "r") {
          S2 := s_concat([S2, "\r"])
        } elif (c2 = "t") {
          S2 := s_concat([S2, "\t"])
        };
        i := i + 2
      }
    } else {
      S2 := s_concat([S2, c]);
      i := i + 1
    }
  };
  return S2
};

function getTokens(global, this, NewTarget, strict, args) {
  JText := l_nth(args, 0);

  whitespaces := ["\x20", "\t", "\r", "\n"];
  structural_tokens := ["{", "}", "[", "]", ",", ":"];

  tokens := [];
  i := 0;
  len := s_len_u (JText);
  while (i < len) {
    c := s_nth_u(JText, i);

    /* allowed white-spaces */
    if (c in_list whitespaces) {
      /* ignore */
      i := i + 1
    }
    /* structural tokens */
    elif (c in_list structural_tokens) {
      tokens := l_add(tokens, c);
      i := i + 1
    }
    /* numbers */
    elif ((c = "-") ||| isDigit(c)) {
      /**
       * JSON number regex: https://stackoverflow.com/a/13340826/3049315
       * -?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?
       *
       * Recognized Regexp constructs in OCaml Str: https://ocaml.org/api/Str.html
       * - \d not recognized in OCaml regexp
       * - non-capturing groups not recognized
       * - (, ) and | must be escaped
       */
      /*re := "-?\\(0\\|[1-9][0-9]*\\)\\(\\.[0-9]+\\)?\\([eE][+-]?[0-9]+\\)?";
      num := re_exec (re, JText, i);*/
      num := parse_number (s_substr_u (JText, i, (s_len_u (JText)) - i));
      num_len := s_len_u (num);
      if (num_len = 0) {
        throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict,
          [s_concat(["JSON.parse: Unexpected token ", c, " in JSON at position ", (int_to_string i)])])
      };
      i := i + num_len;
      tokens := l_add(tokens, num)
    }
    /* Strings. */
    elif (c = "\"") {
      /**
       * JSON string regex: https://stackoverflow.com/a/32155765/3049315
       * "(\\(["\\\/bfnrt]|u[a-fA-F0-9]{4})|[^"\\\0-\x1F\x7F]+)*"
       */
      /*re := "\x22\\(\\\\\\([\x22\\\/bfnrt]\\|u[a-fA-F0-9]{4}\\)\\|[^\x22\\\0-\x1F\x7F]+\\)*\x22";
      str := re_exec (re, JText, i);*/
      str := parse_string (s_substr_u (JText, i, (s_len_u (JText)) - i));
      str_len := s_len_u (str);

      if (str_len = 0) {
        throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict,
          [s_concat(["JSON.parse: Unexpected token ", c, " in JSON at position ", (int_to_string i)])])
      };
      i := i + str_len;
      str := unescapeJSONString(str);
      tokens := l_add(tokens, str)
    }
    /* literal name tokens */
    else {
      /*re := "true\\|false\\|null";
      tok := re_exec (re, JText, i);*/

      valid_tok := false;
      len := s_len_u (JText);
      if (i <= (len - 4)) {
        tok := s_substr_u (JText, i, 4);
        if ((tok = "true") ||| (tok = "null")) {
          i := i + 4;
          tokens := l_add(tokens, tok);
          valid_tok := true
        }
      };
      if (!valid_tok &&& (i <= (len - 5))) {
        tok := s_substr_u (JText, i, 5);

        if (tok = "false") {
          i := i + 5;
          tokens := l_add(tokens, tok);
          valid_tok := true
        }
      };

      if (!valid_tok) {
        throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, 
          [s_concat(["JSON.parse: Unexpected token ", c, " in JSON at position ", (int_to_string i)])])
      }
    }
  };
  return tokens
};

function parseJSONValue(global, this, NewTarget, strict, tokens) {
  token := hd tokens;
  tokens := tl tokens;

  if (token = "null") {
    return ['null, tokens]
  } elif (token = "true") {
    return [true, tokens]
  } elif (token = "false") {
    return [false, tokens]
  } elif (!(ToNumber(token) = NaN)) {
    num := ToNumber(token);
    return [num, tokens]
  } elif ((s_nth_u(token, 0)) = "\"") {
    str := ToString(s_substr_u(token, 1, ((s_len_u (token)) - 2)));
    return [str, tokens]
  } elif (token = "{") {
    ret := findClosingCurlyBracket(tokens);
    obj_tokens := l_nth(ret, 0);
    tokens := l_nth(ret, 1);
    obj := parseJSONObject(global, this, 'undefined, strict, obj_tokens);
    return [obj, tokens]
  } elif (token = "[") {
    ret := findClosingSquareBracket(tokens);
    arr_tokens := l_nth(ret, 0);
    tokens := l_nth(ret, 1);
    arr := parseJSONArray(global, this, 'undefined, strict, arr_tokens);
    return [arr, tokens]
  } else {
    return []
  }
};

function parseJSONObject(global, this, NewTarget, strict, tokens) {
  obj := ObjectConstructor(global, this, 'undefined, strict, [null]);
  keys := [];

  while ((l_len tokens) > 2) {

    key := ToString(hd tokens);
    key := ToString(s_substr_u(key, 1, ((s_len_u (key)) - 2)));

    colon := hd (tl tokens);
    if (!(colon = ":")) {
      throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, [s_concat(["JSON.parse: Invalid syntax. Expected colon after object key."])])
    };
    tokens := tl (tl tokens);

    ret := parseJSONValue(global, this, 'undefined, strict, tokens);

    if ((l_len ret) = 0) {
      throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, [s_concat(["JSON.parse: Invalid syntax. Invalid value for JSON key: ", key])])
    };
    value := l_nth (ret, 0);


    {obj.DefineOwnProperty}(obj, key, newDataPropertyDescriptorFull(value, true, true, true));

    if ((l_len ret) = 2) {
      tokens := l_nth (ret, 1);
      if ((l_len tokens) > 0) {
        comma := hd tokens;
        if (!(comma = ",")) {
          throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, ["JSON.parse: Expected comma after JSON array value."])
        };
        tokens := tl tokens
      }
    } else {
      tokens := []
    }

  };
  tokens_len := l_len tokens;
  if (tokens_len > 0) {
    throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, [s_concat(["JSON.parse: Invalid syntax. Incomplete JSON object"])])
  };
  return obj
};

function parseJSONArray(global, this, NewTarget, strict, tokens) {
  arr := ArrayCreate(0., null);
  i := 0.;
  while ((l_len tokens) > 0) {
    ret := parseJSONValue(global, this, 'undefined, strict, tokens);
    if ((l_len ret) = 0) {
      throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, ["JSON.parse: Invalid syntax. Invalid value in JSON array."])
    };
    value := l_nth (ret, 0);

    {arr.DefineOwnProperty}(arr, ToString(i), newDataPropertyDescriptorFull(value, true, true, true));
    i := i + 1.;

    if ((l_len ret) = 2) {
      tokens := l_nth (ret, 1);
      if ((l_len tokens) > 0) {
        comma := hd tokens;
        if (!(comma = ",")) {
          throw SyntaxErrorConstructor(global, this, getSyntaxErrorConstructor(), strict, ["JSON.parse: Expected comma after JSON array value."])
        };
        tokens := tl tokens
      }
    } else {
      tokens := []
    }
  };
  return arr
};

function findClosingCurlyBracket(tokens) {
  obj_tokens := [];
  bracketCounter := 1;
  while ((bracketCounter > 0) &&& ((l_len tokens) > 0)) {
    token := hd tokens;
    tokens := tl tokens;
    if (token = "{") {
      bracketCounter := bracketCounter + 1
    } elif (token = "}") {
      bracketCounter := bracketCounter - 1
    };
    if (bracketCounter > 0) {
      obj_tokens := l_add (obj_tokens, token)
    }
  };
  return [obj_tokens, tokens]
};

function findClosingSquareBracket(tokens) {
  arr_tokens := [];
  bracketCounter := 1;
  while ((bracketCounter > 0) &&& ((l_len tokens) > 0)) {
    token := hd tokens;
    tokens := tl tokens;
    if (token = "[") {
      bracketCounter := bracketCounter + 1
    } elif (token = "]") {
      bracketCounter := bracketCounter - 1
    };
    if (bracketCounter > 0) {
      arr_tokens := l_add (arr_tokens, token)
    }
  };
  return [arr_tokens, tokens]
};

/**
 * 24.3.1 parse ( text [ , reviver ] )
 *
 * The parse function parses a JSON text (a JSON-formatted String) and produces
 * an ECMAScript value. The JSON format is a restricted form of ECMAScript literal.
 * JSON objects are realized as ECMAScript objects. JSON arrays are realized as
 * ECMAScript arrays. JSON strings, numbers, booleans, and null are realized as
 * ECMAScript Strings, Numbers, Booleans, and null. JSON uses a more limited set
 * of white space characters than WhiteSpace and allows Unicode code points U+2028
 * and U+2029 to directly appear in JSONString literals without using an escape
 * sequence. The process of parsing is similar to 11.1.4 and 11.1.5 as constrained
 * by the JSON grammar.
 *
 * The optional reviver parameter is a function that takes two parameters, (key
 * and value). It can filter and transform the results. It is called with each of
 * the key/value pairs produced by the parse, and its return value is used instead
 * of the original value. If it returns what it received, the structure is not
 * modified. If it returns undefined then the property is deleted from the result.
 */
function jsonParse(global, this, NewTarget, strict, args) {
  text := l_nth(args, 0);
  reviver := getOptionalParam(args, 1); /* - not passing 'null*/
  /*reviver := l_nth(args, 1);*/

  /* 1. Let JText be ToString(text). */
  JText := ToString(text);
  /* 2. ReturnIfAbrupt(JText). */
  @ReturnIfAbrupt(JText);
  
  /* 3. Parse JText interpreted as UTF-16 encoded Unicode points (6.1.4) 
    as a JSON text as specified in ECMA-404. 
    Throw a SyntaxError exception if JText is not a valid JSON text as defined in that specification. */
  objJSON := parseJSONText(global, this, 'undefined, strict, [JText]);

  /* 4. Let scriptText be the result of concatenating "(", JText, and ");". */
  scriptText := s_concat(["(", JText, ")"]);

  /* 5. Let completion be the result of parsing and evaluating scriptText as 
    if it was the source text of an ECMAScript Script. 
    but using the alternative definition of DoubleStringCharacter provided below. 
    The extended PropertyDefinitionEvaluation semantics defined in B.3.1 must not 
    be used during the evaluation. */
/*TODO*/
  /* 6. Let unfiltered be completion.[[value]].*/
  unfiltered := objJSON; /*TODO*/
  
  /* 7. Assert: unfiltered will be either a primitive value or an object that is 
      defined by either an ArrayLiteral or an ObjectLiteral. */
  /* TODO */
  

  /* 8. If IsCallable(reviver) is true, then */
  if (IsCallable(reviver) = true) {
    /* a. Let root be ObjectCreate(%ObjectPrototype%). */
    root := ObjectCreate(|Intrinsics|["ObjectPrototype"], null);
    /* b. Let rootName be the empty String. */
    rootName := "";
    /* c. Let status be CreateDataProperty(root, rootName, unfiltered). */
    status := CreateDataProperty(root, rootName, unfiltered);
    /* d. Assert: status is true. */
    assert (status = true);
    /* e. Return InternalizeJSONProperty(root, rootName). */
    res := InternalizeJSONProperty(root, rootName, reviver);
    return res
  }
  /* 9. Else */
  else {
  /* a. Return unfiltered. */
    return unfiltered
  }
};
/**
 * It is not permitted for a conforming implementation of JSON.parse to extend
 * the JSON grammars. If an implementation wishes to support a modified or extended
 * JSON interchange format it must do so by defining a different parse function.
 *
 * NOTE In the case where there are duplicate name Strings within an object,
 * lexically preceding values for the same key shall be overwritten.
 */




/**
 * The abstract operation InternalizeJSONProperty is a recursive abstract operation that takes two
 * parameters: a holder object and the String name of a property in that object.
 * InternalizeJSONProperty uses the value of reviver that was originally passed to the above parse
 * function.
 *
 * It is not permitted for a conforming implementation of JSON.parse to extend theJSON grammars.
 * If an implementation wishes to support a modified or extended JSON interchange format 
 * it must do so by defining a different parse function.
 *
 * NOTE In the case where there are duplicate name Strings within an object, 
 * lexically preceding values for the same key shall be overwritten.

 */
function InternalizeJSONProperty(holder, name, reviver) {
  /* 1. Let val be Get(holder, name). */
  val := Get(holder, name);
  /* 2. ReturnIfAbrupt(val). */
  @ReturnIfAbrupt(val);
  /* 3. If val is an object, then */
  if (Type(val) = "Object") { 
    /* a. Let isArray be IsArray(val). */
    isArray := IsArray(val);
    /* b. ReturnIfAbrupt(isArray). */
    @ReturnIfAbrupt(isArray);
    /* c. If isArray is true, then */
    if (isArray) {
      /* i. Set I to 0. */
      I := 0.;
      /* ii. Let len be ToLength(Get(val, "length")). */
      len := ToLength(Get(val, "length"));
      /* iii. ReturnIfAbrupt(len). */
      @ReturnIfAbrupt(len);
      /* iv. Repeat while I < len, */
      while (I < len) {
        /* 1. Let newElement be InternalizeJSONProperty(val, ToString(I)). */
        newElement := InternalizeJSONProperty(val, ToString(I), reviver);
        /* 2. ReturnIfAbrupt(newElement). */
        @ReturnIfAbrupt(newElement);
        /* 3. If newElement is undefined, then */
        if (newElement = 'undefined) {
          /* a. Let status be val.[[Delete]](ToString(I)).*/
          status := {val.Delete}(val, ToString(I))
          /*status := GuardedDelete(val, ToString(I)); */
        }
        /* 4. Else */
        else {
          /* a. Let status be CreateDataProperty(val, ToString(I), newElement). */
          status := CreateDataProperty(val, ToString(I), newElement)
          /* b. NOTE This algorithm intentionally does not throw an exception 
                if status is false.*/
        };
        
        /* 5. ReturnIfAbrupt(status). */
        @ReturnIfAbrupt(status); 
        /* 6. Add 1 to I. */
        I := I + 1.
      }
    }
    /* d. Else */
    else {
      /* i. Let keys be EnumerableOwnNames(val). */
      keys := EnumerableOwnNames(val);
      /* iii. ReturnIfAbrupt(keys). */
      @ReturnIfAbrupt(keys);
      /* iii. For each String P in keys do, */
      foreach (P : keys) {
        /* 1. Let newElement be InternalizeJSONProperty(val, P). */
        newElement := InternalizeJSONProperty(val, P, reviver);

        /* 2. ReturnIfAbrupt(newElement). */
        @ReturnIfAbrupt(newElement);
        /* 3. If newElement is undefined, then */
        if (newElement = 'undefined) {

          /* a. Let status be val.[[Delete]](P).*/
          status := {val.Delete}(val, P)
        }
        /* 4. Else */
        else {
          /* a. Let status be CreateDataProperty(val, P, newElement). */
          status := CreateDataProperty(val, P, newElement)
          /* b. NOTE This algorithm intentionally does not throw an exception
                if status is false. */
        };
        /* 5. ReturnIfAbrupt(status). */
        @ReturnIfAbrupt(status)
      }
    }
  };
  /* 4. Call(reviver, holder, «name, val»). */
  return Call(null, null, reviver, holder, [name, val])
};




/**
 * 15.12.3 stringify ( value [ , replacer [ , space ] ] )
 *
 * The stringify function returns a String in JSON format representing
 * an ECMAScript value. It can take three parameters. The first parameter
 * is required. The value parameter is an ECMAScript value, which is usually
 * an object or array, although it can also be a String, Boolean, Number or
 * null. The optional replacer parameter is either a function that alters
 * the way objects and arrays are stringified, or an array of Strings and
 * Numbers that acts as a white list for selecting the object properties
 * that will be stringified. The optional space parameter is a String or
 * Number that allows the result to have white space injected into it to
 * improve human readability.
 *
 * These are the steps in stringifying an object:
 */
function jsonStringify(global, this, NewTarget, strict, args) {
  value := l_nth(args, 0);

  replacer := getOptionalParam(args, 1);
  space := getOptionalParam(args, 2);

  /* 1. Let stack be an empty List. */
  stack := [];
  /* 2. Let indent be the empty String. */
  indent := "";
  /* 3. Let PropertyList and ReplacerFunction be undefined. */
  PropertyList := 'undefined;
  ReplacerFunction := 'undefined;
  /* 4. If Type(replacer) is Object, then */
  if (Type(replacer) = "Object") {
    /* a. If IsCallable(replacer) is true, then */
    if (IsCallable(replacer) = true) {
      /* i. Let ReplacerFunction be replacer. */
      ReplacerFunction := replacer
    } else {
      /* i. Let isArray be IsArray(replacer). */
      isArray := IsArray(replacer);
      /* ii. ReturnIfAbrupt(isArray). */
      @ReturnIfAbrupt(isArray);
      /* iii. If isArray is true, then  */
      if(isArray = true) {
        /* 1. Let PropertyList be an empty internal List */
        PropertyList := [];
        /* 2. Let len be ToLength(Get(replacer, "length")). */
        len := ToLength(Get(replacer, "length"));
        /* 3. ReturnIfAbrupt(len). */
        @ReturnIfAbrupt(len);
        /* 4. Let k be 0.*/
        k := 0.;
        /* 5. Repeat while k<len. */
        while (k < len) {
          /* a. Let v be Get(replacer, ToString(k)). */
          v := Get(replacer, ToString(k));
          /* b. ReturnIfAbrupt(v). */
          @ReturnIfAbrupt(v);
          /* c. Let item be undefined. */
          item := 'undefined;
          /* d. If Type(v) is String, let item be v. */
          if (Type(v) = "String") {
            item := v
          }
          /* e. Else if Type(v) is Number, let item be ToString(v). */
          elif(Type(v) = "Number") {
            item := ToString(v)
          }
          /* f. Else if Type(v) is Object, then */
          elif(Type(v) = "Object") {
            /* i. If v has a [[StringData]] or [[NumberData]] internal slot, let item be ToString(v). */
            if(("StringData" in_obj v) ||| ("NumberData" in_obj v)) {
              item := ToString(v)
            };
            /* ii. ReturnIfAbrupt(item). */
            @ReturnIfAbrupt(item)
          };
          /* g. If item is not undefined and item is not currently an element of PropertyList, then */
          if ( !(item = 'undefined) &&& !(item in_list PropertyList)) {
            /* i. Append item to the end of PropertyList. */
            PropertyList := l_add(PropertyList, item)
          };
          /* h. Let k be k+1. */
          k := k + 1.
        }
      }
    }
  };
  /* 5. If Type(space) is Object then, */
  if (Type(space) = "Object") {
    /* a. If space has a [[NumberData]] internal slot, then */
    if ("NumberData" in_obj space) {
      /* i. Let space be ToNumber(space). */
      space := ToNumber(space);
      /* ii. ReturnIfAbrupt(space). */
      @ReturnIfAbrupt(space)
    } else {
    /* b. Else if space has a [[StringData]] internal slot, then */
      if ("StringData" in_obj space) {
        /* i. Let space be ToString(space). */
        space := ToString(space);
        /* ii. ReturnIfAbrupt(space). */
        @ReturnIfAbrupt(space)
      }
    }
  };
  /* 6. If Type(space) is Number */
  if (Type(space) = "Number") {
    /* a. Let space be min(10, ToInteger(space)). */
    space := min(10., ToInteger(space));
    /* b. Set gap to a String containing space occurrences of code unit 0x0020 (SPACE).
          This will be the empty String if space is less than 1. */
    i := 0.;
    lst := [];
    while (i < space) {
      lst := l_prepend(" ", lst);
      i := i + 1.
    };
    gap := s_concat(lst)
  }
  /* 7. Else if Type(space) is String */
  else {
    if (Type(space) = "String") {
      /* a. If the number of elements in space is 10 or less, set gap to space
            otherwise set gap to a String consisting of the first 10 elementss of space. */
      spaceLen := s_len_u (space);
      if (spaceLen <= 10) {
        gap := space
      } else {
        gap := s_substr_u(space, 0, 10)
      }
    }
    /* 8. Else */
    else {
      /* a. Set gap to the empty String. */
      gap := ""
    }
  };
  /* 9. Let wrapper be ObjectCreate(%ObjectPrototype%). */
  wrapper := ObjectCreate(|Intrinsics|["ObjectPrototype"], null);
  /* 10. Let status be CreateDataProperty(wrapper, the empty String, value). */
  status := CreateDataProperty(wrapper, "", value);
  /* 11. Assert: status is true. */
  assert (status = true);

  /* 12. Return SerializeJSONProperty(the empty String, wrapper). */
  return SerializeJSONProperty("", wrapper, stack, indent, gap, PropertyList, space, ReplacerFunction)
};
/**
 * NOTE 1 JSON structures are allowed to be nested to any depth, but they must be
 * acyclic. If value is or contains a cyclic structure, then the stringify function
 * must throw a TypeError exception. This is an example of a value that cannot be stringified:
 *
 * a = [];
 * a[0] = a;
 * my_text = JSON.stringify(a); // This must throw an TypeError.
 *
 * NOTE 2 Symbolic primitive values are rendered as follows:
 * - The null value is rendered in JSON text as the String null.
 * - The undefined value is not rendered.
 * - The true value is rendered in JSON text as the String true.
 * - The false value is rendered in JSON text as the String false.
 *
 * NOTE 3 String values are wrapped in double quotes. The characters " and \ are
 * escaped with \ prefixes. Control characters are replaced with escape sequences
 * \uHHHH, or with the shorter forms, \b (backspace), \f (formfeed), \n (newline),
 * \r (carriage return), \t (tab).
 *
 * NOTE 4 Finite numbers are stringified as if by calling ToString(number).
 * NaN and Infinity regardless of sign are represented as the String null.
 *
 * NOTE 5 Values that do not have a JSON representation (such as undefined and
 * functions) do not produce a String. Instead they produce the undefined value.
 * In arrays these values are represented as the String null. In objects an
 * unrepresentable value causes the property to be excluded from stringification.
 *
 * NOTE 6 An object is rendered as an opening left brace followed by zero or more
 * properties, separated with commas, closed with a right brace. A property is a
 * quoted String representing the key or property name, a colon, and then the
 * stringified property value. An array is rendered as an opening left bracket
 * followed by zero or more values, separated with commas, closed with a right bracket.
 */




/* The abstract operation SerializeJSONProperty(key, holder) has access to ReplacerFunction
   from the invocation of the stringify method. Its algorithm is as follows: */
function SerializeJSONProperty(key, holder, stack, indent, gap, PropertyList, space, ReplacerFunction) {
  /* 1. Let value be Get(holder, key). */
  value := Get(holder, key);
  /* 2. ReturnIfAbrupt(value). */
  @ReturnIfAbrupt(value);

  /* 3. If Type(value) is Object, then */
  if (Type(value) = "Object") {
    /* a. Let toJSON be Get(value, "toJSON"). */
    toJSON := Get(value, "toJSON");
    /* b. ReturnIfAbrupt(toJSON). */
    @ReturnIfAbrupt(toJSON);
    /* c. If IsCallable(toJSON) is true */
    if (IsCallable(toJSON) = true) {
      /* i. Let value be Call(toJSON, value, «key»). */
      value := Call(null, null, toJSON, value, [key]);
      /* ii. ReturnIfAbrupt(value). */
      @ReturnIfAbrupt(value)
    }
  };
  /* 4. If ReplacerFunction is not undefined, then */
  if (!(ReplacerFunction = 'undefined)) {
    /* a. Let value be Call(ReplacerFunction, holder, «key, value»). */
    value := Call(null, null, ReplacerFunction, holder, [key, value]);
    /* b. ReturnIfAbrupt(value). */
    @ReturnIfAbrupt(value)
  };
  /* 5. If Type(value) is Object then, */
  if (Type(value) = "Object") {
    /* a. If value has a [[NumberData]] internal slot, then */
    if ("NumberData" in_obj value) {
      /* i. Let value be ToNumber(value). */
      value := ToNumber(value);
      /* ii. ReturnIfAbrupt(value). */
      @ReturnIfAbrupt(value)
    }
    /* b. Else if value has a [[StringData]] internal slot, then*/
    elif ("StringData" in_obj value) {
      /* i. Let value be ToString(value). */
      value := ToString(value);
      /* ii. ReturnIfAbrupt(value). */
      @ReturnIfAbrupt(value)
      /* c. Else if value has a [[BooleanData]] internal slot, then */
    } elif ("BooleanData" in_obj value) {
      /* i. Let value be the value of the [[BooleanData]] internal slot of value. */
      value := value.BooleanData
    }
  };
  /* 6. If value is null then return "null". */
  if (value = 'null) {
    return "null"
  };
  /* 7. If value is true then return "true". */
  if (value = true) {
    return "true"
  };
  /* 8. If value is false then return "false". */
  if (value = false) {
    return "false"
  };
  /* 9. If Type(value) is String, return QuoteJSONString(value). */
  if (Type(value) = "String") {
    return QuoteJSONString(value)
  };
  /* 10. If Type(value) is Number then */
  if (Type(value) = "Number") {
    /* a. If value is finite, return ToString(value). */
    if (!((value = NaN) ||| (value = Infinity) ||| (value = -Infinity))) {
      return ToString(value)
    }
    /* b. Else, return "null". */
    else {
      return "null"
    }
  };
  /* 11. If Type(value) is Object, and IsCallable(value) is false, then*/
  if ((Type(value) = "Object") && (IsCallable(value) = false)) {
    /* a. Let isArray be IsArray(value). */
    isArray := IsArray(value);
    /* b. ReturnIfAbrupt(isArray). */
    @ReturnIfAbrupt(isArray);
    /* c. If isArray is true, return SerializeJSONArray(value). */
    if (isArray = true) {
      return SerializeJSONArray(value, stack, indent, gap, PropertyList, ReplacerFunction, space)
    }
    /* d. Else, return SerializeJSONObject(value). */
    else {
      return SerializeJSONObject(value, stack, indent, gap, PropertyList, ReplacerFunction, space)
    }
  };
  /* 12. Return undefined. */
  return 'undefined
};


 /**
  * In section 6.1.4 of ECMA 2019
  * every code unit with a numeric value in the inclusive range 0xD800 to 0xDBFF (defined
  * by the Unicode Standard as a leading surrogate, or more formally as a high-surrogate
  * code unit) and every code unit with a numeric value in the inclusive range 0xDC00 to
  * 0xDFFF (defined as a trailing surrogate, or more formally as a low-surrogate code unit) 
  */
function isLeadingSurrogate(code) {
  start := to_char_code_u ("\u{D800}");
  end := to_char_code_u ("\u{D8FF}");
  if ((code >= start) &&& (code <= end)) {
    return true
  } else {
    return false
  }
};



/**
 * The abstract operation QuoteJSONString(value) wraps a String value in 
 * QUOTATION MARK code units and escapes certain other code units within it.
 */
function QuoteJSONString(value) {
  /* 1. Let product be code unit 0x0022 (QUOTATION MARK).. */
  product := "\"";
  /* 2. For each code unit C in value */
  valueLen := s_len_u (value);
  i := 0;
  while (i < valueLen) {
    C := s_nth_u(value, i);
    C_code := to_char_code_u (C);

    /* a. If C is 0x0022 (QUOTATION MARK) or 0x005C (REVERSE SOLIDUS), then */
    if ((C = "\"") ||| (C = "\\")) {
      /* i. Let product be the concatenation of product and code unit 0x005C (REVERSE SOLIDUS). */
      product := s_concat([product, "\\"]);
      /* ii. Let product be the concatenation of product and C. */
      product := s_concat([product, C])
    }
    /* Else if C is 0x0008 (BACKSPACE), 0x000C (FORM FEED), 0x000A (LINE FEED), 
        0x000D( CARRIAGE RETURN), or 0x000B (LINE TABULATION), then */
    elif ((C = "\b") ||| (C = "\f") ||| (C = "\n") ||| (C = "\r") ||| (C = "\t")) {
      /* i. Let product be the concatenation of product and code unit 0x005C (REVERSE SOLIDUS). */
      product := s_concat([product, "\\"]);
      /* ii. Let abbrev be the String value corresponding to the value of C as follows:
        /* BACKSPACE 	          "b" */
        /* FORM FEED (FF) 	    "f" */
        /* LINE FEED (LF) 	    "n" */
        /* CARRIAGE RETURN (CR) "r" */
        /* LINE TABULATION 	    "t" */
      if (C = "\b") {
        abbrev := "b"
      } elif (C = "\f") {
        abbrev := "f"
      } elif (C = "\n") {
        abbrev := "n"
      } elif (C = "\r") {
        abbrev := "r"
      } elif (C = "\t") {
        abbrev := "t"
      };
      /* iii. Let product be the concatenation of product and abbrev. */
      product := s_concat([product, abbrev])
    }
    /* Else if C has a code unit value less than 0x0020 (SPACE), then  */
    elif (C_code < 32) {
      /* i. Let product be the concatenation of product and and code unit 0x005C (REVERSE SOLIDUS). */
      product := s_concat([product, "\\"]);
      /* ii. Let product be the concatenation of product and "u". */
      product := s_concat([product, "u"]);
      /* iii. Let hex be the string result of converting the numeric code unit 
              value of C to a String of four hexadecimal digits. 
              Alphabetic hexadecimal digits are presented as lowercase Latin letters. */
      hex := int_to_four_hex (to_char_code_u (C));
      /* iv. Let product be the concatenation of product and hex. */
      product := s_concat([product, hex])
    }
    /* d. Else */
    else {
      /* i. Let product be the concatenation of product and C. */
      product := s_concat([product, C])
    };

    i := i + 1
  };
  /* 3. Let product be the concatenation of product and code unit 0x0022 (QUOTATION MARK). */
  product := s_concat([product, "\""]);
  /* 4. Return product. */
  return product
};




/**
 * The abstract operation SerializeJSONObject with argument value serializes an object.
 * It has access to the stack, indent, gap, and PropertyList values of the current 
 * invocation of the stringify method.
 *
 */
function SerializeJSONObject(value, stack, indent, gap, PropertyList, ReplacerFunction, space) {
  /* 1.If stack contains value, throw a TypeError exception because the structure is cyclical. */
  if (value in_list stack) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Append value to stack. */
  stack := l_add(stack, value);
  /* 3. Let stepback be indent. */
  stepback := indent;
  /* 4. Let indent be the concatenation of indent and gap. */
  indent := s_concat([indent, gap]);
  /* 5. If PropertyList is not undefined, then */
  if (!(PropertyList = 'undefined)) {
    /* a. Let K be PropertyList. */
    K := PropertyList
  }  
  /* 6. Else */
  else {
    /* a. Let K be EnumerableOwnNames(value). */
    K := EnumerableOwnNames(value)
  };
  /* 7. Let partial be an empty List. */
  partial := [];
  /* 8. For each element P of K, */
  foreach (P : K) {
    /* a. Let strP be SerializeJSONProperty(P, value).*/
    strP := SerializeJSONProperty(P, value, stack, indent, gap, PropertyList, space, ReplacerFunction);
    /* b. ReturnIfAbrupt(strP). */
    @ReturnIfAbrupt(strP);
    /* c. If strP is not undefined */
    if (!(strP = 'undefined)) {
      /* i. Let member be QuoteJSONString(P). */
      member := QuoteJSONString(P);
      /* ii. Let member be the concatenation of member and the string ":". */
      member := s_concat([member, ":"]);
      /* iii. If gap is not the empty String, then */
      if (!(gap = "")) {
        /* 1. Let member be the concatenation of member and and code unit 0x0020 (SPACE). */
        member := s_concat([member, " "])
      };
      /* iv. Let member be the concatenation of member and strP. */
      member := s_concat([member, strP]);
      /* v. Append member to partial. */
      partial := l_add(partial, member)
    }
  };
  /* 9. If partial is empty, then */
  if ((l_len partial) = 0) {
    /* a. Let final be "{}". */
    final := "{}"
  }
  /* 10. Else */
  else {
    /* a. If gap is the empty String, then */
    if (gap = "") {
      /* i. Let properties be a String formed by concatenating all the element Strings
          of partial with each adjacent pair of Strings separated with code unit 0x002C (COMMA).
          A comma is not inserted either before the first String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, ",");
      /* ii. Let final be the result of concatenating "{", properties, and "}". */
      final := s_concat(["{", properties, "}"])
    }
    /* b. Else gap is not the empty String */
    else {
      /* i. Let separator be the result of concatenating code unit 0x002C (COMMA),
            code unit 0x000A (LINE FEED), and indent. */
      separator := s_concat([",", "\n", indent]);
      /* ii. Let properties be a String formed by concatenating all the element
             Strings of partial with each adjacent pair of Strings separated
             with separator. The separator String is not inserted either before
             the first String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, separator);
      /* iii. Let final be the result of concatenating "{", code unit 0x000A (LINE FEED),
             indent, properties, code unit 0x000A, stepback, and "}". */
      final := s_concat(["{", "\n", indent, properties, "\n", stepback, "}"])
    }
  };
  /* 11. Remove the last element of stack. */
  stack := l_remove_last (stack);
  /* 12. Let indent be stepback. */
  indent := stepback;
  /* 13. Return final. */
  return final
};




/**
 * The abstract operation SerializeJSONArray with argument value serializes an array. 
 * It has access to the stack, indent, and gap values of the 
 * current invocation of the stringify method.
 *
 * NOTE The representation of arrays includes only the elements 
 * between zero and array.length – 1 inclusive. 
 * Properties whose keys are not array indexes are excluded from the stringification. 
 * An array is stringified as an opening LEFT SQUARE BRACKET, elements separated by COMMA, 
 * and a closing RIGHT SQUARE BRACKET.
 *
 */
function SerializeJSONArray(value, stack, indent, gap, PropertyList, ReplacerFunction, space) {
  /* 1. If stack contains value, throw a TypeError exception because
        the structure is cyclical. */
  if (value in_list stack) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Append value to stack. */
  stack := l_add(stack, value);
  /* 3. Let stepback be indent. */
  stepback := indent;
  /* 4. Let indent be the concatenation of indent and gap. */
  indent := s_concat([indent, gap]);
  /* 5. Let partial be an empty List. */
  partial := [];
  /* 6. Let len be ToLength(Get(value, "length")). */
  len := ToLength(Get(value, "length"));
  /* 7. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 8. Let index be 0. */
  index := 0.;
  /* 9. Repeat while index < len */
  while (index < len) {
    /* a. Let strP be SerializeJSONProperty(ToString(index), value).*/
    strP := SerializeJSONProperty(ToString(index), value, stack, indent, gap, PropertyList, space, ReplacerFunction);
    /* b. ReturnIfAbrupt(strP). */
    @ReturnIfAbrupt(strP);
    /* c. If strP is undefined, then */
    if (strP = 'undefined) {
      /* i. Append "null" to partial. */
      partial := l_add(partial, "null")
    }
    /* d. Else */
    else {
      /* i. Append strP to partial. */
      partial := l_add(partial, strP)
    };
    /* e. Increment index by 1. */
    index := index + 1.
  };
  /* 10. If partial is empty, then */
  if ((l_len partial) = 0) {
    /* a. Let final be "[]". */
    final := "[]"
  }
  /* 11. Else */
  else {
    /* a. If gap is the empty String, then */
    if (gap = "") {
      /* i. Let properties be a String formed by concatenating all the element
            Strings of partial with each adjacent pair of Strings separated with
            code unit 0x002C (COMMA). A comma is not inserted either before the first
            String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, ",");
      /* ii. Let final be the result of concatenating "[", properties, and "]". */
      final := s_concat(["[", properties, "]"])
    }
    /* b. Else */
    else {
      /* i. Let separator be the result of concatenating 
          code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent. */
      separator := s_concat([",", "\n", indent]);
      /* ii. Let properties be a String formed by concatenating all the element
             Strings of partial with each adjacent pair of Strings separated with
             separator. The separator String is not inserted either before the
             first String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, separator);
      /* iii. Let final be the result of concatenating "[", code unit 0x000A (LINE FEED),
             indent, properties, code unit 0x000A, stepback, and "]". */
      final := s_concat(["[", "\n", indent, properties, "\n", stepback, "]"])
    }
  };
  /* 12. Remove the last element of stack. */
  stack := l_remove_last (stack);
  /* 13. Let indent be stepback. */
  indent := stepback;
  /* 14. Return final. */
  return final
}
