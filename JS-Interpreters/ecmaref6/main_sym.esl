import "./esl_interpreter.esl";
import "./bindings/ffi_symbolic.esl";
import "./bindings/node-bindings.esl";

function init() {
  initGlobalVars();
  |globals_stack| := stack_make();
  return;
}

/* Redefine this functions because we need to initialize the node global obj */
function ECMAScriptNodeInitialization(sourceText) {
    realm := CreateRealm();

    newContext := createExecutionContext();
    newContext.Function := 'null;
    newContext.Realm := realm;
    pushExecStack(newContext);

    status := InitializeNodeHostDefinedRealm(realm);
    if (isAnAbruptCompletion(status)) {
        assert (realm == null );
        return;
    }

    |realm| := realm;

    EnqueueJob("ScriptJobs", "ScriptEvaluationJob", [sourceText]);
    return NextJob(NormalCompletion('undefined));
}

function InitializeNodeHostDefinedRealm(realm) {
    intrinsics := realm.intrinsics;
    global := intrinsics.GlobalObject;
    SetRealmGlobalObject(realm, global);

    globalObj := SetDefaultGlobalBindings(realm);
    @ReturnIfAbrupt(globalObj);

    init_node_global_object(globalObj, intrinsics.ObjectPrototype, false);
    return NormalCompletion('undefined);
}

function stringOfError(error : object) : string {
  name := Get(error, "name");
  @ReturnIfAbrupt(name);
  if (name == 'undefined)
    name := "Error";

  message := Get(error, "message");
  @ReturnIfAbrupt(message);
  if (message == 'undefined)
    return "Uncaught " + name;
  return "Uncaught " + name + ": " + message;
}

function main() {
  init();
  x := buildAST();
  ret := ECMAScriptNodeInitialization(x);
  c_value := getCompletionValue(ret);

  if ((typeof c_value == "object") &&& ("ErrorData" in_obj c_value) ) {
    name := Get(c_value, "name");
    if (name == "TypeError") {
      print "Uncaught TypeError";
      extern assume(false);
    }
    error := stringOfError(c_value);
    extern abort(error);
  }

  return ret;
}
