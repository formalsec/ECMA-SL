import "extras/symbolic/api.esl";
import "extras/symbolic/lazy_object.esl";
import "extras/symbolic/polluted_object.esl";
import "extras/section_node.esl";
import "esl_interpreter.esl";

/* Redefine this functions because we need to initialize the node global obj */
function ECMAScriptNodeInitialization(sourceText) {
    initGlobalVars();
    realm := CreateRealm();

    newContext := createExecutionContext();
    newContext.Function := 'null;
    newContext.Realm := realm;
    pushExecStack(newContext);

    status := InitializeNodeHostDefinedRealm(realm);
    if (isAnAbruptCompletion(status)) {
        assert( realm = null );
        return
    };

    |realm| := realm;

    EnqueueJob("ScriptJobs", "ScriptEvaluationJob", [ sourceText ]);
    return NextJob(NormalCompletion('undefined))
}

function InitializeNodeHostDefinedRealm(realm) {
    intrinsics := realm.intrinsics;
    global := intrinsics.GlobalObject;
    SetRealmGlobalObject(realm, global);

    globalObj := SetDefaultGlobalBindings(realm);
    @ReturnIfAbrupt(globalObj);

    initNodeGlobalObject(globalObj, intrinsics.ObjectPrototype, false);
    return NormalCompletion('undefined)
}

function stringOfError(error : object) : string {
  name := Get(error, "name");
  @ReturnIfAbrupt(name);
  if (name = 'undefined) {
    name := "Error"
  };

  message := Get(error, "message");
  @ReturnIfAbrupt(message);
  if (message = 'undefined) {
    return "Uncaught " + name
  };
  return "Uncaught " + name + ": " + message
}

function main() {
  x := buildAST();
  ret := ECMAScriptNodeInitialization(x);
  c_value := getCompletionValue(ret);
  if ((typeof c_value = __$Obj) &&& ("ErrorData" in_obj c_value) ) {
    name := Get(c_value, "name");
    if (name = "TypeError") {
      print "Uncaught TypeError";
      extern assume(false)
    };
    error := stringOfError(c_value);
    extern abort(error)
  };
  return ret
}
