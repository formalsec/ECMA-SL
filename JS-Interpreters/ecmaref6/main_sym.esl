import "esl_interpreter.esl";
import "bindings/ffi_symbolic.esl";
import "bindings/node-bindings.esl";

/* Redefine this functions because we need to initialize the node global obj */
function ECMAScriptNodeInitialization(sourceText) {
    initGlobalVars();
    realm := CreateRealm();
    newContext := createExecutionContext();
    newContext.Function := 'null;
    newContext.Realm := realm;
    pushExecStack(newContext);
    status := InitializeNodeHostDefinedRealm(realm);
    if (isAnAbruptCompletion(status)) {
        assert (realm == null );
        return;
    }
    |realm| := realm;
    EnqueueJob("ScriptJobs", "ScriptEvaluationJob", [sourceText]);
    return NextJob(NormalCompletion('undefined));
}

function InitializeNodeHostDefinedRealm(realm) {
    intrinsics := realm.intrinsics;
    global := intrinsics.GlobalObject;
    SetRealmGlobalObject(realm, global);
    globalObj := SetDefaultGlobalBindings(realm);
    initNodeGlobalObject(globalObj, intrinsics.ObjectPrototype, false);
    @ReturnIfAbrupt(globalObj);
    return NormalCompletion('undefined);
}

function stringOfError(error : object) : string {
  name := Get(error, "name");
  @ReturnIfAbrupt(name);
  if (name == 'undefined)
    name := "Error";

  message := Get(error, "message");
  @ReturnIfAbrupt(message);
  if (message == 'undefined)
    return "Uncaught " + name;
  return "Uncaught " + name + ": " + message;
}

function main() {
  x := buildAST();
  ret := ECMAScriptNodeInitialization(x);
  c_value := getCompletionValue(ret);

  if ((typeof c_value == "object") &&& ("ErrorData" in_obj c_value) ) {
    error := stringOfError(c_value);
    extern abort(error);
  }

  return ret;
}
