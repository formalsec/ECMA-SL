import "symbolic/api.esl";
import "symbolic/lazy_object.esl";
import "symbolic/polluted_object.esl";
import "node/global.esl";
import "node/fs.esl";
import "node/cp.esl";
import "node/os.esl";
import "node/path.esl";
import "node/shelljs.esl";
import "node/cross-spawn.esl";
import "node/process.esl";
import "esl_interpreter.esl";

/* Redefine this functions because we need to initialize the node global obj */
function ECMAScriptNodeInitialization(sourceText) {
    initGlobalVars();
    realm := CreateRealm();
    newContext := createExecutionContext();
    newContext.Function := 'null;
    newContext.Realm := realm;
    pushExecStack(newContext);
    status := InitializeNodeHostDefinedRealm(realm);
    if (isAnAbruptCompletion(status)) {
        assert( realm = null );
        return
    };
    |realm| := realm;
    EnqueueJob("ScriptJobs", "ScriptEvaluationJob", [sourceText]);
    return NextJob(NormalCompletion('undefined))
}

function InitializeNodeHostDefinedRealm(realm) {
    intrinsics := realm.intrinsics;
    global := intrinsics.GlobalObject;
    SetRealmGlobalObject(realm, global);
    globalObj := SetDefaultGlobalBindings(realm);
    initNodeGlobalObject(globalObj, intrinsics.ObjectPrototype, false);
    @ReturnIfAbrupt(globalObj);
    return NormalCompletion('undefined)
}

function main() {
  x := buildAST();
  ret := ECMAScriptNodeInitialization(x);
  c_value := getCompletionValue(ret);

  if ((typeof c_value = __$Obj) &&& ("ErrorData" in_obj c_value) ) {
    error_name := {c_value.Get}(c_value, "name", c_value);
    extern abort(error_name);
    return newCompletion(getCompletionType(ret), error_name, getCompletionTarget(ret))
  };

  return ret
}
