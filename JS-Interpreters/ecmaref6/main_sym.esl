import "symbolic/api.esl";
import "symbolic/lazy_object.esl";
import "symbolic/polluted_object.esl";
import "node/global.esl";
import "node/fs.esl";
import "node/cp.esl";
import "node/os.esl";
import "node/path.esl";
import "node/shelljs.esl";
import "node/cross-spawn.esl";
import "node/process.esl";
import "node/execa.esl";
import "esl_interpreter.esl";

/* Redefine this functions because we need to initialize the node global obj */
function ECMAScriptNodeInitialization(sourceText) {
    initGlobalVars();
    realm := CreateRealm();
    newContext := createExecutionContext();
    newContext.Function := 'null;
    newContext.Realm := realm;
    pushExecStack(newContext);
    status := InitializeNodeHostDefinedRealm(realm);
    if (isAnAbruptCompletion(status)) {
        assert( realm = null );
        return
    };
    |realm| := realm;
    EnqueueJob("ScriptJobs", "ScriptEvaluationJob", [sourceText]);
    return NextJob(NormalCompletion('undefined))
}

function InitializeNodeHostDefinedRealm(realm) {
    intrinsics := realm.intrinsics;
    global := intrinsics.GlobalObject;
    SetRealmGlobalObject(realm, global);
    globalObj := SetDefaultGlobalBindings(realm);
    initNodeGlobalObject(globalObj, intrinsics.ObjectPrototype, false);
    @ReturnIfAbrupt(globalObj);
    return NormalCompletion('undefined)
}

function stringOfError(error : object) : string {
  name := Get(error, "name");
  @ReturnIfAbrupt(name);
  if (name = 'undefined) {
    name := "Error"
  };

  message := Get(error, "message");
  @ReturnIfAbrupt(message);
  if (message = 'undefined) {
    return "Uncaught " + name
  };
  return "Uncaught " + name + ": " + message
}

function main() {
  x := buildAST();
  ret := ECMAScriptNodeInitialization(x);
  c_value := getCompletionValue(ret);

  if ((typeof c_value = __$Obj) &&& ("ErrorData" in_obj c_value) ) {
    error := stringOfError(c_value);
    extern abort(error)
  };

  return ret
}
