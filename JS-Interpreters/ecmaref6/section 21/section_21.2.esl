/* Copyright (C) 2022-2025 formalsec programmers
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
* Author: Leonor Barreiros
*/

/* 21.2 RegExp (Regular Expression) Objects */

/**
* A RegExp object contains a regular expression and the associated flags.
*
* NOTE The form and functionality of regular expressions is modelled after the regular
* expression facility in the Perl 5 programming language.
*/

function initRegExpObject(globalObject, ObjectPrototype, strict) {
  regExpConstructor := CreateGeneralBuiltInFunction(getFunctionPrototype(strict), ["patern", "flags"], "RegExpConstructorAsFunction", globalObject, strict, 0.);
  regExpPrototype := initRegExpPrototype(globalObject, ObjectPrototype, regExpConstructor, strict);

  descriptor := newDataPropertyDescriptorFull(regExpConstructor, true, false, true);
  setJSProperty(regExpPrototype, "constructor", descriptor);
  setInternalProperty(regExpConstructor, "Construct", "RegExpConstructor");

  descriptor := newDataPropertyDescriptorFull(regExpPrototype, false, false, false);
  setJSProperty(regExpConstructor, "prototype", descriptor);

  /* 21.2.4.2 get RegExp [ @@species ] */
  species := CreateBuiltInFunctionObject([], "getRegExpSpecies", globalObject, strict, null);
  /* length */
  createBuiltInPropertyWithFullDescriptor(species, "length", 0., false, false, true);
  /* The value of the name property of this function is "get [Symbol.species]". */
  createBuiltInPropertyWithFullDescriptor(species, "name", "get [Symbol.species]", false, false, true);
  setInternalProperty(species, "Construct", "RegExpConstructor");

  species_desc := newGetAccessorPropertyDescriptorFull(species, false, true);
  /* setJSProperty(regExpConstructor, getSpeciesPropertyName(), species_desc); */
  setJSProperty(regExpConstructor, getSpeciesPropertyName(), species_desc);

  /* 21.2.6.1 lastIndex */
  /**
  * The value of the lastIndex property specifies the String index at which to start the next match. It is coerced
  * to an integer when used (see 21.2.5.2.2). This property shall have the attributes { [[Writable]]: true, [[Enumerable]]:
  * false, [[Configurable]]: false }.
  */
  setJSProperty(regExpConstructor, "lastIndex", newDataPropertyDescriptorFull(0., true, false, false));

  return regExpConstructor;
}

function initRegExpPrototype(global, objectPrototype, objectConstructor, strict) {
  regExpPrototypeObject := NewECMAScriptObject();
  setAllInternalMethodsOfOrdinaryObject(regExpPrototypeObject);

  setInternalProperty(regExpPrototypeObject, "Class", "Object");
  setInternalProperty(regExpPrototypeObject, "Prototype", objectPrototype);

  /* 21.2.5.1 RegExp.prototype.constructor */
  createBuiltInProperty(regExpPrototypeObject, "constructor", objectConstructor);
  setInternalProperty(regExpPrototypeObject, "Construct", objectConstructor);

  /* 21.2.5.2 RegExp.prototype.exec ( string ) */
  exec := CreateBuiltInFunctionObject(["string"], "RegExpPrototypeexec", global, strict, null);
  /* length */
  setJSProperty(exec, "length", newDataPropertyDescriptorFull(1., false, false, true));
  /* name */
  setJSProperty(exec, "name", newDataPropertyDescriptorFull("exec", false, false, true));
  createBuiltInProperty(regExpPrototypeObject, "exec", exec);

  /* 21.2.5.3 get RegExp.prototype.flags */
  flags := CreateBuiltInFunctionObject([], "getRegExpFlagsAccessorProperty", global, strict, null);
  flags_desc := newGetAccessorPropertyDescriptorFull(flags, false, true);
  setJSProperty(regExpPrototypeObject, "flags", flags_desc);
  /* length */
  setJSProperty(flags, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(flags, "name", newDataPropertyDescriptorFull("get flags", false, false, true));

  /* 21.2.5.4 get RegExp.prototype.global */
  global_ := CreateBuiltInFunctionObject([], "getRegExpGlobalAccessorProperty", global, strict, null);
  global_desc := newGetAccessorPropertyDescriptorFull(global_, false, true);
  setJSProperty(regExpPrototypeObject, "global", global_desc);
  /* length */
  setJSProperty(global_, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(global_, "name", newDataPropertyDescriptorFull("get global", false, false, true));

  /* 21.2.5.5 get RegExp.prototype.ignoreCase */
  ignoreCase := CreateBuiltInFunctionObject([], "getRegExpIgnoreCaseAccessorProperty", global, strict, null);
  ignoreCase_desc := newGetAccessorPropertyDescriptorFull(ignoreCase, false, true);
  setJSProperty(regExpPrototypeObject, "ignoreCase", ignoreCase_desc);
  /* length */
  setJSProperty(ignoreCase, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(ignoreCase, "name", newDataPropertyDescriptorFull("get ignoreCase", false, false, true));

  /* 21.2.5.6 RegExp.prototype [ @@match ] ( string ) */
  matchFunctionObject := CreateBuiltInFunctionObject(["string"], "RegExpPrototypematch", global, strict, null);
  createBuiltInProperty(regExpPrototypeObject, getMatchPropertyName(), matchFunctionObject);
  /* length */
  setJSProperty(matchFunctionObject, "length", newDataPropertyDescriptorFull(1., false, false, true));
  /* The value of the name property of this function is "[Symbol.match]". */
  setJSProperty(matchFunctionObject, "name", newDataPropertyDescriptorFull("[Symbol.match]", false, false, true));

  /* 21.2.5.7 get RegExp.prototype.multiline */
  multiline := CreateBuiltInFunctionObject([], "getRegExpMultilineAccessorProperty", global, strict, null);
  multiline_desc := newGetAccessorPropertyDescriptorFull(multiline, false, true);
  setJSProperty(regExpPrototypeObject, "multiline", multiline_desc);
  /* length */
  setJSProperty(multiline, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(multiline, "name", newDataPropertyDescriptorFull("get multiline", false, false, true));

  /* 21.2.5.8 RegExp.prototype [ @@replace ] ( string, replaceValue ) */
  replaceFunctionObject := CreateBuiltInFunctionObject(["string", "replaceValue"], "RegExpPrototypereplace", global, strict, null);
  createBuiltInProperty(regExpPrototypeObject, getReplacePropertyName(), replaceFunctionObject);
  /* length */
  setJSProperty(replaceFunctionObject, "length", newDataPropertyDescriptorFull(2., false, false, true));
  /* The value of the name property of this function is "[Symbol.replace]". */
  setJSProperty(replaceFunctionObject, "name", newDataPropertyDescriptorFull("[Symbol.replace]", false, false, true));

  /* 21.2.5.9 RegExp.prototype [ @@search ] ( string ) */
  searchFunctionObject := CreateBuiltInFunctionObject(["string"], "RegExpPrototypesearch", global, strict, null);
  createBuiltInProperty(regExpPrototypeObject, getSearchPropertyName(), searchFunctionObject);
  /* length */
  setJSProperty(searchFunctionObject, "length", newDataPropertyDescriptorFull(1., false, false, true));
  /* The value of the name property of this function is "[Symbol.search]". */
  setJSProperty(searchFunctionObject, "name", newDataPropertyDescriptorFull("[Symbol.search]", false, false, true));

  /* 21.2.5.10 get RegExp.prototype.source */
  source := CreateBuiltInFunctionObject([], "getRegExpSourceAccessorProperty", global, strict, null);
  source_desc := newGetAccessorPropertyDescriptorFull(source, false, true);
  setJSProperty(regExpPrototypeObject, "source", source_desc);
  /* length */
  setJSProperty(source, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(source, "name", newDataPropertyDescriptorFull("get source", false, false, true));

  /* 21.2.5.11 RegExp.prototype [ @@split ] ( string, limit ) */
  splitFunctionObject := CreateBuiltInFunctionObject(["string", "limit"], "RegExpPrototypesplit", global, strict, null);
  createBuiltInProperty(regExpPrototypeObject, getSplitPropertyName(), splitFunctionObject);
  /* The length property of the @@split method is 2. */
  setJSProperty(splitFunctionObject, "length", newDataPropertyDescriptorFull(2., false, false, true));
  /* The value of the name property of this function is "[Symbol.split]". */
  setJSProperty(splitFunctionObject, "name", newDataPropertyDescriptorFull("[Symbol.split]", false, false, true));

  /* 21.2.5.12 get RegExp.prototype.sticky */
  sticky := CreateBuiltInFunctionObject([], "getRegExpStickyAccessorProperty", global, strict, null);
  sticky_desc := newGetAccessorPropertyDescriptorFull(sticky, false, true);
  setJSProperty(regExpPrototypeObject, "sticky", sticky_desc);
  /* length */
  setJSProperty(sticky, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(sticky, "name", newDataPropertyDescriptorFull("get sticky", false, false, true));

  /* 21.2.5.13 RegExp.prototype.test( S ) */
  testFunctionObject := CreateBuiltInFunctionObject(["S"], "RegExpPrototypeTest", global, strict, null);
  createBuiltInProperty(regExpPrototypeObject, "test", testFunctionObject);
  /* length */
  setJSProperty(testFunctionObject, "length", newDataPropertyDescriptorFull(1., false, false, true));
  /* name */
  setJSProperty(testFunctionObject, "name", newDataPropertyDescriptorFull("test", false, false, true));

  /* 21.2.5.14 RegExp.prototype.toString ( ) */
  toStringFunctionObject := CreateBuiltInFunctionObject([], "RegExpPrototypetoString", global, strict, null);
  createBuiltInProperty(regExpPrototypeObject, "toString", toStringFunctionObject);
  /* length */
  setJSProperty(toStringFunctionObject, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(toStringFunctionObject, "name", newDataPropertyDescriptorFull("toString", false, false, true));

  /* 21.2.5.15 get RegExp.prototype.unicode */
  unicode := CreateBuiltInFunctionObject([], "getRegExpUnicodeAccessorProperty", global, strict, null);
  unicode_desc := newGetAccessorPropertyDescriptorFull(unicode, false, true);
  setJSProperty(regExpPrototypeObject, "unicode", unicode_desc);
  /* length */
  setJSProperty(unicode, "length", newDataPropertyDescriptorFull(0., false, false, true));
  /* name */
  setJSProperty(unicode, "name", newDataPropertyDescriptorFull("get unicode", false, false, true));

  /* 21.2.6.1 lastIndex */
  /**
  * The value of the lastIndex property specifies the String index at which to start the next match.
  * It is coerced to an integer when used (see 21.2.5.2.2). This property shall have the attributes
  * { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.
  */
  /*
  setJSProperty(regExpPrototypeObject, "lastIndex", newDataPropertyDescriptorFull(0., true, false, false));
  */
  return regExpPrototypeObject;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.1 Patterns */

/**
* The RegExp constructor applies the following grammar to the input pattern String.
* An error occurs if the grammar cannot interpret the String as an expansion of Pattern.
*/

/* 21.2.1.1 Static Semantics: Early Errors */

/**
* RegExpUnicodeEscapeSequence :: u{ HexDigits }
* It is a Syntax Error if the MV of HexDigits > 1114111.
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.2 Pattern Semantics */

/**
* This sub-section is not in this file (for now). Using the ES5 version
* ("ES6_interpreter/section 15/section_15.10.esl").
* If there are any differences between the ES5 and ES6 standards, they will be highlighted as such,
* and they will also be in the ES5 version file.
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.3 The RegExp Constructor */

/**
* The RegExp constructor is the %RegExp% intrinsic object and the initial value of the RegExp property of
* the global object. When RegExp is called as a function rather than as a constructor, it creates and
* initializes a new RegExp object. Thus the function call RegExp(...) is equivalent to the object creation
* expression new RegExp(...) with the same arguments.
*
* The RegExp constructor is designed to be subclassable. It may be used as the value of an extends clause
* of a class definition. Subclass constructors that intend to inherit the specified RegExp behaviour must
* include a super call to the RegExp constructor to create and initialize subclass instances with the necessary
* internal slots.
*/

function RegExpConstructorAsFunction(externalScope, this, NewTarget, strict, args) {
  return RegExpConstructor(externalScope, null, null, args, NewTarget);
}
/* 21.2.3.1 RegExp ( pattern, flags ) */
/**
* NOTE If pattern is supplied using a StringLiteral, the usual escape sequence substitutions are performed
* before the String is processed by RegExp. If pattern must contain an escape sequence to be recognized by
* RegExp, any U+005C (REVERSE SOLIDUS) code points must be escaped within the StringLiteral to prevent them
* being removed when the contents of the StringLiteral are formed.
*/
function RegExpConstructor(externalScope, ref, F, args, NewTarget) {
  n_args := l_len(args);
  if (n_args >= 1)
    pattern := l_nth(args, 0);
  else
    pattern := 'undefined;
  if (n_args >= 2)
    flags := l_nth(args, 1);
  else
    flags := 'undefined;
  /* 1. Let patternIsRegExp be IsRegExp(pattern). */
  patternIsRegExp := IsRegExp(pattern);
  /* 2. ReturnIfAbrupt(patternIsRegExp). */
  @ReturnIfAbrupt(patternIsRegExp);
  /* 3. If NewTarget is not undefined, let newTarget be NewTarget. */
  if (NewTarget != 'undefined) {
    newTarget := NewTarget;
  } else {
  /* 4. Else, */
    /* a. Let newTarget be the active function object. */
    newTarget := 'undefined;
    /* b. If patternIsRegExp is true and flags is undefined, then */
    if ((patternIsRegExp) &&& (flags == 'undefined)) {
      /* i. Let patternConstructor be Get(pattern, "constructor"). */
      patternConstructor := Get(pattern, "constructor");
      /* ii. ReturnIfAbrupt(patternConstructor). */
      @ReturnIfAbrupt(patternConstructor);
      /* iii. If SameValue(newTarget, patternConstructor) is true, return pattern. */
      if (SameValue(newTarget, patternConstructor))
        return pattern;
    }
  }

  /* 5. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then */
  if ((Type(pattern) == "Object") &&& ("Match" in_obj pattern)) {
    /* a. Let P be the value of pattern’s [[OriginalSource]] internal slot. */
    P := pattern.OriginalSource;
    /* b. If flags is undefined, let F be the value of pattern’s [[OriginalFlags]] internal slot. */
    if (flags == 'undefined)
      F := pattern.OriginalFlags.flags;
    /* c. Else, let F be flags. */
    else
        F := flags;
  }
  /* 6. Else if patternIsRegExp is true, then */
  else if (patternIsRegExp) {
    /* a. Let P be Get(pattern, "source"). */
    P := Get(pattern, "source");
    /* b. ReturnIfAbrupt(P). */
    @ReturnIfAbrupt(P);
    /* c. If flags is undefined, then */
    if (flags == 'undefined) {
      /* i. Let F be Get(pattern, "flags"). */
      F := Get(pattern, "flags");
      /* ii. ReturnIfAbrupt(F). */
      @ReturnIfAbrupt(F);
    /* d. Else, let F be flags. */
    } else {
      F := flags;
    }
  /* 7. Else, */
  } else {
    /* a. Let P be pattern. */
    P := pattern;
    /* b. Let F be flags. */
    F := flags;
  }
  /* 8. Let O be RegExpAlloc(newTarget). */
  O := RegExpAlloc(newTarget);
  /* 9. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 10. Return RegExpInitialize(O, P, F). */
  return RegExpInitialize(O, P, F);
}


/* 21.2.3.2 Abstract Operations for the RegExp Constructor */

/* 21.2.3.2.1 Runtime Semantics: RegExpAlloc ( newTarget ) */
function RegExpAlloc(newTarget) {
  /* 1. Let obj be OrdinaryCreateFromConstructor(newTarget, "%RegExpPrototype%", «‍[[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]]»). */
  obj := OrdinaryCreateFromConstructorRegExp(false);
  /* 2. ReturnIfAbrupt(obj). */
  @ReturnIfAbrupt(obj);
  /* 3. Let status be DefinePropertyOrThrow(obj, "lastIndex", PropertyDescriptor {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}). */
  status := DefinePropertyOrThrow(obj, "lastIndex", newDataPropertyDescriptorFull(0., true, false, false));
  /* 4. Assert: status is not an abrupt completion. */
  assert (!(isAnAbruptCompletion(status)));
  /* 5. Return obj. */
  return obj;
}

/* AUXILIARY FUNCTIONS */
function getRegExpPrototype(strict) {
  return |Intrinsics|["RegExpPrototype"];
}

function OrdinaryCreateFromConstructorRegExp(strict) {
  RegExpPrototype := getRegExpPrototype(strict);

  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfOrdinaryObject(newlyConstructedObject);

  setInternalProperty(newlyConstructedObject, "Prototype", RegExpPrototype);
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  setInternalProperty(newlyConstructedObject, "Class", "RegExp");

  return newlyConstructedObject;
}

/* 21.2.3.2.2 Runtime Semantics: RegExpInitialize (obj, pattern, flags ) */
function RegExpInitialize(obj, pattern, flags) {
  /* 1. If pattern is undefined, let P be the empty String. */
  if (pattern == 'undefined)
    P := "";
  /* 2. Else, let P be ToString(pattern). */
  else
    P := ToString(pattern);
  /* 3. ReturnIfAbrupt(P). */
  @ReturnIfAbrupt(P);
  /* 4. If flags is undefined, let F be the empty String. */
  if (flags == 'undefined)
    F := "";
  /* 5. Else, let F be ToString(flags). */
  else
    F := ToString(flags);
  /* 6. ReturnIfAbrupt(F). */
  @ReturnIfAbrupt(F);
  /* 7. If F contains any code unit other than "g", "i", "m", "u", or "y" or if it contains the same code unit more than once, throw a SyntaxError exception. */
  setFlags(obj, F);
  /* 8. If F contains "u", let BMP be false; else let BMP be true. */
  if (includes(F, "u", 0., 1., int_to_float(s_len_u (F))) == true) BMP := false; else BMP := true;

  /* 9. If BMP is true, then */
    /* a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP code point.
        UTF-16 decoding is not applied to the elements. The goal symbol for the parse is Pattern. Throw a SyntaxError exception
        if P did not conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error
        conditions exist. */
    /* b. Let patternCharacters be a List whose elements are the code unit elements of P. */
  /* 10. Else */
    /* a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points (6.1.4). The goal symbol for the parse is Pattern[U]. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error conditions exist. */
    /* b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16 decoding to P’s sequence of elements. */

  /* 11. Set the value of obj’s [[OriginalSource]] internal slot to P. */

  /* 12. Set the value of obj’s [[OriginalFlags]] internal slot to F. */

  /* 13. Set obj’s [[RegExpMatcher]] internal slot to the internal procedure that evaluates the above parse of P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern’s List of SourceCharacter values and F as the flag parameters. */
  /* 14. Let setStatus be Set(obj, "lastIndex", 0, true). */
  /* 15. ReturnIfAbrupt(setStatus). */
  /* 16. Return obj. */

  /* TEMPORARY */
  return parsePattern(P, F);
}

/* 21.2.3.2.3 Runtime Semantics: RegExpCreate ( P, F ) */
function RegExpCreate(P, F) {
  /* 1. Let obj be RegExpAlloc(%RegExp%). */
  obj := RegExpAlloc("RegExp");

  /* 2. ReturnIfAbrupt(obj). */
  @ReturnIfAbrupt(obj);

  /* 3. Return RegExpInitialize(obj, P, F). */
  return RegExpInitialize(obj, P, F);
}
/* 21.2.3.2.4 Runtime Semantics: EscapeRegExpPattern ( P, F ) */
function EscapeRegExpPattern(P, F) {
  /* 1. Let S be a String in the form of a Pattern (Pattern[U] if F contains "u") equivalent to P
  interpreted as UTF-16 encoded Unicode code points (6.1.4), in which certain code points are
  escaped as described below. S may or may not be identical to P; however, the internal procedure
  that would result from evaluating S as a Pattern (Pattern[U] if F contains "u") must behave
  identically to the internal procedure given by the constructed object's [[RegExpMatcher]]
  internal slot. Multiple calls to this abstract operation using the same values for P and F must
  produce identical results. */

  /* 2. The code points / or any LineTerminator occurring in the pattern shall be escaped in S
  as necessary to ensure that the String value formed by concatenating the Strings "/", S, "/",
  and F can be parsed (in an appropriate lexical context) as a RegularExpressionLiteral that
  behaves identically to the constructed regular expression. For example, if P is "/", then S
  could be "\/" or "\u002F", among other possibilities, but not "/", because /// followed by F
  would be parsed as a SingleLineComment rather than a RegularExpressionLiteral. If P is the
  empty String, this specification can be met by letting S be "(?:)". */

  /* 3. Return S. */

  return parsePattern(P, F);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.4 Properties of the RegExp Constructor */

/**
* The value of the [[Prototype]] internal slot of the RegExp constructor is the intrinsic object
* %FunctionPrototype% (19.2.3).
* Besides the length property (whose value is 2), the RegExp constructor has the following properties:
*/
/* 21.2.4.1 RegExp.prototype */
/**
* The initial value of RegExp.prototype is the intrinsic object %RegExpPrototype% (21.2.5). This property
* has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.
*/

/* 21.2.4.2 get RegExp [ @@species ] */
/**
* RegExp[@@species] is an accessor property whose set accessor function is undefined. Its get accessor
* function performs the following steps:
*
* The value of the name property of this function is "get [Symbol.species]".
* NOTE RegExp prototype methods normally use their this object’s constructor to create a derived object.
* However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.
*/
function getRegExpSpecies(global, this, NewTarget, strict, args) {
  /* 1. Return the this value. */
  return this;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.5 Properties of the RegExp Prototype Object */
/**
* The RegExp prototype object is the intrinsic object %RegExpPrototype%. The RegExp prototype object is an
* ordinary object. It is not a RegExp instance and does not have a [[RegExpMatcher]] internal slot or any
* of the other internal slots of RegExp instance objects.
*
* The value of the [[Prototype]] internal slot of the RegExp prototype object is the intrinsic object
* %ObjectPrototype% (19.1.3).
*
* NOTE The RegExp prototype object does not have a valueOf property of its own; however, it inherits the
* valueOf property from the Object prototype object.
*/

/* 21.2.5.1 RegExp.prototype.constructor */
/**
* The initial value of RegExp.prototype.constructor is the intrinsic object %RegExp%. 21.2.5.2
* RegExp.prototype.exec ( string )
*/

/* 21.2.5.2 RegExp.prototype.exec ( string ) */
/**
* Performs a regular expression match of string against the regular expression and returns an Array object
* containing the results of the match, or null if string did not match.
*/
function RegExpPrototypeexec(global, this, NewTarget, strict, args) {
  str := l_nth(args, 0);
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception. */
  if (!("Match" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 4. Let S be ToString(string). */
  S := ToString(str);
  /* 5. ReturnIfAbrupt(S). */
  @ReturnIfAbrupt(S);
  /* 6. Return RegExpBuiltinExec(R, S). */
  return RegExpBuiltinExec(R, S);
}

/* 21.2.5.2.1 Runtime Semantics: RegExpExec ( R, S ) */
/**
* NOTE If a callable exec property is not found this algorithm falls back to attempting to use the built-in
* RegExp matching algorithm. This provides compatible behaviour for code written for prior editions where
* most built-in algorithms that use regular expressions did not perform a dynamic property lookup of exec.
*/
function RegExpExec(R, S) {
  /* 1. Assert: Type(R) is Object. */
  assert (Type(R) == "Object");
  /* 2. Assert: Type(S) is String. */
  assert (Type(S) == "String");
  /* 3. Let exec be Get(R, "exec"). */
  exec := Get(R, "exec");
  /* 4. ReturnIfAbrupt(exec). */
  @ReturnIfAbrupt(exec);
  /* 5. If IsCallable(exec) is true, then */
  if (IsCallable(exec)) {
    /* a. Let result be Call(exec, R, «S»). */
    result := Call(null, null, exec, R, [S]);
    /* b. ReturnIfAbrupt(result). */
    @ReturnIfAbrupt(result);
    /* c. If Type(result) is neither Object or Null, throw a TypeError exception. */
    if (!((Type(result) == "Object") ||| (Type(result) == "Null")))
      throw TypeErrorConstructorInternal();
    /* d. Return result. */
    return result;
  }
  /* 6. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception. */
  if (!("Match" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 7. Return RegExpBuiltinExec(R, S). */
  return RegExpBuiltinExec(R, S);
}

/* 21.2.5.2.2 Runtime Semantics: RegExpBuiltinExec ( R, S ) */
function RegExpBuiltinExec(R, S) {
  /* 1. Assert: R is an initialized RegExp instance. */
  assert (IsRegExp(R));
  /* 2. Assert: Type(S) is String. */
  assert (Type(S) == "String");
  /* 3. Let length be the number of code units in S. */
  length := int_to_float (s_len_u (S));
  /* 4. Let lastIndex be ToLength(Get(R,"lastIndex")). */
  lastIndex := ToLength(Get(R, "lastIndex"));
  /* 5. ReturnIfAbrupt(lastIndex). */
  @ReturnIfAbrupt(lastIndex);
  /* 6. Let global be ToBoolean(Get(R, "global")). */
  global := ToBoolean(Get(R, "global"));
  /* 7. ReturnIfAbrupt(global). */
  @ReturnIfAbrupt(global);
  /* 8. Let sticky be ToBoolean(Get(R, "sticky")). */
  sticky := ToBoolean(Get(R, "sticky"));
  /* 9. ReturnIfAbrupt(sticky). */
  @ReturnIfAbrupt(sticky);
  /* 10. If global is false and sticky is false, let lastIndex be 0. */
  if ((global == false) &&& (sticky == false))
    lastIndex := 0.;
  /* 11. Let matcher be the value of R’s [[RegExpMatcher]] internal slot. */
  matcher := R.Match;
  /* 12. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
  flags := R.OriginalFlags.flags;
  /* 13. If flags contains "u", let fullUnicode be true, else let fullUnicode be false. */
  fullUnicode := includes(flags, "u", 0., 1., int_to_float(s_len_u (flags)));
  /* 14. Let matchSucceeded be false. */
  matchSucceeded := false;
  /* 15. Repeat, while matchSucceeded is false */
  while (matchSucceeded == false) {
    /* a. If lastIndex > length, then */
    if (lastIndex > length) {
      /* i. Let setStatus be Set(R, "lastIndex", 0, true). */
      setStatus := Set(R, "lastIndex", 0., true);
      /* ii. ReturnIfAbrupt(setStatus). */
      @ReturnIfAbrupt(setStatus);
      /* iii. Return null. */
      return 'null;
    }
    /* b. Let r be matcher(S, lastIndex). */
    r := {R.Match}(R, S, float_to_int lastIndex);
    /* c. If r is failure, then */
    if (isFailure(r)) {
      /* i. If sticky is true, then */
      if (sticky == true) {
        /* 1. Let setStatus be Set(R, "lastIndex", 0, true). */
        setStatus := Set(R, "lastIndex", 0., true);
        /* 2. ReturnIfAbrupt(setStatus). */
        @ReturnIfAbrupt(setStatus);
        /* 3. Return null. */
        return 'null;
      }
      /* ii. Let lastIndex be AdvanceStringIndex(S, lastIndex, fullUnicode). */
      lastIndex := AdvanceStringIndex(S, lastIndex, fullUnicode);
    /* d. Else, */
    } else {
        /* i. Assert: r is a State. */
        /* TODO */
        /* ii. Set matchSucceeded to true. */
        matchSucceeded := true;
    }
  }

  /* 16. Let e be r's endIndex value. */
  e := int_to_float r.endIndex;
  /* 17. If fullUnicode is true, then */
  if (fullUnicode) {
    print "unicode!!!!";
    /* a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S. */
    /* b. Let e be eUTF. */
  }

  /* 18. If global is true or sticky is true, */
  if ((global == true) ||| (sticky == true)) {
    /* a. Let setStatus be Set(R, "lastIndex", e, true). */
    setStatus := Set(R, "lastIndex", e, true);
    /* b. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* setJSProperty(R, "lastIndex", newDataPropertyDescriptorFull(e, true, false, false)) */
  }

  /* 19. Let n be the length of r's captures List. (This is the same value as 21.2.2.1's NcapturingParens.) */
  n := int_to_float r.caps.len;
  /* 20. Let A be ArrayCreate(n + 1). */
  A := ArrayCreate(n + 1., null);
  /* 21. Assert: The value of A’s "length" property is n + 1. */
  A_length := Get(A, "length");
  @ReturnIfAbrupt(A_length);
  assert (A_length == (n + 1.));
  /* 22. Let matchIndex be lastIndex. */
  matchIndex := lastIndex;
  /* 23. Assert: The following CreateDataProperty calls will not result in an abrupt completion. */
  /* ??? */
  /* 24. Perform CreateDataProperty(A, "index", matchIndex). */
  CreateDataProperty(A, "index", matchIndex);
  /* 25. Perform CreateDataProperty(A, "input", S). */
  CreateDataProperty(A, "input", S);
  /* 26. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive). */
  matchedSubstr := substring(S, lastIndex, e);
  /* 27. Perform CreateDataProperty(A, "0", matchedSubstr). */
  CreateDataProperty(A, "0", matchedSubstr);
  /* 28. For each integer i such that i > 0 and i ≤ n */
  i := 1;
  n := r.caps.len;
  while (i <= n) {
    /* a. Let captureI be ith element of r's captures List. */
    i_str := int_to_string i;
    captureI := r.caps[i_str];

    /* b. If captureI is undefined, let capturedValue be undefined. */
    if (captureI == 'undefined) {
      capturedValue := 'undefined;
    /* c. Else if fullUnicode is true, */
    } else if (fullUnicode) {
      print "unicode!!!!";
      capturedValue := captureI;
      /* i. Assert: captureI is a List of code points. */
      /* ii. Let capturedValue be a string whose code units are the UTF16Encoding (10.1.1) of the code points of captureI. */
    /* d. Else, fullUnicode is false, */
    } else {
      /* i. Assert: captureI is a List of code units. */
      /* ii. Let capturedValue be a string consisting of the code units of captureI. */
      capturedValue := captureI;
    }

    /* e. Perform CreateDataProperty(A, ToString(i) , capturedValue). */
    CreateDataProperty(A, ToString(int_to_float i), capturedValue);
    i := i + 1;
  }

  /* 29. Return A. */
  return A;
}

/* 21.2.5.2.3 AdvanceStringIndex ( S, index, unicode ) */
function AdvanceStringIndex(S, index, unicode) {
  /* 1. Assert: Type(S) is String. */
  assert (Type(S) == "String");
  /* 2. Assert: index is an integer such that 0≤index≤253-1. */
  /* assert ((IsInteger(index)) && (index >= 0) && (index <= ((2^53) - 1))); */
  assert (IsInteger(index));
  assert (index >= 0.);
  assert (index <= ((2. ** 53.) - 1.));
  /* 3. Assert: Type(unicode) is Boolean. */
  assert (Type(unicode) == "Boolean");
  /* 4. If unicode is false, return index+1. */
  if (unicode == false)
    return index + 1.;
  /* 5. Let length be the number of code units in S. */
  length := int_to_float (s_len_u (S));
  /* 6. If index+1 ≥ length, return index+1. */
  if (index + 1. >= length)
    return index + 1.;
  /* 7. Let first be the code unit value at index index in S. */
  first := s_nth(S, float_to_int index);
  first := to_char_code(first);
  /* 8. If first < 0xD800 or first > 0xDBFF, return index+1. */
  if ((first < 0xD800) || (first > 0xDBFF))
    return index + 1.;
  /* 9. Let second be the code unit value at index index+1 in S. */
  second := s_nth(S, float_to_int (index + 1.));
  second := to_char_code(second);
  /* 10. If second < 0xDC00 or second > 0xDFFF, return index+1. */
  if ((second < 0xDC00) || (second > 0xDFFF))
    return index + 1.;
  /* 11. Return index+2. */
  return index + 2.;
}

/* 21.2.5.3 get RegExp.prototype.flags */
/**
* RegExp.prototype.flags is an accessor property whose set accessor function is undefined. Its get accessor
* function performs the following steps:
*/
function getRegExpFlagsAccessorProperty(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. Let result be the empty String. */
  result := "";
  /* 4. Let global be ToBoolean(Get(R, "global")). */
  global_ := ToBoolean(Get(R, "global"));
  /* 5. ReturnIfAbrupt(global). */
  @ReturnIfAbrupt(global_);
  /* 6. If global is true, append "g" as the last code unit of result. */
  if (global_)
    result := s_concat([result, "g"]);
  /* 7. Let ignoreCase be ToBoolean(Get(R, "ignoreCase")). */
  ignoreCase := ToBoolean(Get(R, "ignoreCase"));
  /* 8. ReturnIfAbrupt(ignoreCase). */
  @ReturnIfAbrupt(ignoreCase);
  /* 9. If ignoreCase is true, append "i" as the last code unit of result. */
  if (ignoreCase)
    result := s_concat([result, "i"]);
  /* 10. Let multiline be ToBoolean(Get(R, "multiline")). */
  multiline := ToBoolean(Get(R, "multiline"));
  /* 11. ReturnIfAbrupt(multiline). */
  @ReturnIfAbrupt(multiline);
  /* 12. If multiline is true, append "m" as the last code unit of result. */
  if (multiline)
    result := s_concat([result, "m"]);
  /* 13. Let unicode be ToBoolean(Get(R, "unicode")). */
  unicode := ToBoolean(Get(R, "unicode"));
  /* 14. ReturnIfAbrupt(unicode). */
  @ReturnIfAbrupt(unicode);
  /* 15. If unicode is true, append "u" as the last code unit of result. */
  if (unicode)
    result := s_concat([result, "u"]);
  /* 16. Let sticky be ToBoolean(Get(R, "sticky")). */
  sticky := ToBoolean(Get(R, "sticky"));
  /* 17. ReturnIfAbrupt(sticky). */
  @ReturnIfAbrupt(sticky);
  /* 18. If sticky is true, append "y" as the last code unit of result. */
  if (sticky)
    result := s_concat([result, "y"]);
  /* 19. Return result. */
  return result;
}

/* 21.2.5.4 get RegExp.prototype.global */
/**
* RegExp.prototype.global is an accessor property whose set accessor function is undefined. Its get accessor
* function performs the following steps:
*/
function getRegExpGlobalAccessorProperty(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception. */
  if (!("OriginalFlags" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 4. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
  flags := R.OriginalFlags.flags;
  /* 5. If flags contains the code unit "g", return true. */
  /* 6. Return false. */
  return includes(flags, "g", 0., 1., int_to_float(s_len_u (flags)));
}

/* 21.2.5.5 get RegExp.prototype.ignoreCase */
/**
* RegExp.prototype.ignoreCase is an accessor property whose set accessor function is undefined. Its get
* accessor function performs the following steps:
*/
function getRegExpIgnoreCaseAccessorProperty(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception. */
  if (!("OriginalFlags" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 4. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
  flags := R.OriginalFlags.flags;
  /* 5. If flags contains the code unit "i", return true. */
  /* 6. Return false. */
  return includes(flags, "i", 0., 1., int_to_float(s_len_u (flags)));
}

/* 21.2.5.6 RegExp.prototype [ @@match ] ( string ) */
/**
* The value of the name property of this function is "[Symbol.match]".
*
* NOTE The @@match property is used by the IsRegExp abstract operation to identify objects that have the basic
* behaviour of regular expressions. The absence of a @@match property or the existence of such a property whose
* value does not Boolean coerce to true indicates that the object is not intended to be used as a regular
* expression object.
*/
function RegExpPrototypematch(global, this, NewTarget, strict, args) {
  str := l_nth(args, 0);
  /* 1. Let rx be the this value. */
  rx := this;
  /* 2. If Type(rx) is not Object, throw a TypeError exception. */
  if (Type(rx) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. Let S be ToString(string) */
  S := ToString(str);
  /* 4. ReturnIfAbrupt(S). */
  @ReturnIfAbrupt(S);
  /* 5. Let global be ToBoolean(Get(rx, "global")). */
  global_ := ToBoolean(Get(rx, "global"));
  /* 6. ReturnIfAbrupt(global). */
  @ReturnIfAbrupt(global_);
  /* 7. If global is false, then */
  if (global_ == false) {
    /* a. Return RegExpExec(rx, S). */
    return RegExpExec(rx, S);
  /* 8. Else global is true, */
  } else {
    /* a. Let fullUnicode be ToBoolean(Get(rx, "unicode")). */
    fullUnicode := ToBoolean(Get(rx, "unicode"));
    /* b. ReturnIfAbrupt(fullUnicode). */
    @ReturnIfAbrupt(fullUnicode);
    /* c. Let setStatus be Set(rx, "lastIndex", 0, true). */
    setStatus := Set(rx, "lastIndex", 0., true);
    /* d. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* e. Let A be ArrayCreate(0). */
    A := ArrayCreate(0., null);
    /* f. Let n be 0. */
    n := 0;
    /* g. Repeat, */
    while (true) {
      /* i. Let result be RegExpExec(rx, S). */
      result := RegExpExec(rx, S);
      /* ii. ReturnIfAbrupt(result). */
      @ReturnIfAbrupt(result);
      /* iii. If result is null, then */
      if (result == 'null) {
        /* 1. If n=0, return null. */
        if (n == 0)
          return 'null;
        /* 2. Else, return A. */
        else
          return A;
      /* iv. Else result is not null, */
      } else {
        /* 1. Let matchStr be ToString(Get(result, "0")). */
        matchStr := ToString(Get(result, "0"));
        /* 2. ReturnIfAbrupt(matchStr). */
        @ReturnIfAbrupt(matchStr);
        /* 3. Let status be CreateDataProperty(A, ToString(n), matchStr). */
        status := CreateDataProperty(A, ToString(int_to_float n), matchStr);
        /* 4. Assert: status is true. */
        /* assert (status == true); */
        /* 5. If matchStr is the empty String, then */
        if (matchStr == "") {
          /* a. Let thisIndex be ToLength(Get(rx, "lastIndex")). */
          thisIndex := ToLength(Get(rx, "lastIndex"));
          /* b. ReturnIfAbrupt(thisIndex). */
          @ReturnIfAbrupt(thisIndex);
          /* c. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode). */
          nextIndex := AdvanceStringIndex(S, thisIndex, fullUnicode);
          /* d. Let setStatus be Set(rx, "lastIndex", nextIndex, true). */
          setStatus := Set(rx, "lastIndex", nextIndex, true);
          /* e. ReturnIfAbrupt(setStatus). */
          @ReturnIfAbrupt(setStatus);
        }
        /* 6. Increment n. */
        n := n + 1;
        }
    }
  }
}

/* 21.2.5.7 get RegExp.prototype.multiline */
/**
* RegExp.prototype.multiline is an accessor property whose set accessor function is undefined. Its get
* accessor function performs the following steps:
*/
function getRegExpMultilineAccessorProperty(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception. */
  if (!("OriginalFlags" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 4. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
  flags := R.OriginalFlags.flags;
  /* 5. If flags contains the code unit "m", return true. */
  /* 6. Return false. */
  return includes(flags, "m", 0., 1., int_to_float(s_len_u (flags)));
}

/* 21.2.5.8 RegExp.prototype [ @@replace ] ( string, replaceValue ) */
/**
* The value of the name property of this function is "[Symbol.replace]".
*/
function RegExpPrototypereplace(global, this, NewTarget, strict, args) {
  str := l_nth(args, 0);
  replaceValue := l_nth(args, 1);
  /* 1. Let rx be the this value. */
  rx := this;
  /* 2. If Type(rx) is not Object, throw a TypeError exception. */
  if (Type(rx) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. Let S be ToString(string). */
  S := ToString(str);
  /* 4. ReturnIfAbrupt(S). */
  @ReturnIfAbrupt(S);
  /* 5. Let lengthS be the number of code unit elements in S. */
  lengthS := s_len_u (S);
  /* 6. Let functionalReplace be IsCallable(replaceValue). */
  functionalReplace := IsCallable(replaceValue);
  /* 7. If functionalReplace is false, then */
  if (functionalReplace == false) {
    /* a. Let replaceValue be ToString(replaceValue). */
    replaceValue := ToString(replaceValue);
    /* b. ReturnIfAbrupt(replaceValue). */
    @ReturnIfAbrupt(replaceValue);
  }
  /* 8. Let global be ToBoolean(Get(rx, "global")). */
  global_ := ToBoolean(Get(rx, "global"));
  /* 9. ReturnIfAbrupt(global). */
  @ReturnIfAbrupt(global_);
  /* 10. If global is true, then */
  if (global_) {
    /* a. Let fullUnicode be ToBoolean(Get(rx, "unicode")). */
    fullUnicode := ToBoolean(Get(rx, "unicode"));
    /* b. ReturnIfAbrupt(fullUnicode). */
    @ReturnIfAbrupt(fullUnicode);
    /* c. Let setStatus be Set(rx, "lastIndex", 0, true). */
    setStatus := Set(rx, "lastIndex", 0., true);
    /* d. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
  }
  /* 11. Let results be a new empty List. */
  results := [];
  /* 12. Let done be false. */
  done := false;
  /* 13. Repeat, while done is false */
  while (done == false) {
    /* a. Let result be RegExpExec(rx, S). */
    result := RegExpExec(rx, S);
    /* b. ReturnIfAbrupt(result). */
    @ReturnIfAbrupt(result);
    /* c. If result is null, set done to true. */
    if (result == 'null) {
        done := true;
    /* d. Else result is not null, */
    } else {
      /* i. Append result to the end of results. */
      results := l_concat(results, [result]);
      /* ii. If global is false, set done to true. */
      if (global_ == false) {
        done := true;
      /* iii. Else, */
      } else {
        /* 1. Let matchStr be ToString(Get(result, "0")). */
        matchStr := ToString(Get(result, "0"));
        /* 2. ReturnIfAbrupt(matchStr). */
        @ReturnIfAbrupt(matchStr);
        /* 3. If matchStr is the empty String, then */
        if (matchStr == "") {
          /* a. Let thisIndex be ToLength(Get(rx, "lastIndex")). */
          /* thisIndex := ToLength(Get(rx, "lastIndex")); */
          thisIndex := ToLength(Get(rx, "lastIndex"));
          /* b. ReturnIfAbrupt(thisIndex). */
          @ReturnIfAbrupt(thisIndex);
          /* c. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode). */
          nextIndex := AdvanceStringIndex(S, thisIndex, fullUnicode);
          /* d. Let setStatus be Set(rx, "lastIndex", nextIndex, true). */
          setStatus := Set(rx, "lastIndex", nextIndex, true);
          /* e. ReturnIfAbrupt(setStatus). */
          @ReturnIfAbrupt(setStatus);
        }
      }
    }
  }

  /* 14. Let accumulatedResult be the empty String value. */
  accumulatedResult := "";
  /* 15. Let nextSourcePosition be 0. */
  nextSourcePosition := 0;
  /* 16. Repeat, for each result in results, */
  i := 0;
  len := l_len(results);
  while (i < len) {
    result := l_nth(results, i);
    /* a. Let nCaptures be ToLength(Get(result, "length")). */
    nCaptures := ToLength(Get(result, "length"));
    /* b. ReturnIfAbrupt(nCaptures). */
    @ReturnIfAbrupt(nCaptures);
    /* c. Let nCaptures be max(nCaptures − 1, 0). */
    nCaptures := float_to_int(max(nCaptures - 1., 0.));
    /* d. Let matched be ToString(Get(result, "0")). */
    matched := ToString(Get(result, "0"));
    /* e. ReturnIfAbrupt(matched). */
    @ReturnIfAbrupt(matched);
    /* f. Let matchLength be the number of code units in matched. */
    matchLength := s_len_u (matched);
    /* g. Let position be ToInteger(Get(result, "index")). */
    position := ToInteger(Get(result, "index"));
    /* h. ReturnIfAbrupt(position). */
    @ReturnIfAbrupt(position);
    /* i. Let position be max(min(position, lengthS), 0). */
    position := float_to_int(max(min(position, int_to_float lengthS), 0.));
    /* j. Let n be 1. */
    n := 1;
    /* k. Let captures be an empty List. */
    captures := [];
    /* l. Repeat while n ≤ nCaptures */
    while (n <= nCaptures) {
      /* i. Let capN be Get(result, ToString(n)). */
      capN := Get(result, ToString(int_to_float n));
      /* ii. ReturnIfAbrupt(capN). */
      @ReturnIfAbrupt(capN);
      /* iii. If capN is not undefined, then */
      if (capN != 'undefined) {
        /* 1. Let capN be ToString(capN). */
        capN := ToString(capN);
        /* 2. ReturnIfAbrupt(capN). */
        @ReturnIfAbrupt(capN);
      }
      /* iv. Append capN as the last element of captures. */
      captures := l_add(captures, capN);
      /* v. Let n be n+1 */
      n := n + 1;
    }

    /* m. If functionalReplace is true, then */
    if (functionalReplace == true) {
      /* i. Let replacerArgs be «matched». */
      replacerArgs := [matched];
      /* ii. Append in list order the elements of captures to the end of the List replacerArgs. */
      replacerArgs := l_concat(replacerArgs, captures);
      /* iii. Append position and S as the last two elements of replacerArgs. */
      replacerArgs := l_concat(replacerArgs, [int_to_float position, S]);
      /* iv. Let replValue be Call(replaceValue, undefined, replacerArgs). */
      replValue := Call(null, null, replaceValue, 'undefined, replacerArgs);
      /* v. Let replacement be ToString(replValue). */
      replacement := ToString(replValue);
    /* n. Else, */
    } else {
      /* i. Let replacement be GetSubstitution(matched, S, position, captures, replaceValue). */
      replacement := GetSubstitution(matched, S, int_to_float position, captures, replaceValue, global, strict);
    }

    /* o. ReturnIfAbrupt(replacement). */
    @ReturnIfAbrupt(replacement);

    /* p. If position ≥ nextSourcePosition, then */
    if (position >= nextSourcePosition) {
        /* i. NOTE position should not normally move backwards. If it does, it is an indication of an ill-behaving
        RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx.
        In such cases, the corresponding substitution is ignored. */

        /* ii. Let accumulatedResult be the String formed by concatenating the code units of the current value of
        accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to
        position (exclusive) and with the code units of replacement. */

        substring := substring(S, int_to_float nextSourcePosition, int_to_float position);
        accumulatedResult := s_concat([accumulatedResult, substring]);
        accumulatedResult := s_concat([accumulatedResult, replacement]);

        /* iii. Let nextSourcePosition be position + matchLength. */
        nextSourcePosition := position + matchLength;
    }

    i := i + 1;
  }

  /* 17. If nextSourcePosition ≥ lengthS, return accumulatedResult. */
  if (nextSourcePosition >= lengthS)
    return accumulatedResult;

  /* 18. Return the String formed by concatenating the code units of accumulatedResult with the substring of S
  consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive). */
  substring := substring(S, int_to_float nextSourcePosition, int_to_float(s_len_u (S)));
  accumulatedResult := s_concat([accumulatedResult, substring]);
  return accumulatedResult;
}

/* 21.2.5.9 RegExp.prototype [ @@search ] ( string ) */
/**
* The value of the name property of this function is "[Symbol.search]".
*
* NOTE The lastIndex and global properties of this RegExp object are ignored when performing the search.
* The lastIndex property is left unchanged.
*/
function RegExpPrototypesearch(global, this, NewTarget, strict, args) {
  str := l_nth(args, 0);
  /* 1. Let rx be the this value. */
  rx := this;
  /* 2. If Type(rx) is not Object, throw a TypeError exception. */
  if (Type(rx) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. Let S be ToString(string). */
  S := ToString(str);
  /* 4. ReturnIfAbrupt(S). */
  @ReturnIfAbrupt(S);
  /* 5. Let previousLastIndex be Get(rx, "lastIndex"). */
  previousLastIndex := Get(rx, "lastIndex");
  /* 6. ReturnIfAbrupt(previousLastIndex). */
  @ReturnIfAbrupt(previousLastIndex);
  /* 7. Let status be Set(rx, "lastIndex", 0, true). */
  status := Set(rx, "lastIndex", 0., true);
  /* 8. ReturnIfAbrupt(status). */
  @ReturnIfAbrupt(status);
  /* 9. Let result be RegExpExec(rx, S). */
  result := RegExpExec(rx, S);
  /* 10. ReturnIfAbrupt(result). */
  @ReturnIfAbrupt(result);
  /* 11. Let status be Set(rx, "lastIndex", previousLastIndex, true). */
  tatus := Set(rx, "lastIndex", previousLastIndex, true);
  /* 12. ReturnIfAbrupt(status). */
  @ReturnIfAbrupt(status);
  /* 13. If result is null, return –1. */
  if (result == 'null)
    return -(1.);
  /* 14. Return Get(result, "index"). */
  return Get(result, "index");
}

/* 21.2.5.10 get RegExp.prototype.source */
/**
* RegExp.prototype.source is an accessor property whose set accessor function is undefined. Its get accessor
* function performs the following steps:
*/
function getRegExpSourceAccessorProperty(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If R does not have an [[OriginalSource]] internal slot, throw a TypeError exception. */
  if (!("OriginalSource" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 4. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception. */
  if (!("OriginalFlags" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 5. Let src be the value of R’s [[OriginalSource]] internal slot. */
  src := R.OriginalSource;
  /* 6. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
  flags := R.OriginalFlags.flags;
  /* 7. Return EscapeRegExpPattern(src, flags). */
  return EscapeRegExpPattern(src, flags);
}

/* 21.2.5.11 RegExp.prototype [ @@split ] ( string, limit ) */
/**
* NOTE 1 Returns an Array object into which substrings of the result of converting string to a String have been
* stored. The substrings are determined by searching from left to right for matches of the this value regular
* expression; these occurrences are not part of any substring in the returned array, but serve to divide up the
* String value.
* The this value may be an empty regular expression or a regular expression that can match an empty String. In
* this case, regular expression does not match the empty substring at the beginning or end of the input String,
* nor does it match the empty substring at the end of the previous separator match. (For example, if the regular
* expression matches the empty String, the String is split up into individual code unit elements; the length of
* the result array equals the length of the String, and each substring contains one code unit.) Only the first
* match at a given index of the this String is considered, even if backtracking could yield a non-empty-substring
* match at that index. (For example, /a*?/[Symbol.split]("ab") evaluates to the array ["a","b"], while
* /a*\/[Symbol.split]("ab") evaluates to the array["","b"].)
* If the string is (or converts to) the empty String, the result depends on whether the regular expression can
* match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains
* one element, which is the empty String.
* If the regular expression that contains capturing parentheses, then each time separator is matched the results
* (including any undefined results) of the capturing parentheses are spliced into the output array. For example,
  /<(\/)?([^<>]+)>/[Symbol.split]("A<B>bold</B>and<CODE>coded</CODE>")
* evaluates to the array
  ["A",undefined,"B","bold","/","B","and",undefined,"CODE","coded","/","CODE",""]
* If limit is not undefined, then the output array is truncated so that it contains no more than limit elements.
*
* The length property of the @@split method is 2.
* The value of the name property of this function is "[Symbol.split]".
*
* NOTE 2 The @@split method ignores the value of the global and sticky properties of this RegExp object.
*/
function RegExpPrototypesplit(global, this, NewTarget, strict, args) {
  str := l_nth(args, 0);
  limit := l_nth(args, 1);
  /* 1. Let rx be the this value. */
  rx := this;
  l := Type(rx);
  /* 2. If Type(rx) is not Object, throw a TypeError exception. */
  if (Type(rx) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. Let S be ToString(string). */
  S := ToString(str);
  /* 4. ReturnIfAbrupt(S). */
  @ReturnIfAbrupt(S);
  /* 5. Let C be SpeciesConstructor(rx, %RegExp%). */
  C := SpeciesConstructor(rx, |Intrinsics|["RegExp"]);
  /* 6. ReturnIfAbrupt(C). */
  @ReturnIfAbrupt(C);
  /* 7. Let flags be ToString(Get(rx, "flags")). */
  flags := ToString(Get(rx, "flags"));
  /* 8. ReturnIfAbrupt(flags). */
  @ReturnIfAbrupt(flags);
  /* 9. If flags contains "u", let unicodeMatching be true. */
  contains := includes(flags, "u", 0., 1., int_to_float(s_len_u(flags)));
  if (contains)
    unicodeMatching := true;
  /* 10. Else, let unicodeMatching be false. */
  else
    unicodeMatching := false;
  /* 11. If flags contains "y", let newFlags be flags. */
  contains := includes(flags, "y", 0., 1., int_to_float(s_len_u(flags)));
  if (contains)
    newFlags := flags;
  /* 12. Else, let newFlags be the string that is the concatenation of flags and "y". */
  else
    newFlags := s_concat([flags, "y"]);
  /* 13. Let splitter be Construct(C, «rx, newFlags»). */
  splitter := Construct(null, null, C, [rx, newFlags], null);
  /* 14. ReturnIfAbrupt(splitter). */
  @ReturnIfAbrupt(splitter);
  /* 15. Let A be ArrayCreate(0). */
  A := ArrayCreate(0., null);
  /* 16. Let lengthA be 0. */
  lengthA := 0.;
  /* 17. If limit is undefined, let lim be 253–1; else let lim be ToLength(limit). */
  if (limit == 'undefined) lim := (2. ** 53.) - 1.0; else lim := ToLength(limit);
  /* 18. ReturnIfAbrupt(lim). */
  @ReturnIfAbrupt(lim);
  /* 19. Let size be the number of elements in S. */
  size := int_to_float (s_len_u (S));
  /* 20. Let p be 0. */
  p := 0.;
  /* 21. If lim == 0, return A. */
  if (lim == 0.)
    return A;
  /* 22. If size == 0, then */
  if (size == 0.) {
    /* a. Let z be RegExpExec(splitter, S). */
    z := RegExpExec(splitter, S);
    /* b. ReturnIfAbrupt(z). */
    @ReturnIfAbrupt(z);
    /* c. If z is not null, return A. */
    if (z != 'null &&& z != null)
      return A;
    /* d. Assert: The following call will never result in an abrupt completion. */
    /* ???? */
    /* e. Perform CreateDataProperty(A, "0", S). */
    CreateDataProperty(A, "0", S);
    /* f. Return A. */
    return A;
  }
  /* 23. Let q be p. */
  q := p;
  /* 24. Repeat, while q < size */
  while (q < size) {
    /* a. Let setStatus be Set(splitter, "lastIndex", q, true). */
    setStatus := Set(splitter, "lastIndex", q, true);
    /* b. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* c. Let z be RegExpExec(splitter, S). */
    z := RegExpExec(splitter, S);
    /* d. ReturnIfAbrupt(z). */
    @ReturnIfAbrupt(z);
    /* e. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching). */
    if ((z == 'null) || (z == null)) {
      q := AdvanceStringIndex(S, q, unicodeMatching);
    /* f. Else z is not null, */
    } else {
      /* i. Let e be ToLength(Get(splitter, "lastIndex")). */
      e := ToLength(Get(splitter, "lastIndex"));
      /* ii. ReturnIfAbrupt(e). */
      @ReturnIfAbrupt(e);
      /* iii. If e == p, let q be AdvanceStringIndex(S, q, unicodeMatching). */
      if (e == p) {
        q := AdvanceStringIndex(S, q, unicodeMatching);
      /* iv. Else e  p, */
      } else {
        /* 1. Let T be a String value equal to the substring of S consisting of the elements at indices p
        (inclusive) through q (exclusive). */
        T := substring(S, p, q);
        /* 2. Assert: The following call will never result in an abrupt completion. */
        /* ???? */
        /* 3. Perform CreateDataProperty(A, ToString(lengthA), T). */
        CreateDataProperty(A, ToString(lengthA), T);
        /* 4. Let lengthA be lengthA +1. */
        lengthA := lengthA + 1.;
        /* 5. If lengthA == lim, return A. */
        if (lengthA == lim)
          return A;
        /* 6. Let p be e. */
        p := e;
        /* 7. Let numberOfCaptures be ToLength(Get(z, "length")). */
        numberOfCaptures := ToLength(Get(z, "length"));
        /* 8. ReturnIfAbrupt(numberOfCaptures). */
        @ReturnIfAbrupt(numberOfCaptures);
        /* 9. Let numberOfCaptures be max(numberOfCaptures-1, 0). */
        numberOfCaptures := max(numberOfCaptures - 1., 0.);
        /* 10. Let i be 1. */
        i := 1.;
        /* 11. Repeat, while i ≤ numberOfCaptures. */
        while (i <= numberOfCaptures) {
          /* a. Let nextCapture be Get(z, ToString(i)). */
          nextCapture := Get(z, ToString(i));
          /* b. ReturnIfAbrupt(nextCapture). */
          @ReturnIfAbrupt(nextCapture);
          /* c. Perform CreateDataProperty(A, ToString(lengthA), nextCapture). */
          CreateDataProperty(A, ToString(lengthA), nextCapture);
          /* d. Let i be i+1. */
          i := i + 1.;
          /* e. Let lengthA be lengthA +1. */
          lengthA := lengthA + 1.;
          /* f. If lengthA == lim, return A. */
          if (lengthA == lim)
            return A;
        }
        /* 12. Let q be p. */
        q := p;
      }
    }
  }

  /* 25. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive). */
  T := substring(S, p, size);
  /* 26. Assert: The following call will never result in an abrupt completion. */
  /* ???? */
  /* 27. Perform CreateDataProperty(A, ToString(lengthA), T ). */
  CreateDataProperty(A, ToString(lengthA), T);
  /* setJSProperty(A, "length", newDataPropertyDescriptorFull(lengthA + 1., true, false, false)); */
  /* 28. Return A. */
  return A;
}

/* 21.2.5.12 get RegExp.prototype.sticky */
/**
* RegExp.prototype.sticky is an accessor property whose set accessor function is undefined. Its get accessor
* function performs the following steps:
*/
function getRegExpStickyAccessorProperty(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception. */
  if (!("OriginalFlags" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 4. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
  flags := R.OriginalFlags.flags;
  /* 5. If flags contains the code unit "y", return true. */
  /* 6. Return false. */
  return includes(flags, "y", 0., 1., int_to_float(s_len_u (flags)));
}

/* 21.2.5.13 RegExp.prototype.test( S ) */
function RegExpPrototypetest(global, this, NewTarget, strict, args) {
  n_args := l_len(args);
  if (n_args >= 1) S := l_nth(args, 0); else S := 'undefined;
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. Let string be ToString(S). */
  str := ToString(S);
  /* 4. ReturnIfAbrupt(string). */
  @ReturnIfAbrupt(str);
  /* 5. Let match be RegExpExec(R, string). */
  match_ := RegExpExec(R, str);
  /* 6. ReturnIfAbrupt(match). */
  @ReturnIfAbrupt(match_);
  /* 7. If match is not null, return true; else return false. */
  if (match_ != null) return true; else return false;
}

/* 21.2.5.14 RegExp.prototype.toString ( ) */
/**
* NOTE The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object
* with the same behaviour as this object.
*/
function RegExpPrototypetoString(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. Let pattern be ToString(Get(R, "source")). */
  pattern := ToString(Get(R, "source"));
  /* 4. ReturnIfAbrupt(pattern). */
  @ReturnIfAbrupt(pattern);
  /* 5. Let flags be ToString(Get(R, "flags")). */
  flags := ToString(Get(R, "flags"));
  /* 6. ReturnIfAbrupt(flags). */
  @ReturnIfAbrupt(flags);
  /* 7. Let result be the String value formed by concatenating "/", pattern, and "/", and flags. */
  result := s_concat(["/", pattern, "/", flags]);
  return result;
}

/* 21.2.5.15 get RegExp.prototype.unicode */
/**
* RegExp.prototype.unicode is an accessor property whose set accessor function is undefined. Its get accessor
* function performs the following steps:
*/
function getRegExpUnicodeAccessorProperty(global, this, NewTarget, strict, args) {
  /* 1. Let R be the this value. */
  R := this;
  /* 2. If Type(R) is not Object, throw a TypeError exception. */
  if (Type(R) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception. */
  if (!("OriginalFlags" in_obj R))
    throw TypeErrorConstructorInternal();
  /* 4. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
  flags := R.OriginalFlags.flags;
  /* 5. If flags contains the code unit "u", return true. */
  /* 6. Return false. */
  return includes(flags, "u", 0., 1., int_to_float(s_len_u (flags)));
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.6 Properties of RegExp Instances */

/**
* RegExp instances are ordinary objects that inherit properties from the RegExp prototype object. RegExp
* instances have internal slots [[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]]. The value of the
* [[RegExpMatcher]] internal slot is an implementation dependent representation of the Pattern of the RegExp object.
*
* NOTE Prior to ECMAScript 2015, RegExp instances were specified as having the own data properties source, global,
* ignoreCase, and multiline. Those properties are now specified as accessor properties of RegExp.prototype.
*
* RegExp instances also have the following property:
*/

/* 21.2.6.1 lastIndex */
/**
* The value of the lastIndex property specifies the String index at which to start the next match. It is coerced
* to an integer when used (see 21.2.5.2.2). This property shall have the attributes { [[Writable]]: true, [[Enumerable]]:
* false, [[Configurable]]: false }.
*/

