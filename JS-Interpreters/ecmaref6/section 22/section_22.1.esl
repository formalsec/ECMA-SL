/**
 * 15.4 Array Objects
 *
 * Array objects give special treatment to a certain class of property names.
 * A property name P (in the form of a String value) is an array index if and
 * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to
 * 2^32 − 1. A property whose property name is an array index is also called
 * an element. Every Array object has a length property whose value is always
 * a nonnegative integer less than 2^32. The value of the length property is
 * numerically greater than the name of every property whose name is an array
 * index; whenever a property of an Array object is created or changed, other
 * properties are adjusted as necessary to maintain this invariant.
 * Specifically, whenever a property is added whose name is an array index,
 * the length property is changed, if necessary, to be one more than the
 * numeric value of that array index; and whenever the length property is
 * changed, every property whose name is an array index whose value is not
 * smaller than the new length is automatically deleted. This constraint
 * applies only to own properties of an Array object and is unaffected by
 * length or array index properties that may be inherited from its prototypes.
 */

/*
  No ES6 mas não no ES5 :
    [NOT FINAL] = not using the section 7/9 functions because they arent implemented yet
    DONE:
    - 22.1.3.3 Array.prototype.copyWithin (target, start [ , end ] ) [NOT FINAL]
    - 22.1.3.4 Array.prototype.entries ( ) [DOESNT WORK WITH "for (let letter of iterator)" ]
    - 22.1.3.6 Array.prototype.fill (value [ , start [ , end ] ] ) [NOT FINAL]
    - 22.1.3.8 Array.prototype.find ( predicate [ , thisArg ] ) [DOESNT WORK WITH => FUNCTIONS] [NOT FINAL]
    - 22.1.3.9 Array.prototype.findIndex ( predicate [ , thisArg ] ) [DOESNT WORK WITH "=>" FUNCTIONS] [NOT FINAL]
    - 22.1.3.13 Array.prototype.keys ( ) [DOESNT WORK WITH "for (let letter of iterator)" ]
    - 22.1.3.29 Array.prototype.values ( ) [DOESNT WORK WITH "for (let letter of iterator)" ]
    - 22.1.3.30 Array.prototype [ @@iterator ] ( )
    - 22.1.5.1 CreateArrayIterator Abstract Operation
    - 22.1.5.2.1 %ArrayIteratorPrototype%.next( )
    - 22.1.2.5 get Array [ @@species ]

    TESTING:
    - 22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] ) [NOT FINAL]
    - 22.1.2.3 Array.of ( ...items ) [NOT FINAL]

    - 22.1.3.1.1 Runtime Semantics: IsConcatSpreadable ( O ) NOT FULLY DONE
    - 22.1.3.24.1 Runtime Semantics: SortCompare( x, y )

    TODO :
    - 22.1.1.1 Array ( )

    - 22.1.3.31 Array.prototype [ @@unscopables ]
    - 22.1.5.2.2 %ArrayIteratorPrototype% [ @@toStringTag ]

  Em ambos os standards :
    [NOT FINAL] = not using the section 7/9 functions because they arent implemented yet
    DONE :
    - 22.1.2.2 Array.isArray ( arg )
    - 22.1.3.1 Array.prototype.concat ( ...arguments )
    - 22.1.3.5 Array.prototype.every ( callbackfn [ , thisArg] ) [NOT FINAL]
    - 22.1.3.7 Array.prototype.filter ( callbackfn [ , thisArg ] )
    - 22.1.3.10 Array.prototype.forEach ( callbackfn [ , thisArg ] ) [NOT FINAL]
    - 22.1.3.11 Array.prototype.indexOf ( searchElement [ , fromIndex ] ) [NOT FINAL]
    - 22.1.3.12 Array.prototype.join (separator) [NOT FINAL]
    - 22.1.3.14 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] ) [NOT FINAL]
    - 22.1.3.15 Array.prototype.map ( callbackfn [ , thisArg ] )
    - 22.1.3.16 Array.prototype.pop ( ) [NOT FINAL]
    - 22.1.3.17 Array.prototype.push ( ...items ) [NOT FINAL]
    - 22.1.3.18 Array.prototype.reduce ( callbackfn [ , initialValue ] ) [NOT FINAL]
    - 22.1.3.19 Array.prototype.reduceRight ( callbackfn [ , initialValue ] ) [NOT FINAL]
    - 22.1.3.20 Array.prototype.reverse ( ) [NOT FINAL]
    - 22.1.3.21 Array.prototype.shift ( ) [NOT FINAL]
    - 22.1.3.23 Array.prototype.some ( callbackfn [ , thisArg ] ) [NOT FINAL]
    - 22.1.3.27 Array.prototype.toString ( ) [NOT FINAL] => MISSING %ObjProto_toString% (19.1.3.6).
    - 22.1.3.28 Array.prototype.unshift ( ...items ) [NOT FINAL]
    - 22.1.3.22 Array.prototype.slice (start, end)
    - 22.1.3.25 Array.prototype.splice (start, deleteCount , ...items )

    TESTING :
    - 22.1.3.26 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] ).

    TODO :
    - 22.1.1.2 Array (len)
    - 22.1.1.3 Array (...items )
    - 22.1.3.24 Array.prototype.sort (comparefn)
*/


/* An object, O, is said to be sparse if the following algorithm returns true: */
function isSparseArray(O) {
  /* 1. Let len be the result of calling the [[Get]] internal method of O with argument "length". */
  len := ToLength( {O.Get}(O, "length", O)  );
  @ReturnIfAbrupt(len);
  /* 2. For each integer i in the range 0≤i<len */
  i := 0.;
  while (i < len) {
    /* a. Let elem be obj.[[GetOwnProperty]](ToString(i)). */
    elem := {O.GetOwnProperty}(O, ToString(i));
    /* b. If elem is undefined, return true. */
    if (elem == 'undefined)
      return true;
  }
  /* 3. Return false. */
  return false;
}


function setAllInternalMethodsOfArray(arr) {
  setAllInternalMethodsOfOrdinaryObject(arr);
  arr.DefineOwnProperty := "ArrayDefineOwnProperty";
  return arr;
}



/**
 * 15.4.4 Properties of the Array Prototype Object
 *
 * The value of the [[Prototype]] internal property of the Array prototype object
 * is the standard built-in Object prototype object (15.2.4).
 *
 * The Array prototype object is itself an array; its [[Class]] is "Array", and it
 * has a length property (whose initial value is +0) and the special [[DefineOwnProperty]]
 * internal method described in 15.4.5.1.
 *
 * In following descriptions of functions that are properties of the Array prototype
 * object, the phrase "this object" refers to the object that is the this value for
 * the invocation of the function. It is permitted for the this to be an
 * object for which the value of the [[Class]] internal property is not "Array".
 *
 * NOTE The Array prototype object does not have a valueOf property of its own; however,
 * it inherits the valueOf property from the standard built-in Object prototype Object.
 */
function initArrayPrototype(global, objectPrototype, strict) {
  prototype := NewECMAScriptObjectFull(objectPrototype, "Array", true);
  setAllInternalMethodsOfArray(prototype);

  setJSProperty(prototype, "length", newDataPropertyDescriptorFull(0., true, false, false));
  setJSProperty(prototype, getIteratorPropertyName(), newDataPropertyDescriptorFull(0., false, true, true));

  /* Add built-in function objects to array's prototype */

  /* 22.1.3.27 Array.prototype.toString ( ) */
  toStringObject := CreateBuiltInFunctionObject([], "arrayToString", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(toStringObject, true, false, true);
  setJSProperty(prototype, "toString", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(toStringObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("toString", false, false, true);
  setJSProperty(toStringObject, "name", descName);

  /* 22.1.3.26 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] ) */
  toLocaleStringObject := CreateBuiltInFunctionObject([], "arrayToLocaleString", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(toLocaleStringObject, true, false, true);
  setJSProperty(prototype, "toLocaleString", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(toLocaleStringObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("toLocaleString", false, false, true);
  setJSProperty(toLocaleStringObject, "name", descName);

  /* 22.1.3.1 Array.prototype.concat ( ...arguments ) */
  /* We pass 0 to the `internalLength` because while `items` is optional, the length of the
     function is 1. We have `items` in the `FormalParameterList` which makes the length of
     the function to be 1, but if we did not have the `internalLength` to be 0, then
     'undefined would be passed to items when no parameter is provided to `concat`, and
     this is not desired for optional parameters. */
  concatObject := CreateBuiltInFunctionObject(["items"], "arrayConcat", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(concatObject, true, false, true);
  setJSProperty(prototype, "concat", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(concatObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("concat", false, false, true);
  setJSProperty(concatObject, "name", descName);

  /* 22.1.3.12 Array.prototype.join (separator) */
  joinObject := CreateBuiltInFunctionObject(["separator"], "arrayJoin", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(joinObject, true, false, true);
  setJSProperty(prototype, "join", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(joinObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("join", false, false, true);
  setJSProperty(joinObject, "name", descName);

  /* 22.1.3.16 Array.prototype.pop ( ) */
  popObject := CreateBuiltInFunctionObject([], "arrayPop", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(popObject, true, false, true);
  setJSProperty(prototype, "pop", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(popObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("pop", false, false, true);
  setJSProperty(popObject, "name", descName);

  /* 22.1.3.17 Array.prototype.push ( ...items ) */
  pushObject := CreateBuiltInFunctionObject(["items"], "arrayPush", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(pushObject, true, false, true);
  setJSProperty(prototype, "push", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(pushObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("push", false, false, true);
  setJSProperty(pushObject, "name", descName);

  /* 22.1.3.20 Array.prototype.reverse ( ) */
  reverseObject := CreateBuiltInFunctionObject([], "arrayReverse", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(reverseObject, true, false, true);
  setJSProperty(prototype, "reverse", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(reverseObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("reverse", false, false, true);
  setJSProperty(reverseObject, "name", descName);

  /* 22.1.3.21 Array.prototype.shift ( ) */
  shiftObject := CreateBuiltInFunctionObject([], "arrayShift", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(shiftObject, true, false, true);
  setJSProperty(prototype, "shift", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(shiftObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("shift", false, false, true);
  setJSProperty(shiftObject, "name", descName);

  /* 22.1.3.22 Array.prototype.slice (start, end) */
  sliceObject := CreateBuiltInFunctionObject(["start", "end"], "arraySlice", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(sliceObject, true, false, true);
  setJSProperty(prototype, "slice", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(2., false, false, true);
  setJSProperty(sliceObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("slice", false, false, true);
  setJSProperty(sliceObject, "name", descName);

  /* 15.4.4.11 Array.prototype.sort (comparefn) */
  sortObject := CreateBuiltInFunctionObject(["comparefn"], "arraySort", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(sortObject, true, false, true);
  setJSProperty(prototype, "sort", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(sortObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("sort", false, false, true);
  setJSProperty(sortObject, "name", descName);

  /* 22.1.3.25 Array.prototype.splice (start, deleteCount , ...items ) */
  spliceObject := CreateBuiltInFunctionObject([], "arraySplice", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(spliceObject, true, false, true);
  setJSProperty(prototype, "splice", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(2., false, false, true);
  setJSProperty(spliceObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("splice", false, false, true);
  setJSProperty(spliceObject, "name", descName);

  /* 22.1.3.28 Array.prototype.unshift ( ...items ) */
  unshiftObject := CreateBuiltInFunctionObject(["items"], "arrayUnshift", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(unshiftObject, true, false, true);
  setJSProperty(prototype, "unshift", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(unshiftObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("unshift", false, false, true);
  setJSProperty(unshiftObject, "name", descName);

  /* 22.1.3.11 Array.prototype.indexOf ( searchElement [ , fromIndex ] ) */
  indexOfObject := CreateBuiltInFunctionObject(["searchElement"], "arrayIndexOf", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(indexOfObject, true, false, true);
  setJSProperty(prototype, "indexOf", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(indexOfObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("indexOf", false, false, true);
  setJSProperty(indexOfObject, "name", descName);

  /* 21.1.3.14 Array.prototype.lastIndexOf ( searchString [ , position ] ) */
  lastIndexOfObject := CreateBuiltInFunctionObject(["searchElement"], "arrayLastIndexOf", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(lastIndexOfObject, true, false, true);
  setJSProperty(prototype, "lastIndexOf", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(lastIndexOfObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("lastIndexOf", false, false, true);
  setJSProperty(lastIndexOfObject, "name", descName);

  /* 22.1.3.5 Array.prototype.every ( callbackfn [ , thisArg] ) */
  everyOfObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayEvery", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(everyOfObject, true, false, true);
  setJSProperty(prototype, "every", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(everyOfObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("every", false, false, true);
  setJSProperty(everyOfObject, "name", descName);

  /* 22.1.3.23 Array.prototype.some ( callbackfn [ , thisArg ] ) */
  someOfObject := CreateBuiltInFunctionObject(["callbackfn"], "arraySome", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(someOfObject, true, false, true);
  setJSProperty(prototype, "some", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(someOfObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("some", false, false, true);
  setJSProperty(someOfObject, "name", descName);

  /* 22.1.3.10 Array.prototype.forEach ( callbackfn [ , thisArg ] ) */
  forEachObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayForEach", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(forEachObject, true, false, true);
  setJSProperty(prototype, "forEach", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(forEachObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("forEach", false, false, true);
  setJSProperty(forEachObject, "name", descName);

  /* 22.1.3.15 Array.prototype.map ( callbackfn [ , thisArg ] ) */
  mapObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayMap", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(mapObject, true, false, true);
  setJSProperty(prototype, "map", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(mapObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("map", false, false, true);
  setJSProperty(mapObject, "name", descName);

  /* 22.1.3.7 Array.prototype.filter ( callbackfn [ , thisArg ] ) */
  filterObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayFilter", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(filterObject, true, false, true);
  setJSProperty(prototype, "filter", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(filterObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("filter", false, false, true);
  setJSProperty(filterObject, "name", descName);

  /* 22.1.3.18 Array.prototype.reduce ( callbackfn [ , initialValue ] ) */
  reduceObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayReduce", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(reduceObject, true, false, true);
  setJSProperty(prototype, "reduce", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(reduceObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("reduce", false, false, true);
  setJSProperty(reduceObject, "name", descName);

  /* 22.1.3.19 Array.prototype.reduceRight ( callbackfn [ , initialValue ] ) */
  reduceRightObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayReduceRight", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(reduceRightObject, true, false, true);
  setJSProperty(prototype, "reduceRight", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(reduceRightObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("reduceRight", false, false, true);
  setJSProperty(reduceRightObject, "name", descName);

  /* 22.1.3.3 Array.prototype.copyWithin (target, start [ , end ] ) */
  copyWithinObject := CreateBuiltInFunctionObject(["target", "start"], "arraycopyWithin", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(copyWithinObject, true, false, true);
  setJSProperty(prototype, "copyWithin", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(2., false, false, true);
  setJSProperty(copyWithinObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("copyWithin", false, false, true);
  setJSProperty(copyWithinObject, "name", descName);

  /* 22.1.3.6 Array.prototype.fill (value [ , start [ , end ] ] ) */
  fillObject := CreateBuiltInFunctionObject(["value"], "arrayFill", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(fillObject, true, false, true);
  setJSProperty(prototype, "fill", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(fillObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("fill", false, false, true);
  setJSProperty(fillObject, "name", descName);

  /* 22.1.3.8 Array.prototype.find ( predicate [ , thisArg ] ) */
  findObject := CreateBuiltInFunctionObject(["predicate"], "arrayFind", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(findObject, true, false, true);
  setJSProperty(prototype, "find", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(findObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("find", false, false, true);
  setJSProperty(findObject, "name", descName);

  /* 22.1.3.9 Array.prototype.findIndex ( predicate [ , thisArg ] ) */
  findIndexObject := CreateBuiltInFunctionObject(["predicate"], "arrayFindIndex", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(findIndexObject, true, false, true);
  setJSProperty(prototype, "findIndex", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(findIndexObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("findIndex", false, false, true);
  setJSProperty(findIndexObject, "name", descName);

  /* 22.1.3.29 Array.prototype.values ( ) */
  valuesObject := CreateBuiltInFunctionObject([], "arrayValues", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(valuesObject, true, false, true);
  setJSProperty(prototype, "values", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(valuesObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("values", false, false, true);
  setJSProperty(valuesObject, "name", descName);

  /* 22.1.3.13 Array.prototype.keys ( ) */
  keysObject := CreateBuiltInFunctionObject([], "arrayKeys", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(keysObject, true, false, true);
  setJSProperty(prototype, "keys", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(keysObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("keys", false, false, true);
  setJSProperty(keysObject, "name", descName);

  /* 22.1.3.4 Array.prototype.entries ( ) */
  entriesObject := CreateBuiltInFunctionObject([], "arrayEntries", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(entriesObject, true, false, true);
  setJSProperty(prototype, "entries", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(entriesObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("entries", false, false, true);
  setJSProperty(entriesObject, "name", descName);

  /* 22.1.3.30 Array.prototype [ @@iterator ] ( ) */
  descriptor := newDataPropertyDescriptorFull(valuesObject, true, false, true);
  setJSProperty(prototype, getIteratorPropertyName(), descriptor);

  /* 22.1.3.31 Array.prototype [ @@unscopables ] */
  unscopablesObject := createUnscopablesObject();
  descriptor := newDataPropertyDescriptorFull(unscopablesObject, false, false, true);
  setJSProperty(prototype, getUnscopablesPropertyName(), descriptor);

  return prototype;
}


function getArrayPrototype(strict) {
  return |Intrinsics|["ArrayPrototype"];
  /*refArray := newPropertyReference(|global|, "Array", strict);
  ArrayObject := GetValue(refArray);
  refArrayProto := newPropertyReference(ArrayObject, "prototype", strict);
  objectArrayProto := GetValue(refArrayProto);
  return objectArrayProto */
}


function initArrayObject(global, objectPrototype, strict) {

  objArrayPrototype := initArrayPrototype(global, objectPrototype, strict);

  /* 22.1.1 The Array Constructor */
  objArrayConstructor := CreateGeneralBuiltInFunction(getFunctionPrototype(strict), ["items"], "ArrayConstructor", global, strict, 0.);
  objArrayConstructorFun := lambda (global, this, NewTarget, strict, args)[objArrayConstructor] {
    return ArrayConstructor(global, this, NewTarget, strict, args, objArrayConstructor);
  };
  objArrayConstructor.ECMAScriptCode := objArrayConstructorFun;

  descriptor := newDataPropertyDescriptorFull(objArrayConstructor, true, false, true);
  setJSProperty(objArrayPrototype, "constructor", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(objArrayConstructor, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("Array", false, false, true);
  setJSProperty(objArrayConstructor, "name", descName);


  /* 22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] ) */
  fromObject := CreateBuiltInFunctionObject(["items"], "arrayFrom", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(fromObject, true, false, true);
  setJSProperty(objArrayConstructor, "from", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(1., false, false, true);
  setJSProperty(fromObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("from", false, false, true);
  setJSProperty(fromObject, "name", descName);


  /* 22.1.2.2 Array.isArray ( arg ) */
  isArrayObject := CreateBuiltInFunctionObject(["arg"], "isArray", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(isArrayObject, true, false, true);
  setJSProperty(objArrayConstructor, "isArray", descriptor);
  /* Name */
  descName := newDataPropertyDescriptorFull("isArray", false, false, true);
  setJSProperty(isArrayObject, "name", descName);


  /* 22.1.2.3 Array.of ( ...items ) */
  ofObject := CreateBuiltInFunctionObject([], "arrayOf", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(ofObject, true, false, true);
  setJSProperty(objArrayConstructor, "of", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(ofObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("of", false, false, true);
  setJSProperty(ofObject, "name", descName);


  /* 22.1.2.5 get Array [@@species] */
  symbolSpeciesObject := CreateBuiltInFunctionObject([], "arraySpeciesGetter", global, strict, null);
  descriptor := newGetAccessorPropertyDescriptorFull(symbolSpeciesObject, false, true);
  setJSProperty(objArrayConstructor, getSpeciesPropertyName(), descriptor);
  setJSProperty(symbolSpeciesObject, "name", newDataPropertyDescriptorFull("get [Symbol.species]", false, false, true));

  descriptor := newDataPropertyDescriptorFull(objArrayPrototype, false, false, false);
  setJSProperty(objArrayConstructor, "prototype", descriptor);

  return objArrayConstructor;
}




/**
 *  22.1.1 The Array Constructor
 *
 *  The Array constructor is the %Array% intrinsic object and the initial value of the Array property of
 *  the global object. When called as a constructor it creates and initializes a new exotic Array object.
 *  When Array is called as a function rather than as a constructor, it also creates and initializes a
 *  new Array object. Thus the function call Array(…) is equivalent to the object creation expression
 *  new Array(…) with the same arguments.
 *
 *  The Array constructor is a single function whose behaviour is overloaded based upon the number
 *  and types of its arguments.
 *
 *  The Array constructor is designed to be subclassable. It may be used as the value of an extends
 *  clause of a class definition. Subclass constructors that intend to inherit the exotic Array
 *  behaviour must include a super call to the Array constructor to initialize subclass instances
 *  that are exotic Array objects. However, most of the Array.prototype methods are generic methods
 *  that are not dependent upon their this value being an exotic Array object.
 *
 *  The length property of the Array constructor function is 1.
 */
function ArrayConstructor(global, this, NewTarget, strict, items, here) {
  n_args := l_len(items);

  if (n_args == 0)
    return ArrayConstructorNoArgs(items, NewTarget, here);
  if (n_args == 1)
    return ArrayConstructorLen(items, NewTarget, here);
  return ArrayConstructorItems(items, NewTarget, here);
}

/**
*  22.1.1.1 Array ( )
*/
function ArrayConstructorNoArgs(args, NewTarget, here) {
  /* 1. Let numberOfArgs be the number of arguments passed to this function call. */
  numberOfArgs := l_len(args);
  /* 2. Assert: numberOfArgs == 0. */
  assert (numberOfArgs == 0);
  /* 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget. */
  if (NewTarget == 'undefined) newTarget := here; else newTarget := NewTarget;
  /* 4. Let proto be GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%"). */
  proto := GetPrototypeFromConstructor(newTarget, "ArrayPrototype");
  /* 5. ReturnIfAbrupt(proto). */
  @ReturnIfAbrupt(proto);
  /* 6. Return ArrayCreate(0, proto). */
  return ArrayCreate(0., proto);
}



/**
*  22.1.1.2 Array (len)
*/
function ArrayConstructorLen(args, NewTarget, here) {
  /* 1. Let numberOfArgs be the number of arguments passed to this function call. */
  numberOfArgs := l_len(args);
  /* 2. Assert: numberOfArgs == 1. */
  assert (numberOfArgs == 1);
  len := l_nth(args, 0);
  /* 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget. */
  if (NewTarget == 'undefined) newTarget := here; else newTarget := NewTarget;
  /* 4. Let proto be GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%"). */
  proto := GetPrototypeFromConstructor(newTarget, "ArrayPrototype");
  /* 5. ReturnIfAbrupt(proto). */
  @ReturnIfAbrupt(proto);
  /* 6. Let array be ArrayCreate(0, proto). */
  array := ArrayCreate(0., proto);
  /* 7. If Type(len) is not Number, then */
  if (Type(len) != "Number") {
    /* a. Let defineStatus be CreateDataProperty(array, "0", len). */
    defineStatus := CreateDataProperty(array, "0", len);
    /* b. Assert: defineStatus is true. */
    assert (defineStatus == true);
    /* c. Let intLen be 1. */
    intLen := 1.;
  /* 8. Else, */
  } else {
    /* a. Let intLen be ToUint32(len). */
    intLen := ToUint32(len);
    /* b. If intLen ≠ len, throw a RangeError exception. */
    if (intLen != len)
      throw RangeErrorConstructorInternal();
  }
  /* 9. Let setStatus be Set(array, "length", intLen, true). */
  setStatus := Set(array, "length", intLen, true);
  /* 10. Assert: setStatus is not an abrupt completion. */
  assert (!((Type(setStatus) == "Completion") &&& (isAnAbruptCompletion(setStatus))));
  /* 11. Return array. */
  return array;
}



/**
*  22.1.1.3 Array (...items )
*/
function ArrayConstructorItems(args, NewTarget, here) {
  /* 1. Let numberOfArgs be the number of arguments passed to this function call. */
  numberOfArgs := l_len(args);
  /* 2. Assert: numberOfArgs ≥ 2. */
  assert (numberOfArgs >= 2);
  numberOfArgs := int_to_float numberOfArgs;
  /* 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget. */
  if (NewTarget == 'undefined) newTarget := here; else newTarget := NewTarget;
  /* 4. Let proto be GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%"). */
  proto := GetPrototypeFromConstructor(newTarget, "ArrayPrototype");
  /* 5. ReturnIfAbrupt(proto). */
  @ReturnIfAbrupt(proto);
  /* 6. Let array be ArrayCreate(numberOfArgs, proto). */
  array := ArrayCreate(numberOfArgs, proto);
  /* 7. ReturnIfAbrupt(array). */
  @ReturnIfAbrupt(array);
  /* 8. Let k be 0. */
  k := 0.;
  /* 9. Let items be a zero-origined List containing the argument items in order. */
  items := args;
  /* 10. Repeat, while k < numberOfArgs */
  while (k < numberOfArgs) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let itemK be items[k]. */
    itemK := l_nth(items, float_to_int k);
    /* c. Let defineStatus be CreateDataProperty(array, Pk, itemK). */
    defineStatus := CreateDataProperty(array, Pk, itemK);
    /* d. Assert: defineStatus is true. */
    assert (defineStatus == true);
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 11. Assert: the value of array’s length property is numberOfArgs. */
  assert (getJSProperty(array, "length").Value == numberOfArgs);
  /* 12. Return array. */
  return array;
}


/*
*  22.1.2 Properties of the Array Constructor
*
*  The value of the [[Prototype]] internal slot of the Array constructor
*  is the intrinsic object %FunctionPrototype% (19.2.3).
*
*  Besides the length property (whose value is 1), the Array constructor
*  has the following properties:
*/

/**
*  22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] )
*
*  The length property of the from method is 1.
*
*  NOTE The from function is an intentionally generic factory method; it does not require that
*  its this value be the Array constructor. Therefore it can be transferred to or inherited by
*  any other constructors that may be called with a single numeric argument.
*
*/
function arrayFrom(global, this, NewTarget, strict, args) {
  /* method is called with argument items and optional arguments mapfn and thisArg */
  items := l_nth(args, 0);
  mapfn := getOptionalParam(args, 1);
  thisArg := getOptionalParam(args, 2);
  if (mapfn == null)
    mapfn := 'undefined;
  /* 1. Let C be the this value. */
  C := this;
  /* 2. If mapfn is undefined, let mapping be false. */
  if ((mapfn == 'undefined)) {
    mapping := false;
  /* 3. else */
  } else {
    /* a. If IsCallable(mapfn) is false, throw a TypeError exception. */
    if (IsCallable(mapfn) == false)
      throw TypeErrorConstructorInternal();
    /* b. If thisArg was supplied, let T be thisArg; else let T be undefined. */
    if (thisArg != null) T := thisArg; else T := 'undefined;
    /* c. Let mapping be true */
    mapping := true;
  }
  /* 4. Let usingIterator be GetMethod(items, @@iterator). */
  usingIterator := GetMethod(items, getIteratorPropertyName());
  /* if ((items == 'null)) {
    throw TypeErrorConstructorInternal()
  } */
  /* 5. ReturnIfAbrupt(usingIterator). */
  @ReturnIfAbrupt(usingIterator);
  /* 6. If usingIterator is not undefined, then */
  if (usingIterator != 'undefined) {
    /* a. If IsConstructor(C) is true, then */
    if (IsConstructor(C))
      /* i. Let A be Construct(C). */
      A := Construct(null, null, C, [], null);
    /* b. Else, */
    else
      /* i. Let A be ArrayCreate(0). */
      A := ArrayCreate(0., null);
    /* c. ReturnIfAbrupt(A). */
    @ReturnIfAbrupt(A);
    /* d. Let iterator be GetIterator(items, usingIterator). */
    iterator := GetIterator(items, usingIterator);
    /* e. ReturnIfAbrupt(iterator). */
    @ReturnIfAbrupt(iterator);
    /* f. Let k be 0. */
    k := 0.;
    /* g. Repeat */
    while (true) {
      /* i. Let Pk be ToString(k). */
      Pk := ToString(k);
      /* ii. Let next be IteratorStep(iterator). */
      next := IteratorStep(iterator);
      /* iii. ReturnIfAbrupt(next). */
      @ReturnIfAbrupt(next);
      /* iv. If next is false, then */
      if (next == false) {
        /* 1. Let setStatus be Set(A, "length", k, true). */
        setStatus := Set(A, "length", k, true);
        /* 2. ReturnIfAbrupt(setStatus). */
        @ReturnIfAbrupt(setStatus);
        /* 3. Return A. */
        return A;
      }
      /* v. Let nextValue be IteratorValue(next). */
      nextValue := IteratorValue(next);
      /* vi. ReturnIfAbrupt(nextValue). */
      @ReturnIfAbrupt(nextValue);
      /* vii. If mapping is true, then */
      if (mapping == true) {
        /* 1. Let mappedValue be Call(mapfn, T, «nextValue, k»). */
        mappedValue := WrappedCall(null, null, mapfn, T, [nextValue, k]);
        /* 2. If mappedValue is an abrupt completion, return IteratorClose(iterator, mappedValue). */
        if ((Type(mappedValue) == "Completion") &&& (isAnAbruptCompletion(mappedValue)))
          return IteratorClose(iterator, mappedValue);
        /* 3. Let mappedValue be mappedValue.[[value]]. */
        mappedValue := getCompletionValue(mappedValue);
      /* viii. Else, let mappedValue be nextValue. */
      } else {
        mappedValue := nextValue;
      }
      /* ix. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue). */
      defineStatus := WrappedCreateDataPropertyOrThrow(A, Pk, mappedValue);
      /* x. If defineStatus is an abrupt completion, return IteratorClose(iterator, defineStatus). */
      if ((Type(defineStatus) == "Completion") &&& (isAnAbruptCompletion(defineStatus)))
        return IteratorClose(iterator, defineStatus);
      /* xi. Increase k by 1. */
      k := k + 1.;
    }
  }
  /* 7. Assert: items is not an Iterable so assume it is an array-like object. */
  assert (!(IsIterable(items)));
  /* 8. Let arrayLike be ToObject(items). */
  arrayLike := ToObject(items);
  /* 9. ReturnIfAbrupt(arrayLike). */
  @ReturnIfAbrupt(arrayLike);
  /* 10. Let len be ToLength(Get(arrayLike, "length")). */
  len := ToLength(Get(arrayLike, "length"));
  /* 11. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 12. If IsConstructor(C) is true, then */
  A := null;
  if (IsConstructor(C)) {
    /* a. Let A be Construct(C, «len»). */
    A := Construct(null, null, C, [len], null);
  /* 13. Else, */
  } else {
    /* a. Let A be ArrayCreate(len). */
    A := ArrayCreate(len, null);
  }
  /* 14. ReturnIfAbrupt(A). */
  @ReturnIfAbrupt(A);
  /* 15. Let k be 0. */
  k := 0.;
  /* 16. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kValue be Get(arrayLike, Pk). */
    kValue := Get(arrayLike, Pk);
    /* c. ReturnIfAbrupt(kValue). */
    @ReturnIfAbrupt(kValue);
    /* d. If mapping is true, then */
    if (mapping == true) {
      /* i. Let mappedValue be Call(mapfn, T, «kValue, k»). */
      mappedValue := Call(null, null, mapfn, T, [kValue, k]);
      /* ii. ReturnIfAbrupt(mappedValue). */
      @ReturnIfAbrupt(mappedValue);
    /* e. Else, let mappedValue be kValue. */
    } else {
      mappedValue := kValue;
    }
    /* f. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue). */
    defineStatus := CreateDataPropertyOrThrow(A, Pk, mappedValue);
    /* g. ReturnIfAbrupt(defineStatus). */
    @ReturnIfAbrupt(defineStatus);
    /* h. Increase k by 1. */
    k := k + 1.;
  }
  /* 17. Let setStatus be Set(A, "length", len, true). */
  setStatus := Set(A, "length", len, true);
  /* 18. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 19. Return A. */
  return A;
}



/**
 * 22.1.2.2 Array.isArray ( arg )
 *
 * The isArray function takes one argument arg, and returns the Boolean
 * value true if the argument is an object whose class internal property
 * is "Array"; otherwise it returns false. The following steps are taken:
 */
function isArray(global, this, NewTarget, strict, args) {
  arg := l_nth(args, 0);
  /* 1. Return IsArray(arg).*/
  return IsArray(arg);
}



/**
*  22.1.2.3 Array.of ( ...items )
*
*  method is called with any number of arguments
*
*  The length property of the of method is 0.
*
*  NOTE 1 The items argument is assumed to be a well-formed rest argument value.
*
*  NOTE 2 The of function is an intentionally generic factory method; it does not
*  require that its this value be the Array constructor. Therefore it can be transferred
*  to or inherited by other constructors that may be called with a single numeric argument.
*
*/
function arrayOf(global, this, NewTarget, strict, args) {
  /* Initialize `A` so typechecker is happy. */
  A := null;
  /* 1. Let len be the actual number of arguments passed to this function. */
  len := l_len(args);
  /* 2. Let items be the List of arguments passed to this function. */
  items := args;
  /* 3. Let C be the this value. */
  C := this;
  /* 4. If IsConstructor(C) is true, then */
  if (IsConstructor(C)) {
    /* a. Let A be Construct(C, «len»). */
    A := Construct(null, null, C, [int_to_float len], null);
  /* 5. Else, */
  } else {
    /* a. Let A be ArrayCreate(len). */
    A := ArrayCreate(int_to_float len, null);
  }
  /* 6. ReturnIfAbrupt(A). */
  @ReturnIfAbrupt(A);
  /* 7. Let k be 0. */
  k := 0;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let kValue be items[k]. */
    kValue := l_nth(items, k);
    /* b. Let Pk be ToString(k). */
    Pk := ToString(int_to_float k);
    /* c. Let defineStatus be CreateDataPropertyOrThrow(A,Pk, kValue). */
    defineStatus := CreateDataPropertyOrThrow(A, Pk, kValue);
    /* d. ReturnIfAbrupt(defineStatus). */
    @ReturnIfAbrupt(defineStatus);
    /* e. Increase k by 1. */
    k := k + 1;
  }
  /* 9. Let setStatus be Set(A, "length", len, true). */
  setStatus := Set(A, "length", int_to_float len, true);
  /* 10. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 11. Return A. */
  return A;
}



/* 22.1.2.5 get Array [@@species] */
function arraySpeciesGetter(global, this, NewTarget, strict, args) {
  return this;
}





/**
*  22.1.3 Properties of the Array Prototype Object
*
*  The Array prototype object is the intrinsic object %ArrayPrototype%.
*  The Array prototype object is an Array exotic objects and has the internal
*  methods specified for such objects. It has a length property whose initial
*  value is 0 and whose attributes are:
*     > { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.
*
*  The value of the [[Prototype]] internal slot of the Array prototype object is
*  the intrinsic object %ObjectPrototype%.
*
*  NOTE The Array prototype object is specified to be an Array exotic object to ensure compatibility
*  with ECMAScript code that was created prior to the ECMAScript 2015 specification.
*/


/**
 * 22.1.3.1 Array.prototype.concat ( ...arguments )
 *
 * When the concat method is called with zero or more arguments item1, item2,
 * etc., it returns an array containing the array elements of the object
 * followed by the array elements of each argument in order.
 *
 * The following steps are taken:
 */
function arrayConcat(global, this, NewTarget, strict, items) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let A be ArraySpeciesCreate(O, 0). */
  A := ArraySpeciesCreate(O, 0.);
  /* 4. ReturnIfAbrupt(A). */
  @ReturnIfAbrupt(A);
  /* 5. Let n be 0. */
  n := 0.;
  /* 6. Let items be a List whose first element is O and whose
        subsequent elements are, in left to right order, the
         arguments that were passed to this function invocation. */
  items := l_prepend(O, items);
  /* 7. Repeat, while items is not empty */
  while (items != []) {
    /* a. Remove the first element from items and let E be the value of the
          element. */
    E := hd items;
    items := tl items;
    /* b. Let spreadable be IsConcatSpreadable(E). */
    spreadable := IsConcatSpreadable(E);
    /* c. ReturnIfAbrupt(spreadable). */
    @ReturnIfAbrupt(spreadable);
    /* d. If spreadable is true, then */
    if (spreadable == true) {
      /* i. Let k be 0. */
      k := 0.;
      /* ii. Let len be ToLength(Get(E, "length")). */
      len := ToLength(Get(E, "length"));
      /* iii. ReturnIfAbrupt(len). */
      @ReturnIfAbrupt(len);
      /* iv. If n + len > 2^53-1, throw a TypeError exception. */
      if ((n + len) > (((2. ** 53.) - 1.)))
        throw TypeErrorConstructorInternal();
      /* v. Repeat, while k < len */
      while (k < len) {
        /* 1. Let P be ToString(k). */
        P := ToString(k);
        /* 2. Let exists be HasProperty(E, P). */
        exists := HasProperty(E, P);
        /* 3. ReturnIfAbrupt(exists). */
        @ReturnIfAbrupt(exists);
        /* 4. If exists is true, then */
        if (exists == true) {
          /* a. Let subElement be Get(E, P). */
          subElement := Get(E, P);
          /* b. ReturnIfAbrupt(subElement). */
          @ReturnIfAbrupt(subElement);
          /* c. Let status be CreateDataPropertyOrThrow (A, ToString(n), subElement). */
          status := CreateDataPropertyOrThrow(A, ToString(n), subElement);
          /* d. ReturnIfAbrupt(status). */
          @ReturnIfAbrupt(status);
        }
        /* 5. Increase n by 1. */
        n := n + 1.;
        /* 6. Increase k by 1. */
        k := k + 1.;
      }
    /* e. Else E is added as a single item rather than spread, */
    } else {
      /* i. If n≥2^53-1, throw a TypeError exception */
      if ((n) >= (((2. ** 53.) - 1.)))
        throw TypeErrorConstructorInternal();
      /* ii. Let status be CreateDataPropertyOrThrow (A, ToString(n), E). */
      status := CreateDataPropertyOrThrow (A, ToString(n), E);
      /* iii. ReturnIfAbrupt(status). */
      @ReturnIfAbrupt(status);
      /* iv. Increase n by 1. */
      n := n + 1.;
    }
  }
  /* 8. Let setStatus be Set(A, "length", n, true). */
  setStatus := Set(A, "length", n, true);
  /* 9. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 10. Return A. */
  return A;
}
/**
 * The length property of the concat method is 1.
 *
 * NOTE The concat function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the concat function
 * can be applied successfully to a host object is implementation-dependent.
 */


/* 22.1.3.1.1 Runtime Semantics: IsConcatSpreadable ( O ) */
function IsConcatSpreadable(O) {
  /* 1. If Type(O) is not Object, return false. */
  if (Type(O) != "Object")
    return false;
  /* 2. Let spreadable be Get(O, @@isConcatSpreadable). */
  spreadable := Get(O, getIsConcatSpreadablePropertyName());
  /* 3. ReturnIfAbrupt(spreadable). */
  @ReturnIfAbrupt(spreadable);
  /* 4. If spreadable is not undefined, return ToBoolean(spreadable). */
  if (spreadable != 'undefined)
    return ToBoolean(spreadable);
  /* 5. Return IsArray(O). */
  return IsArray(O);
}



/**
* 22.1.3.3 Array.prototype.copyWithin (target, start [ , end ] )
*
*  NOTE 1 The end argument is optional with the length of the this object as its default value. If target is negative,
*  it is treated as length+target where length is the length of the array. If start is negative, it is treated as
*  length+start. If end is negative, it is treated as length+end.
*
*  The length property of the copyWithin method is 2.
*
*  NOTE 2 The copyWithin function is intentionally generic; it does not require that its this value be an Array
*  object. Therefore it can be transferred to other kinds of objects for use as a method.
*
*/
function arraycopyWithin(global, this, NewTarget, strict, args) {
  /* The copyWithin method takes up to three arguments target, start and end. */
  target := l_nth(args, 0);
  start := l_nth(args, 1);
  end := getOptionalParam(args, 2);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. Let relativeTarget be ToInteger(target). */
  relativeTarget := ToInteger(target);
  /* 6. ReturnIfAbrupt(relativeTarget). */
  @ReturnIfAbrupt(relativeTarget);
  /* 7. If relativeTarget < 0, let to be max((len + relativeTarget),0); else let to be min(relativeTarget, len). */
  if (relativeTarget < 0.) to := max((len + relativeTarget), 0.); else to := min(relativeTarget, len);
  /* 8. Let relativeStart be ToInteger(start). */
  relativeStart := ToInteger(start);
  /* 9. ReturnIfAbrupt(relativeStart). */
  @ReturnIfAbrupt(relativeStart);
  /* 10. If relativeStart < 0, let from be max((len + relativeStart),0); else let from be min(relativeStart, len). */
  if (relativeStart < 0.) from := max((len + relativeStart), 0.); else from := min(relativeStart, len);
  /* 11. If end is undefined, let relativeEnd be len; else let relativeEnd be ToInteger(end). */
  if ((end == 'undefined) ||| (end == null)) relativeEnd := len; else relativeEnd := ToInteger(end);
  /* 12. ReturnIfAbrupt(relativeEnd). */
  @ReturnIfAbrupt(relativeEnd);
  /* 13. If relativeEnd < 0, let final be max((len + relativeEnd),0); else let final be min(relativeEnd, len). */
  if (relativeEnd < 0.) final := max((len + relativeEnd), 0.); else final := min(relativeEnd, len);
  /* 14. Let count be min(final-from, len-to). */
  count := min(final - from, len - to);
  /* 15. If from<to and to<from+count */
  if ((from < to) &&& (to < (from + count))) {
    /* a. Let direction be -1. */
    direction := -(1.);
    /* b. Let from be from + count -1. */
    from := from + count - 1.;
    /* c. Let to be to + count -1. */
    to := to + count - 1.;
  /* 16. Else, */
  } else {
    /* a. Let n = 1. */
    direction := 1.;
  }
  /* 17. Repeat, while count > 0 */
  while (count > 0.) {
    /* a. Let fromKey be ToString(from). */
    fromKey := ToString(from);
    /* b. Let toKey be ToString(to). */
    toKey := ToString(to);
    /* c. Let fromPresent be HasProperty(O, fromKey). */
    fromPresent := HasProperty(O, fromKey);
    /* d. ReturnIfAbrupt(fromPresent). */
    @ReturnIfAbrupt(fromPresent);
    /* e. If fromPresent is true, then */
    if (fromPresent == true) {
      /* i. Let fromVal be Get(O, fromKey). */
      fromVal := Get(O, fromKey);
      /* ii. ReturnIfAbrupt(fromVal). */
      @ReturnIfAbrupt(fromVal);
      /* iii. Let setStatus be Set(O, toKey, fromVal, true). */
      setStatus := Set(O, toKey, fromVal, true);
      /* iv. ReturnIfAbrupt(setStatus). */
      @ReturnIfAbrupt(setStatus);
    /* f. Else fromPresent is false, */
    } else {
      /* i. Let deleteStatus be DeletePropertyOrThrow(O, toKey). */
      deleteStatus := DeletePropertyOrThrow(O, toKey);
      /* ii. ReturnIfAbrupt(deleteStatus). */
      @ReturnIfAbrupt(deleteStatus);
    }
    /* g. Let from be from + direction. */
    from := from + direction;
    /* h. Let to be to + direction. */
    to := to + direction;
    /* i. Let count be count − 1. */
    count := count - 1.;
  }
  /* 18. Return O. */
  return O;
}



/**
*  22.1.3.4 Array.prototype.entries ( )
*/
function arrayEntries(global, this, NewTarget, strict, args) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Return CreateArrayIterator(O, "key+value"). */
  return CreateArrayIterator(O, "key+value");
}



/**
 * 22.1.3.5 Array.prototype.every ( callbackfn [ , thisArg] )
 *
 * callbackfn should be a function that accepts three arguments and returns
 * a value that is coercible to the Boolean value true or false. every calls
 * callbackfn once for each element present in the array, in ascending order,
 * until it finds one where callbackfn returns false. If such an element is
 * found, every immediately returns false. Otherwise, if callbackfn returned
 * true for all elements, every will return true. callbackfn is called only
 * for elements of the array which actually exist; it is not called for
 * missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value
 * for each invocation of callbackfn. If it is not provided, undefined is
 * used instead.
 *
 * callbackfn is called with three arguments: the value of the element,
 * the index of the element, and the object being traversed.
 *
 * every does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by every is set before the first call
 * to callbackfn. Elements which are appended to the array after the call
 * to every begins will not be visited by callbackfn. If existing elements
 * of the array are changed, their value as passed to callbackfn will be the
 * value at the time every visits them; elements that are deleted after the
 * call to every begins and before being visited are not visited. every acts
 * like the "for all" quantifier in mathematics. In particular, for an empty
 * array, it returns true.
 *
 * When the every method is called with one or two arguments, the following
 * steps are taken:
 */
function arrayEvery(global, this, NewTarget, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (thisArg != null) T := thisArg; else T := 'undefined;
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent). */
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* iii. Let testResult be ToBoolean(Call(callbackfn, T, «kValue, k, O»)). */
      testResult := ToBoolean(Call(null, null, callbackfn, T, [kValue, k, O]));
      /* iv. ReturnIfAbrupt(testResult). */
      @ReturnIfAbrupt(testResult);
      /* v. If testResult is false, return false. */
      if (ToBoolean(testResult) == false)
        return false;
    }
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 9. Return true. */
  return true;
}
/**
 * The length property of the every method is 1.
 *
 * NOTE The every function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the every function
 * can be applied successfully to a host object is implementation-dependent.
 */



 /**
*   22.1.3.6 Array.prototype.fill (value [ , start [ , end ] ] )
*
*  NOTE 1 The start and end arguments are optional with default values of 0 and the length
*  of the this object. If start is negative, it is treated as length+start where length is the
*  length of the array. If end is negative, it is treated as length+end.
*
*  The length property of the fill method is 1.
*
*  NOTE 2 The fill function is intentionally generic; it does not require that its this value be
*  an Array object. Therefore it can be transferred to other kinds of objects for use as a method.
*
*/
function arrayFill(global, this, NewTarget, strict, args) {
  /* The fill method takes up to three arguments value, start and end. */
  value := l_nth(args, 0);
  start := getOptionalParam(args, 1);
  end := getOptionalParam(args, 2);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. Let relativeStart be ToInteger(start). */
  if ((start == 'undefined) ||| (start == null))
    start := 0.;
  relativeStart := ToInteger(start);
  /* 6. ReturnIfAbrupt(relativeStart). */
  @ReturnIfAbrupt(relativeStart);
  /* 7. If relativeStart < 0, let k be max((len + relativeStart),0); else let k be min(relativeStart, len). */
  if (relativeStart < 0.) k := max((len + relativeStart), 0.); else k := min(relativeStart, len);
  /* 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ToInteger(end). */
  if ((end == 'undefined) ||| (end == null)) relativeEnd := len; else relativeEnd := ToInteger(end);
  /* 9. ReturnIfAbrupt(relativeEnd). */
  @ReturnIfAbrupt(relativeEnd);
  /* 10. If relativeEnd < 0, let final be max((len + relativeEnd),0); else let final be min(relativeEnd, len). */
  if (relativeEnd < 0.) final := max((len + relativeEnd), 0.); else final := min(relativeEnd, len);
  /* 11. Repeat, while k < final */
  while (k < final) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let setStatus be Set(O, Pk, value, true). */
    setStatus := Set(O, Pk, value, true);
    /* c. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* d. Increase k by 1. */
    k := k + 1.;
  }

  /* 12. Return O. */
  return O;
}



/**
 *  22.1.3.7 Array.prototype.filter ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments and returns a
 * value that is coercible to the Boolean value true or false. filter calls
 * callbackfn once for each element in the array, in ascending order, and
 * constructs a new array of all the values for which callbackfn returns true.
 * callbackfn is called only for elements of the array which actually exist; it
 * is not called for missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value for
 * each invocation of callbackfn. If it is not provided, undefined is used instead.
 *
 * callbackfn is called with three arguments: the value of the element, the
 * index of the element, and the object being traversed.
 *
 * filter does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by filter is set before the first call to
 * callbackfn. Elements which are appended to the array after the call to filter
 * begins will not be visited by callbackfn. If existing elements of the array
 * are changed their value as passed to callbackfn will be the value at the time
 * filter visits them; elements that are deleted after the call to filter begins
 * and before being visited are not visited.
 *
 * When the filter method is called with one or two arguments, the following
 * steps are taken:
 */

function arrayFilter(global, this, NewTarget, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (thisArg != null) T := thisArg; else T := 'undefined;
  /* 7. Let A be ArraySpeciesCreate(O, 0). */
  A := ArraySpeciesCreate(O, 0.);
  /* 8. ReturnIfAbrupt(A). */
  @ReturnIfAbrupt(A);
  /* 9. Let k be 0. */
  k := 0.;
  /* 10. Let to be 0. */
  to := 0.;
  /* 11. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent). */
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* iii. Let selected be ToBoolean(Call(callbackfn, T, «kValue, k, O»)). */
      selected := ToBoolean(Call(null, null, callbackfn, T, [kValue, k, O]));
      /* iv. ReturnIfAbrupt(selected). */
      @ReturnIfAbrupt(selected);
      /* v. If selected is true, then  */
      if (selected == true) {
        /* 1. Let status be CreateDataPropertyOrThrow (A, ToString(to), kValue). */
        status := CreateDataPropertyOrThrow(A, ToString(to), kValue);
        /* 2. ReturnIfAbrupt(status). */
        @ReturnIfAbrupt(status);
        /* 3. Increase to by 1. */
        to := to + 1.;
      }
    }
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 12. Return A. */
  return A;
}
/**
* The length property of the filter method is 1.
*
* NOTE The filter function is intentionally generic; it does not require that
* its this value be an Array object. Therefore it can be transferred to other
* kinds of objects for use as a method. Whether the filter function can be
* applied successfully to a host object is implementation-dependent.
*/



/**
* 22.1.3.8 Array.prototype.find ( predicate [ , thisArg ] )
*
*  NOTE 1 predicate should be a function that accepts three arguments and returns a value that is
*  coercible to a Boolean value. find calls predicate once for each element of the array, in
*  ascending order, until it finds one where predicate returns true. If such an element is found,
*  find immediately returns that element value. Otherwise, find returns undefined.
*
*  If a thisArg parameter is provided, it will be used as the this value for each invocation
*  of predicate. If it is not provided, undefined is used instead.
*
*  predicate is called with three arguments:
*      - the value of the element
*      - the index of the element
*      - the object being traversed.
*
*  find does not directly mutate the object on which it is called but
*  the object may be mutated by the calls to predicate.
*
*  The range of elements processed by find is set before the first call to callbackfn.
*  Elements that are appended to the array after the call to find begins will not be
*  visited by callbackfn. If existing elements of the array are changed, their value
*  as passed to predicate will be the value at the time that find visits them.
*
*  The length property of the find method is 1.
*
*  NOTE 2 The find function is intentionally generic; it does not require that its this value
*  be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.
*
*/
function arrayFind(global, this, NewTarget, strict, args) {
  /* The find method is called with one or two arguments, predicate and thisArg. */
  predicate := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(predicate) is false, throw a TypeError exception. */
  if (IsCallable(predicate) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (thisArg != null) T := thisArg; else T := 'undefined;
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kValue be Get(O, Pk). */
    kValue := Get(O, Pk);
    /* c. ReturnIfAbrupt(kValue). */
    @ReturnIfAbrupt(kValue);
    /* d. Let testResult be ToBoolean(Call(predicate, T, «kValue, k, O»)). */
    testResult := ToBoolean(Call(null, null, predicate, T, [kValue, k, O]));
    /* e. ReturnIfAbrupt(testResult). */
    @ReturnIfAbrupt(testResult);
    /* f. If testResult is true, return kValue. */
    if (testResult == true)
      return kValue;
    /* g. Increase k by 1. */
    k := k + 1.;
  }
  /* 9. Return undefined. */
  return 'undefined;
}



/**
* 22.1.3.9 Array.prototype.findIndex ( predicate [ , thisArg ] )
-
*  NOTE 1 predicate should be a function that accepts three arguments and returns a value that is
*  coercible to the Boolean value true or false. findIndex calls predicate once for each element
*  of the array, in ascending order, until it finds one where predicate returns true. If such
*  an element is found, findIndex immediately returns the index of that element value. Otherwise,
*  findIndex returns -1.
*
*  If a thisArg parameter is provided, it will be used as the this value for each invocation
*  of predicate. If it is not provided, undefined is used instead.
*
*  predicate is called with three arguments: the value of the element,
*  the index of the element, and the object being traversed.
*
*  findIndex does not directly mutate the object on which it is called but the object
*  may be mutated by the calls to predicate.
*
*  The range of elements processed by findIndex is set before the first call to callbackfn.
*  Elements that are appended to the array after the call to findIndex begins will not be
*  visited by callbackfn. If existing elements of the array are changed, their value as
*  passed to predicate will be the value at the time that findIndex visits them.
*
*  The length property of the findIndex method is 1.
*
*  NOTE 2 The findIndex function is intentionally generic; it does not require that its this
*  value be an Array object. Therefore it can be transferred to other kinds of objects for use
*  as a method.
*
*/
function arrayFindIndex(global, this, NewTarget, strict, args) {
  /* The find method is called with one or two arguments, predicate and thisArg. */
  predicate := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(predicate) is false, throw a TypeError exception. */
  if (IsCallable(predicate) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (thisArg != null) T := thisArg; else T := 'undefined;
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kValue be Get(O, Pk). */
    kValue := Get(O, Pk);
    /* c. ReturnIfAbrupt(kValue). */
    @ReturnIfAbrupt(kValue);
    /* d. Let testResult be ToBoolean(Call(predicate, T, «kValue, k, O»)). */
    testResult := ToBoolean(Call(null, null, predicate, T, [kValue, k, O]));
    /* e. ReturnIfAbrupt(testResult). */
    @ReturnIfAbrupt(testResult);
    /* f. If testResult is true, return kValue. */
    if (testResult == true)
      return k;
    /* g. Increase k by 1. */
    k := k + 1.;
  }
  /* 9. Return -1. */
  return -(1.);
}



/**
 * 22.1.3.10 Array.prototype.forEach ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments. forEach
 * calls callbackfn once for each element present in the array, in ascending
 * order. callbackfn is called only for elements of the array which actually
 * exist; it is not called for missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value for
 * each invocation of callbackfn. If it is not provided, undefined is used
 * instead.
 *
 * callbackfn is called with three arguments: the value of the element,
 * the index of the element, and the object being traversed.
 *
 * forEach does not directly mutate the object on which it is called but
 * the object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by forEach is set before the first
 * call to callbackfn. Elements which are appended to the array after the
 * call to forEach begins will not be visited by callbackfn. If existing
 * elements of the array are changed, their value as passed to callback
 * will be the value at the time forEach visits them; elements that are
 * deleted after the call to forEach begins and before being visited are
 * not visited.
 *
 * When the forEach method is called with one or two arguments, the
 * following steps are taken:
 */
function arrayForEach(global, this, NewTarget, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (thisArg != null) T := thisArg; else T := 'undefined;
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent). */
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* iii. Let funcResult be Call(callbackfn, T, «kValue, k, O»). */
      funcResult := Call(null, null, callbackfn, T, [kValue, k, O]);
      /* iv. ReturnIfAbrupt(funcResult). */
      @ReturnIfAbrupt(funcResult);
    }
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 9. Return undefined. */
  return 'undefined;
}
/**
 * The length property of the forEach method is 1.
 *
 * NOTE The forEach function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the forEach function
 * can be applied successfully to a host object is implementation-dependent.
 */



 /**
 * 22.1.3.11 Array.prototype.indexOf ( searchElement [ , fromIndex ] )
 *
 * indexOf compares searchElement to the elements of the array, in ascending
 * order, using the internal Strict Equality Comparison Algorithm (11.9.6),
 * and if found at one or more positions, returns the index of the first such
 * position; otherwise, -1 is returned.
 *
 * The optional second argument fromIndex defaults to 0 (i.e. the whole array
 * is searched). If it is greater than or equal to the length of the array, -1
 * is returned, i.e. the array will not be searched. If it is negative, it is
 * used as the offset from the end of the array to compute fromIndex. If the
 * computed index is less than 0, the whole array will be searched.
 *
 * When the indexOf method is called with one or two arguments, the following
 * steps are taken:
 */
function arrayIndexOf(global, this, NewTarget, strict, args) {
  searchElement := l_nth(args, 0);
  fromIndex := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len).*/
  @ReturnIfAbrupt(len);
  /* 5. If len is 0, return -1. */
  if (len == 0.)
    return -(1.);
  /* 6. If argument fromIndex was passed let n be ToInteger(fromIndex); else let n be 0. */
  if (fromIndex != null) n := ToInteger(fromIndex); else n := 0.;
  /* 7. ReturnIfAbrupt(n). */
  @ReturnIfAbrupt(n);
  /* 8. If n ≥ len, return -1. */
  if (n >= len)
    return -(1.);
  /* 9. If n ≥ 0, then */
  if (n >= 0.) {
    /* This comparison with -0 was extracted from ES7 standard. Fix bug. */
    /* a. If n is -0, let k be +0; else let k be n. */
    if (isMinusZero(n)) k := 0.; else k := n;
  /* 10. Else, n<0 */
  } else {
    /* a. Let k be len - abs(n). */
    k := len - abs(n);
    /* b. If k is less than 0, then let k be 0. */
    if (k < 0.)
      k := 0.;
  }
  /* 11. Repeat, while k<len */
  while (k < len) {
    /* a. Let kPresent be HasProperty(O, ToString(k)). */
    kPresent := HasProperty(O, ToString(k));
    /* b. ReturnIfAbrupt(kPresent).*/
    @ReturnIfAbrupt(kPresent);
    /* c. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let elementK be Get(O, ToString(k)). */
      elementK := Get(O, ToString(k));
      /* ii. ReturnIfAbrupt(elementK). */
      @ReturnIfAbrupt(elementK);
      /* iii. Let same be the result of applying the Strict Equality Comparison Algorithm to searchElement and elementK. */
      same := StrictEqualityComparison(searchElement, elementK);
      /* iv. If same is true, return k. */
      if (same == true)
        return k;
    }
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 10. Return -1. */
  return -(1.);
}
/**
 * The length property of the indexOf method is 1.
 *
 * NOTE The indexOf function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the indexOf function
 * can be applied successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.12 Array.prototype.join (separator)
 *
 * The elements of the array are converted to Strings, and these Strings
 * are then concatenated, separated by occurrences of the separator. If
 * no separator is provided, a single comma is used as the separator.
 *
 * The join method takes one argument, separator, and performs the
 * following steps:
 */
/* function join (global, this, [ separator ]) */
function arrayJoin(global, this, NewTarget, strict, args) {
  separator := l_nth(args, 0);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")) */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If separator is undefined, let separator be the single-character String ",". */
  if (separator == 'undefined)
    separator := ",";
  /* 6. Let sep be ToString(separator). */
  sep := ToString(separator);
  /* 7. ReturnIfAbrupt(sep). */
  @ReturnIfAbrupt(sep);
  /* 8. If len is zero, return the empty String. */
  if (len == 0.)
    return "";
  /* 9. Let element0 be Get(O, "0"). */
  element0 := Get(O, "0");
  @ReturnIfAbrupt(element0);
  /* 10. If element0 is undefined or null, let R be the empty String; otherwise, Let R be ToString(element0). */
  if ((element0 == 'undefined) || (element0 == 'null)) R := ""; else R := ToString(element0);
  /* 11. ReturnIfAbrupt(R). */
  @ReturnIfAbrupt(R);
  /* 12. Let k be 1. */
  k := 1.;
  /* 13. Repeat, while k < len */
  while (k < len) {
    /* a. Let S be the String value produced by concatenating R and sep. */
    S := s_concat([R, sep]);
    /* b. Let element be Get(O, ToString(k)). */
    element := Get(O, ToString(k));
    @ReturnIfAbrupt(element);
    /* c. If element is undefined or null, Let next be the empty String; otherwise, let next be ToString(element). */
    if ((element == 'undefined) || (element == 'null)) next := ""; else next := ToString(element);
    /* d. ReturnIfAbrupt(next). */
    @ReturnIfAbrupt(next);
    /* e. Let R be a String value produced by concatenating S and next. */
    R := s_concat([S, next]);
    /* f. Increase k by 1. */
    k := k + 1.;
  }
  /* 14. Return R. */
  return R;
}
/**
 * The length property of the join method is 1.
 *
 * NOTE The join function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore, it can be transferred
 * to other kinds of objects for use as a method. Whether the join function
 * can be applied successfully to a host object is implementation-dependent.
 */



/**
*  22.1.3.13 Array.prototype.keys ( )
*/
function arrayKeys(global, this, NewTarget, strict, args) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Return CreateArrayIterator(O, "key"). */
  return CreateArrayIterator(O, "key");
}



/**
 * 21.1.3.14 Array.prototype.lastIndexOf ( searchString [ , position ] )
 *
 * lastIndexOf compares searchElement to the elements of the array in
 * descending order using the internal Strict Equality Comparison Algorithm
 * (11.9.6), and if found at one or more positions, returns the index of the
 * last such position; otherwise, -1 is returned.
 *
 * The optional second argument fromIndex defaults to the array's length minus
 * one (i.e. the whole array is searched). If it is greater than or equal to
 * the length of the array, the whole array will be searched. If it is
 * negative, it is used as the offset from the end of the array to compute
 * fromIndex. If the computed index is less than 0, -1 is returned.
 *
 * When the lastIndexOf method is called with one or two arguments, the
 * following steps are taken:
 */
function arrayLastIndexOf(global, this, NewTarget, strict, args) {
  searchElement := l_nth(args, 0);
  fromIndex := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O).*/
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If len is 0, return -1. */
  if (len == 0.)
    return -(1.);
  /* 6. If argument fromIndex was passed let n be ToInteger(fromIndex); else let n be len. */
  if (fromIndex != null) n := ToInteger(fromIndex); else n := len - 1.;
  /* 7. ReturnIfAbrupt(n). */
  @ReturnIfAbrupt(n);
  /* 8. If n ≥ 0, then let k be min(n, len - 1). */
  if (n >= 0.) {
    /* This comparison with -0 was extracted from ES7 standard. Fix bug. */
    /* a. If n is -0, let k be +0; else let k be min(n, len - 1). */
    if (isMinusZero(n)) k := 0.; else k := min(n, len - 1.);
  /* 9. Else, n < 0 */
  } else {
    /* a. Let k be len - abs(n). */
    k := len - abs(n);
  }
  /* 10. Repeat, while k≥ 0 */
  while (k >= 0.) {
    /* a. Let kPresent be HasProperty(O, ToString(k)). */
    kPresent := HasProperty(O, ToString(k));
    /* b. ReturnIfAbrupt(kPresent). */
    @ReturnIfAbrupt(kPresent);
    /* c. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let elementK be Get(O, ToString(k)). */
      elementK := Get(O, ToString(k));
      /* ii. ReturnIfAbrupt(elementK).*/
      @ReturnIfAbrupt(elementK);
      /* iii. Let same be the result of performing Strict Equality Comparison searchElement === elementK. */
      same := StrictEqualityComparison(searchElement, elementK);
      /* iv. If same is true, return k. */
      if (same == true)
        return k;
    }
    /* d. Decrease k by 1. */
    k := k - 1.;
  }
  /* 11. Return -1. */
  return -(1.);
}
/**
 * The length property of the lastIndexOf method is 1.
 *
 * NOTE The lastIndexOf function is intentionally generic; it does not
 * require that its this value be an Array object. Therefore it can be
 * transferred to other kinds of objects for use as a method. Whether the
 * lastIndexOf function can be applied successfully to a host object is
 * implementation-dependent.
 */



 /**
 * 22.1.3.15 Array.prototype.map ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments. map calls
 * callbackfn once for each element in the array, in ascending order, and
 * constructs a new Array from the results. callbackfn is called only for
 * elements of the array which actually exist; it is not called for missing
 * elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value
 * for each invocation of callbackfn. If it is not provided, undefined is
 * used instead.
 *
 * callbackfn is called with three arguments: the value of the element,
 * the index of the element, and the object being traversed.
 *
 * map does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by map is set before the first call
 * to callbackfn. Elements which are appended to the array after the call
 * to map begins will not be visited by callbackfn. If existing elements of
 * the array are changed, their value as passed to callbackfn will be the
 * value at the time map visits them; elements that are deleted after the
 * call to map begins and before being visited are not visited.
 *
 * When the map method is called with one or two arguments, the following
 * steps are taken:
 */
function arrayMap(global, this, NewTarget, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (thisArg != null) T := thisArg; else T := 'undefined;
  /* 7. Let A be ArraySpeciesCreate(O, len). */
  A := ArraySpeciesCreate(O, len);
  /* 8. ReturnIfAbrupt(A). */
  @ReturnIfAbrupt(A);
  /* 9. Let k be 0. */
  k := 0.;
  /* 10. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent). */
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* ii. Let mappedValue be Call(callbackfn, T, «kValue, k, O»). */
      mappedValue := Call(null, null, callbackfn, T, [kValue, k, O]);
      /* iii. ReturnIfAbrupt(mappedValue). */
      @ReturnIfAbrupt(mappedValue);
      /* iv. Let status be CreateDataPropertyOrThrow (A, Pk, mappedValue). */
      status := CreateDataPropertyOrThrow(A, Pk, mappedValue);
      /* v. ReturnIfAbrupt(status). */
      @ReturnIfAbrupt(status);
    }
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 11. Return A. */
  return A;
}
/**
 * The length property of the map method is 1.
 *
 * NOTE The map function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the map function can be applied
 * successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.16 Array.prototype.pop ( ) ( )
 *
 * The last element of the array is removed from the array and returned.
 */
function arrayPop(global, this, NewTarget, strict, args) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")) */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If len is zero, */
  if (len == 0.) {
    /* a. Let setStatus be Set(O, "length", 0, true). */
    setStatus := Set(O, "length", 0., true);
    /* b. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* c. Return undefined. */
    return 'undefined;
  /* 6. Else, len > 0 */
  } else {
    /* a. Let newLen be len–1. */
    newLen := len - (1.);
    /* b. Let indx be ToString(newLen). */
    indx := ToString(newLen);
    /* c. Let element be Get(O, indx). */
    element := Get(O, indx);
    /* d. ReturnIfAbrupt(element). */
    @ReturnIfAbrupt(element);
    /* e. Let deleteStatus be DeletePropertyOrThrow(O, indx). */
    deleteStatus := DeletePropertyOrThrow(O, indx);
    /* f. ReturnIfAbrupt(deleteStatus). */
    @ReturnIfAbrupt(deleteStatus);
    /* g. Let setStatus be Set(O, "length", newLen, true). */
    setStatus := Set(O, "length", newLen, true);
    /* h. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* i. Return element. */
    return element;
  }
}
/**
 * NOTE The pop function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the pop function can be applied
 * successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.17 Array.prototype.push ( ...items )
 *
 * The arguments are appended to the end of the array, in the order in which
 * they appear. The new length of the array is returned as the result of the call.
 *
 * When the push method is called with zero or more arguments item1,item2, etc.,
 * the following steps are taken:
 */
function arrayPush(global, this, NewTarget, strict, items) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")) */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. Let items be an internal List whose elements are, in left to right order, the arguments that were passed to this function invocation. */
  items := items;
  /* 6. Let argCount be the number of elements in items. */
  argCount := int_to_float l_len(items);
  /* 7. If len + argCount > 2^53 - 1, throw a TypeError exception. */
  if ((len + argCount) > (((2. ** 53.) - 1.)))
    throw TypeErrorConstructorInternal();
  /* 8. Repeat, while items is not empty */
  while (items != []) {
    /* a. Remove the first element from items and let E be the value of the element. */
    E := hd items;
    items := tl items;
    /* b. Let setStatus be Set(O, ToString(len), E, true). */
    setStatus := Set(O, ToString(len), E , true);
    /* c. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* d. Increase len by 1. */
    len := len + 1.;
  }
  /* 9. Let setStatus be Set(O, "length", len, true). */
  setStatus := Set(O, "length", len , true);
  /* 10. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 11. Return len. */
  return len;
}
/**
 * The length property of the push method is 1.
 *
 * NOTE The push function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the push function can be applied
 * successfully to a host object is implementation-dependent.
 */



 /**
 * 22.1.3.18 Array.prototype.reduce ( callbackfn [ , initialValue ] )
 *
 * callbackfn should be a function that takes four arguments. reduce calls
 * the callback, as a function, once for each element present in the array,
 * in ascending order.
 *
 * callbackfn is called with four arguments: the previousValue (or value
 * from the previous call to callbackfn), the currentValue (value of the
 * current element), the currentIndex, and the object being traversed. The
 * first time that callback is called, the previousValue and currentValue
 * can be one of two values. If an initialValue was provided in the call to
 * reduce, then previousValue will be equal to initialValue and currentValue
 * will be equal to the first value in the array. If no initialValue was
 * provided, then previousValue will be equal to the first value in the array
 * and currentValue will be equal to the second. It is a TypeError if the
 * array contains no elements and initialValue is not provided.
 *
 * reduce does not directly mutate the object on which it is called but
 * the object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by reduce is set before the first call
 * to callbackfn. Elements that are appended to the array after the call to
 * reduce begins will not be visited by callbackfn. If existing elements of
 * the array are changed, their value as passed to callbackfn will be the
 * value at the time reduce visits them; elements that are deleted after
 * the call to reduce begins and before being visited are not visited.
 *
 * When the reduce method is called with one or two arguments, the
 * following steps are taken:
 */
function arrayReduce(global, this, NewTarget, strict, args) {
  /* Initialize `accumulator` to keep typechecker happy */
  accumulator := null;
  callbackfn := l_nth(args, 0);
  initialValue := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If len is 0 and initialValue is not present, throw a TypeError exception. */
  if ((len == 0.) &&& (initialValue == null))
    throw TypeErrorConstructorInternal();
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. If initialValue is present, then */
  if (initialValue != null) {
    /* a. Set accumulator to initialValue. */
    accumulator := initialValue;
  /* 9. Else, initialValue is not present */
  } else {
    /* a. Let kPresent be false. */
    kPresent := false;
    /* b. Repeat, while kPresent is false and k < len */
    while ((kPresent == false) && (k < len)) {
      /* i. Let Pk be ToString(k). */
      Pk := ToString(k);
      /* ii. Let kPresent be HasProperty(O, Pk). */
      kPresent := HasProperty(O, Pk);
      /* iii. ReturnIfAbrupt(kPresent). */
      @ReturnIfAbrupt(kPresent);
      /* iv. If kPresent is true, then */
      if (kPresent == true) {
        /* 1. Let accumulator be Get(O, Pk). */
        accumulator := Get(O, Pk);
        /* 2. ReturnIfAbrupt(accumulator). */
        @ReturnIfAbrupt(accumulator);
      }
      /* v. Increase k by 1. */
      k := k + 1.;
    }
    /* c. If kPresent is false, throw a TypeError exception. */
    if (kPresent == false)
      throw TypeErrorConstructorInternal();
  }

  /* 10. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent).*/
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* iii. Let accumulator be Call(callbackfn, undefined, «accumulator, kValue, k, O»). */
      accumulator := Call(null, null, callbackfn, 'undefined, [accumulator, kValue, k, O]);
      /* iv. ReturnIfAbrupt(accumulator). */
      @ReturnIfAbrupt(accumulator);
    }
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 11. Return accumulator. */
  return accumulator;
}
/**
 * The length property of the reduce method is 1.
 *
 * NOTE The reduce function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the reduce function
 * can be applied successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.19 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )
 *
 * callbackfn should be a function that takes four arguments. reduceRight calls
 * the callback, as a function, once for each element present in the array, in
 * descending order.
 *
 * callbackfn is called with four arguments: the previousValue (or value from
 * the previous call to callbackfn), the currentValue (value of the current
 * element), the currentIndex, and the object being traversed. The first time
 * the function is called, the previousValue and currentValue can be one of two
 * values. If an initialValue was provided in the call to reduceRight, then
 * previousValue will be equal to initialValue and currentValue will be equal
 * to the last value in the array. If no initialValue was provided, then
 * previousValue will be equal to the last value in the array and currentValue
 * will be equal to the second-to-last value. It is a TypeError if the array
 * contains no elements and initialValue is not provided.
 *
 * reduceRight does not directly mutate the object on which it is called but
 * the object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by reduceRight is set before the first call
 * to callbackfn. Elements that are appended to the array after the call to
 * reduceRight begins will not be visited by callbackfn. If existing elements
 * of the array are changed by callbackfn, their value as passed to callbackfn
 * will be the value at the time reduceRight visits them; elements that are
 * deleted after the call to reduceRight begins and before being visited are
 * not visited.
 *
 * When the reduceRight method is called with one or two arguments,
 * the following steps are taken:
 */
function arrayReduceRight(global, this, NewTarget, strict, args) {
  /* Initialize `accumulator` to keep typechecker happy. */
  accumulator := null;
  callbackfn := l_nth(args, 0);
  initialValue := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If len is 0 and initialValue is not present, throw a TypeError exception. */
  if ((len == 0.) &&& (initialValue == null))
    throw TypeErrorConstructorInternal();
  /* 7. Let k be len-1. */
  k := len - 1.;
  /* 8. If initialValue is present, then */
  if (initialValue != null) {
    /* a. Set accumulator to initialValue. */
    accumulator := initialValue;
  /* 8. Else, initialValue is not present */
  } else {
    /* a. Let kPresent be false. */
    kPresent := false;
    /* b. Repeat, while kPresent is false and k ≥ 0 */
    while ((kPresent == false) && (k >= 0.)) {
      /* i. Let Pk be ToString(k). */
      Pk := ToString(k);
      /* ii. Let kPresent be HasProperty(O, Pk). */
      kPresent := HasProperty(O, Pk);
      /* iii. ReturnIfAbrupt(kPresent). */
      @ReturnIfAbrupt(kPresent);
      /* iv. If kPresent is true, then */
      if (kPresent == true) {
        /* 1. Let accumulator be Get(O, Pk). */
        accumulator := Get(O, Pk);
        /* 2. ReturnIfAbrupt(accumulator). */
        @ReturnIfAbrupt(accumulator);
      }
      /* v. Decrease k by 1. */
      k := k - 1.;
    }
    /* c. If kPresent is false, throw a TypeError exception. */
    if (kPresent == false)
      throw TypeErrorConstructorInternal();
  }

  /* 10. Repeat, while k ≥ 0 */
  while (k >= 0.) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent). */
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* iii. Let accumulator be Call(callbackfn, undefined, «accumulator, kValue, k, »). */
      accumulator := Call(null, null, callbackfn, 'undefined, [accumulator, kValue, k, O]);
      /* iv. ReturnIfAbrupt(accumulator). */
      @ReturnIfAbrupt(accumulator);
    }
    /* d. Decrease k by 1. */
    k := k - 1.;
  }
  /* 11. Return accumulator. */
  return accumulator;
}
/**
 * The length property of the reduceRight method is 1.
 *
 * NOTE The reduceRight function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred to
 * other kinds of objects for use as a method. Whether the reduceRight function
 * can be applied successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.20 Array.prototype.reverse ( )
 *
 * The elements of the array are rearranged so as to reverse their order.
 * The object is returned as the result of the call.
 */
function arrayReverse(global, this, NewTarget, strict, args) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")) */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. Let middle be floor(len/2). */
  middle := floor(len / 2.);
  /* 6. Let lower be 0. */
  lower := 0.;
  /* 7. Repeat, while lower ≠ middle */
  while (lower != middle) {
    /* a. Let upper be len−lower −1. */
    upper := len - lower - 1.;
    /* b. Let upperP be ToString(upper). */
    upperP := ToString(upper);
    /* c. Let lowerP be ToString(lower). */
    lowerP := ToString(lower);
    /* d. Let lowerExists be HasProperty(O, lowerP). */
    lowerExists := HasProperty(O, lowerP);
    /* e. ReturnIfAbrupt(lowerExists). */
    @ReturnIfAbrupt(lowerExists);
    /* f. If lowerExists is true, then */
    if (lowerExists == true) {
      /* i. Let lowerValue be Get(O, lowerP). */
      lowerValue := Get(O, lowerP);
      /* ii. ReturnIfAbrupt(lowerValue). */
      @ReturnIfAbrupt(lowerValue);
    }
    /* g. Let upperExists be HasProperty(O, upperP). */
    upperExists := HasProperty(O, upperP);
    /* h. ReturnIfAbrupt(upperExists). */
    @ReturnIfAbrupt(upperExists);
    /* i. If upperExists is true, then */
    if (upperExists == true) {
      /* i. Let upperValue be Get(O, upperP). */
      upperValue := Get(O, upperP);
      /* ii. ReturnIfAbrupt(upperValue). */
      @ReturnIfAbrupt(upperValue);
    }
    /* j. If lowerExists is true and upperExists is true, then */
    if (lowerExists == true && upperExists == true) {
      /* i. Let setStatus be Set(O, lowerP, upperValue, true). */
      setStatus := Set(O, lowerP, upperValue, true);
      /* ii. ReturnIfAbrupt(setStatus). */
      @ReturnIfAbrupt(setStatus);
      /* iii. Let setStatus be Set(O, upperP, lowerValue, true). */
      setStatus := Set(O, upperP, lowerValue, true);
      /* iv. ReturnIfAbrupt(setStatus). */
      @ReturnIfAbrupt(setStatus);
    /* k. Else if lowerExists is false and upperExists is true, then */
    } else {
      if (lowerExists == false && upperExists == true) {
        /* i. Let setStatus be Set(O, lowerP, upperValue, true). */
        setStatus := Set(O, lowerP, upperValue, true);
        /* ii. ReturnIfAbrupt(setStatus). */
        @ReturnIfAbrupt(setStatus);
        /* iii. Let deleteStatus be DeletePropertyOrThrow (O, upperP). */
        deleteStatus := DeletePropertyOrThrow(O, upperP);
        /* iv. ReturnIfAbrupt(deleteStatus). */
        @ReturnIfAbrupt(deleteStatus);
      /* l. Else if lowerExists is true and upperExists is false, then */
      } else {
        if (lowerExists == true && upperExists == false) {
          /* i. Let deleteStatus be DeletePropertyOrThrow (O, lowerP). */
          deleteStatus := DeletePropertyOrThrow(O, lowerP);
          /* ii. ReturnIfAbrupt(deleteStatus). */
          @ReturnIfAbrupt(deleteStatus);
          /* iii. Let setStatus be Set(O, upperP, lowerValue, true). */
          setStatus := Set(O, upperP, lowerValue, true);
          /* iv. ReturnIfAbrupt(setStatus). */
          @ReturnIfAbrupt(setStatus);
        /* m. Else, both lowerExists and upperExists are false */
        } else {
          /* i. No action is required. */
        }
      }
    }
    /* n. Increase lower by 1. */
    lower := lower + 1.;
  }

  /* 8. Return O . */
  return O;
}
/**
 * NOTE The reverse function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore, it can be transferred
 * to other kinds of objects for use as a method. Whether the reverse function
 * can be applied successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.21 Array.prototype.shift ( )
 *
 * The first element of the array is removed from the array and returned.
 */
function arrayShift(global, this, NewTarget, strict, args) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")) */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If len is zero, then */
  if (len == 0.) {
    /* a. Let setStatus be Set(O, "length", 0, true). */
    setStatus := Set(O, "length", 0., true);
    /* b. ReturnIfAbrupt(setStatus).*/
    @ReturnIfAbrupt(setStatus);
    /* c. Return undefined. */
    return 'undefined;
  }
  /* 6. Let first be Get(O, "0").*/
  first := Get(O, "0");
  /* 7. ReturnIfAbrupt(first). */
  @ReturnIfAbrupt(first);
  /* 8. Let k be 1. */
  k := 1.;
  /* 9. Repeat, while k < len */
  while (k < len) {
    /* a. Let from be ToString(k). */
    from := ToString(k);
    /* b. Let to be ToString(k–1). */
    to := ToString(k - 1.);
    /* c. Let fromPresent be HasProperty(O, from). */
    fromPresent := HasProperty(O, from);
    /* d. ReturnIfAbrupt(fromPresent). */
    @ReturnIfAbrupt(fromPresent);
    /* e. If fromPresent is true, then */
    if (fromPresent == true) {
      /* i. Let fromVal be Get(O, from). */
      fromVal := Get(O, from);
      /* ii. ReturnIfAbrupt(fromVal). */
      @ReturnIfAbrupt(fromVal);
      /* iii. Let setStatus be Set(O, to, fromVal, true). */
      setStatus := Set(O, to, fromVal, true);
      /* iv. ReturnIfAbrupt(setStatus). */
      @ReturnIfAbrupt(setStatus);
    /* f. Else, fromPresent is false */
    } else {
      /* i. Let deleteStatus be DeletePropertyOrThrow(O, to). */
      deleteStatus := DeletePropertyOrThrow(O, to);
      /* ii. ReturnIfAbrupt(deleteStatus). */
      @ReturnIfAbrupt(deleteStatus);
    }
    /* g. Increase k by 1. */
    k := k + 1.;
  }
  /* 10. Let deleteStatus be DeletePropertyOrThrow(O, ToString(len–1)). */
  deleteStatus := DeletePropertyOrThrow(O, ToString(len - 1.));
  /* 11. ReturnIfAbrupt(deleteStatus). */
  @ReturnIfAbrupt(deleteStatus);
  /* 12. Let setStatus be Set(O, "length", len–1, true). */
  setStatus := Set(O, "length", (len - 1.), true);
  /* 13. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 14. Return first. */
  return first;
}
/**
 * NOTE The shift function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the shift function can be applied
 * successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.22 Array.prototype.slice (start, end)
 *
 * The slice method takes two arguments, start and end, and returns an array containing
 * the elements of the array from element start up to, but not including, element end
 * (or through the end of the array if end is undefined). If start is negative, it is
 * treated as length+start where length is the length of the array. If end is negative,
 * it is treated as length+end where length is the length of the array. The following
 * steps are taken:
 */
function arraySlice(global, this, NewTarget, strict, args) {
  start := l_nth(args, 0);
  end := l_nth(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")) */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. Let relativeStart be ToInteger(start). */
  relativeStart := ToInteger(start);
  /* 6. ReturnIfAbrupt(relativeStart). */
  @ReturnIfAbrupt(relativeStart);
  /* 7. If relativeStart is negative, let k be max((len +relativeStart),0); else let k be min(relativeStart,len). */
  if (relativeStart < 0.) k := max((len + relativeStart), 0.); else k := min(relativeStart, len);
  /* 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ToInteger(end). */
  if (end == 'undefined) relativeEnd := len; else relativeEnd := ToInteger(end);
  /* 9. ReturnIfAbrupt(relativeEnd). */
  @ReturnIfAbrupt(relativeEnd);
  /* 10. If relativeEnd is negative, let final be max((len + relativeEnd),0); else let final be min(relativeEnd,len). */
  if (relativeEnd < 0.) final := max((len + relativeEnd), 0.); else final := min(relativeEnd, len);
  /* 11. Let count be max(final – k, 0). */
  count := max(final - k, 0.);
  /* 12. Let A be ArraySpeciesCreate(O, count). */
  A := ArraySpeciesCreate(O, count);
  /* 13. ReturnIfAbrupt(A). */
  @ReturnIfAbrupt(A);
  /* 14. Let n be 0. */
  n := 0.;
  /* 15. Repeat, while k < final */
  while (k < final) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent).*/
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* iii. Let status be CreateDataPropertyOrThrow(A, ToString(n), kValue ). */
      status := CreateDataPropertyOrThrow(A, ToString(n), kValue);
      /* iv. ReturnIfAbrupt(status). */
      @ReturnIfAbrupt(status);
    }
    /* e. Increase k by 1. */
    k := k + 1.;
    /* f. Increase n by 1. */
    n := n + 1.;
  }
  /* 16. Let setStatus be Set(A, "length", n, true). */
  setStatus := Set(A, "length", n, true);
  /* 17. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 18. Return A. */
  return A;
}
/**
 * The length property of the slice method is 2.
 *
 * NOTE The slice function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the slice function can be applied
 * successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.23 Array.prototype.some ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments and returns
 * a value that is coercible to the Boolean value true or false. some calls
 * callbackfn once for each element present in the array, in ascending order,
 * until it finds one where callbackfn returns true. If such an element is
 ª found, some immediately returns true. Otherwise, some returns false.
 * callbackfn is called only for elements of the array which actually exist;
 * it is not called for missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value for
 * each invocation of callbackfn. If it is not provided, undefined is used instead.
 *
 * callbackfn is called with three arguments: the value of the element, the
 * index of the element, and the object being traversed.
 *
 * some does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by some is set before the first call to
 * callbackfn. Elements that are appended to the array after the call to
 * some begins will not be visited by callbackfn. If existing elements of
 * the array are changed, their value as passed to callbackfn will be the
 * value at the time that some visits them; elements that are deleted after
 * the call to some begins and before being visited are not visited. some
 * acts like the "exists" quantifier in mathematics. In particular, for an
 * empty array, it returns false.
 *
 * When the some method is called with one or two arguments, the following
 * steps are taken:
 */
function arraySome(global, this, NewTarget, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) == false)
    throw TypeErrorConstructorInternal();
  /* 6. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (thisArg != null) T := thisArg; else T := 'undefined;
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be HasProperty(O, Pk). */
    kPresent := HasProperty(O, Pk);
    /* c. ReturnIfAbrupt(kPresent). */
    @ReturnIfAbrupt(kPresent);
    /* d. If kPresent is true, then */
    if (kPresent == true) {
      /* i. Let kValue be Get(O, Pk). */
      kValue := Get(O, Pk);
      /* ii. ReturnIfAbrupt(kValue). */
      @ReturnIfAbrupt(kValue);
      /* iii. Let testResult be ToBoolean(Call(callbackfn, T, «kValue, k, and O»)). */
      testResult := ToBoolean(Call(null, null, callbackfn, T, [kValue, k, O]));
      /* iv. ReturnIfAbrupt(testResult). */
      @ReturnIfAbrupt(testResult);
      /* v. If testResult is true, return true. */
      if (testResult == true)
        return true;
    }
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 9. Return false. */
  return false;
}
/**
 * The length property of the some method is 1.
 *
 * NOTE The some function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the some function
 * can be applied successfully to a host object is implementation-dependent.
 */



/**
 * 15.4.4.11 Array.prototype.sort (comparefn)
 *
 * The elements of this array are sorted. The sort is not necessarily stable
 * (that is, elements that compare equal do not necessarily remain in their
 * original order). If comparefn is not undefined, it should be a function
 * that accepts two arguments x and y and returns a negative value if x < y,
 * zero if x == y, or a positive value if x > y.
 */
function arraySort(global, this, NewTarget, strict, args) {
  comparefn := l_nth(args, 0);
  /* 1. Let obj be ToObject(this value). */
  obj := ToObject(this);
  /* 2. Let len be ToLength(Get(obj, "length")). */
  len := ToLength(Get(obj, "length"));
  /* 3. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);

  /* The sort order is the ordering, after completion of this function, of the integer
  *  indexed property values of obj whose integer indexes are less than len. The result
  *  of the sort function is then determined as follows: */

  /* If comparefn is not undefined and is not a consistent comparison function for the
  *  elements of this array (see below), the sort order is implementation-defined. The
  *  sort order is also implementation-defined if comparefn is undefined and
  *  SortCompare (22.1.3.24.1) does not act as a consistent comparison function. */

  /* if (comparefn != 'undefined) */

  /* Let proto be the value of the [[Prototype]] internal property of obj. */
  proto := obj.Prototype;

  /* If proto is not null and there exists an integer j such that all of the
     conditions below are satisfied then the behaviour of sort is
     implementation-defined:
     - obj is sparse (15.4)
     - 0 ≤ j < len
     - The result of calling the [[HasProperty]] internal method of proto
       with argument ToString(j) is true. */
  /* TODO */
  /* The behaviour of sort is also implementation defined if obj is sparse
     and any of the following conditions are true:
     - The [[Extensible]] internal property of obj is false.
     - Any array index property of obj whose name is a nonnegative integer
       less than len is a data property whose [[Configurable]] attribute
       is false. */
  /* TODO */
  /* The behaviour of sort is also implementation defined if any array
     index property of obj whose name is a nonnegative integer less than
     len is an accessor property or is a data property whose [[Writable]]
     attribute is false. */
  /* TODO */
  /* Otherwise, the following steps are taken. */
  /* 1. Perform an implementation-dependent sequence of calls to the [[Get]] ,
        [[Put]], and [[Delete]] internal methods of obj and to SortCompare
        (described below), where the first argument for each call to [[Get]],
        [[Put]], or [[Delete]] is a nonnegative integer less than len and where
        the arguments for calls to SortCompare are results of previous calls to
        the [[Get]] internal method. The throw argument to the [[Put]] and
        [[Delete]] internal methods will be the value true. If obj is not
        sparse then [[Delete]] must not be called. */

  /* Using algorithm recommended here https://github.com/tc39/ecma262/pull/1585 */

  k := 0.;
  nonUndefinedItems := [];
  undefinedCount := 0.;
  while (k < len) {
    k_str := ToString(k);
    jValExists := {obj.HasProperty}(obj, k_str);
    @ReturnIfAbrupt(jValExists);
    jVal := {obj.Get}(obj, k_str, obj);
    @ReturnIfAbrupt(jVal);

    if (jValExists)
      if (jVal == 'undefined)
        undefinedCount := undefinedCount + 1.;
      else
        nonUndefinedItems := l_add(nonUndefinedItems, jVal);

    k := k + 1.;
  }

  /* Sort nonUndefined Items */
  nonUndLen := l_len(nonUndefinedItems);
  sorted := false;
  while (!sorted) {
    index := 0;
    somethingChanged := false;
    while (index < (nonUndLen - 1)) {
      sortingIndex := index;
      currentIndex := index + 1;
      sortingValue := l_nth(nonUndefinedItems, sortingIndex);
      currentValue := l_nth(nonUndefinedItems, currentIndex);
      comparisonResult := SortCompare(comparefn, sortingValue, currentValue);
      @ReturnIfAbrupt(comparisonResult);
      if (comparisonResult > 0.) {
        nonUndefinedItems := l_set(nonUndefinedItems, sortingIndex, currentValue);
        nonUndefinedItems := l_set(nonUndefinedItems, currentIndex, sortingValue);
        somethingChanged := true;
      }
      index := index + 1;
    }
    sorted := (!somethingChanged);
  }

  /* Set nonUndefined Items */
  i := 0;
  while (i < nonUndLen) {
    val := l_nth(nonUndefinedItems, i);
    i_str := ToString(int_to_float i);
    setStatus := {obj.Set}(obj, i_str, val, obj);
    @ReturnIfAbrupt(setStatus);
    i := i + 1;
  }

  /* Set undefineds */
  nonUndLen := int_to_float nonUndLen;
  i := 0.;
  while (i < undefinedCount) {
    i_str := ToString(i + nonUndLen);
    setStatus := {obj.Set}(obj, i_str, 'undefined, obj);
    @ReturnIfAbrupt(setStatus);
    i := i + 1.;
  }

  /* Delete remaining */
  i := nonUndLen + undefinedCount;
  while (i < len) {
    i_str := ToString(i);
    deleteStatus := {obj.Delete}(obj, i_str);
    @ReturnIfAbrupt(deleteStatus);
    i := i + 1.;
  }

  /* 2. Return obj. */
  return obj;

  /* The returned object must have the following two properties.
     - There must be some mathematical permutation π of the nonnegative
       integers less than len, such that for every nonnegative integer j
       less than len, if property old[j] existed, then new[π(j)] is exactly
       the same value as old[j],. But if property old[j] did not exist,
       then new[π(j)] does not exist.
     - Then for all nonnegative integers j and k, each less than len,
       if SortCompare(j,k) < 0 (see SortCompare below), then π(j) < π(k).

    Here the notation old[j] is used to refer to the hypothetical result
    of calling the [[Get]] internal method of obj with argument j before
    this function is executed, and the notation new[j] to refer to the
    hypothetical result of calling the [[Get]] internal method of obj
    with argument j after this function has been executed.

    A function comparefn is a consistent comparison function for a set
    of values S if all of the requirements below are met for all values
    a, b, and c (possibly the same value) in the set S: The notation
    a <CF b means comparefn(a,b) < 0; a =CF b means comparefn(a,b) == 0
    (of either sign); and a >CF b means comparefn(a,b) > 0.

    - Calling comparefn(a,b) always returns the same value v when given
    a specific pair of values a and b as its two arguments. Furthermore,
    Type(v) is Number, and v is not NaN. Note that this implies that
    exactly one of a <CF b, a =CF b, and a >CF b will be true for a
    given pair of a and b.
    - Calling comparefn(a,b) does not modify the this object.
    - a =CF a (reflexivity)
    - If a =CF b, then b =CF a (symmetry)
    - If a =CF b and b =CF c, then a =CF c (transitivity of =CF)
    - If a <CF b and b <CF c, then a <CF c (transitivity of <CF)
    - If a >CF b and b >CF c, then a >CF c (transitivity of >CF)

    NOTE The above conditions are necessary and sufficient to ensure
    that comparefn divides the set S into equivalence classes and that
    these equivalence classes are totally ordered. */
}
/**
 * NOTE 1 Because non-existent property values always compare greater than
 * undefined property values, and undefined always compares greater than any
 * other value, undefined property values always sort to the end of the
 * result, followed by non-existent property values.
 *
 * NOTE 2 The sort function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore, it can be transferred
 * to other kinds of objects for use as a method. Whether the sort function
 * can be applied successfully to a host object is implementation-dependent.
 */


/**
*  22.1.3.24.1 Runtime Semantics: SortCompare( x, y )
*
*  The SortCompare abstract operation is called with two arguments x and y.
*  It also has access to the comparefn argument passed to the current invocation
*  of the sort method. The following steps are taken:
*
*  NOTE 1 Because non-existent property values always compare greater than
*  undefined property values, and undefined always compares greater than
*  any other value, undefined property values always sort to the end of
*  the result, followed by non-existent property values.
*
*  NOTE 2 Method calls performed by the ToString abstract operations in steps
*  5 and 7 have the potential to cause SortCompare to not behave as a consistent
*  comparison function.
*/
function SortCompare(comparefn, x, y) {
  /* 1. If x and y are both undefined, return +0. */
  if ((x == 'undefined) &&& (y == 'undefined))
    return 0.;
  /* 2. If x is undefined, return 1. */
  if (x == 'undefined)
    return 1.;
  /* 3. If y is undefined, return −1. */
  if (y == 'undefined)
    return - (1.);
  /* 4. If the argument comparefn is not undefined, then */
  if (comparefn != 'undefined) {
    /* a. Let v be ToNumber(Call(comparefn, undefined, «x, y»)). */
    v := ToNumber(Call(null, null, comparefn, 'undefined, [x, y]));
    /* b. ReturnIfAbrupt(v). */
    @ReturnIfAbrupt(v);
    /* c. If v is NaN, return +0. */
    if (is_NaN (v))
      return 0.;
    /* d. Return v. */
    return v;
  }
  /* 5. Let xString be ToString(x). */
  xString := ToString(x);
  /* 6. ReturnIfAbrupt(xString). */
  @ReturnIfAbrupt(xString);
  /* 7. Let yString be ToString(y). */
  yString := ToString(y);
  /* 8. ReturnIfAbrupt(yString). */
  @ReturnIfAbrupt(yString);
  /* 9. If xString < yString, return −1. */
  if (xString < yString)
    return -(1.);
  /* 10. If xString > yString, return 1. */
  if (xString > yString)
    return 1.;
  /* 11. Return +0. */
  return 0.;
}



/**
 *  22.1.3.25 Array.prototype.splice (start, deleteCount , ...items )
 *
 * When the splice method is called with two or more arguments start,
 * deleteCount and (optionally) item1, item2, etc., the deleteCount elements
 * of the array starting at array index start are replaced by the arguments
 * item1, item2, etc. An Array object containing the deleted elements (if any)
 * is returned. The following steps are taken:
 */
function arraySplice(global, this, NewTarget, strict, args) {
  start := getOptionalParam(args, 0);
  deleteCount := getOptionalParam(args, 1);
  items := getOptionalParamList(args, 2);
  if (start == null)
    start := 'undefined;
  if (deleteCount == null)
    deleteCount := 'undefined;
  if (items == null)
    items := [];

  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. Let relativeStart be ToInteger(start). */
  relativeStart := ToInteger(start);
  /* 6. ReturnIfAbrupt(relativeStart). */
  @ReturnIfAbrupt(relativeStart);
  /* 7. If relativeStart is negative, let actualStart be max((len + relativeStart),0); else let actualStart be min(relativeStart, len). */
  if (relativeStart < 0.) actualStart := max((len + relativeStart), 0.); else actualStart := min(relativeStart, len);
  n_args := l_len(args);

  /* 8. If the number of actual arguments is 0, then  */
  if (n_args == 0) {
    /* a. Let insertCount be 0. */
    insertCount := 0.;
    /* b. Let actualDeleteCount be 0. */
    actualDeleteCount := 0.;
  /* 9. Else if the number of actual arguments is 1, then  */
  } else {
    if (n_args == 1) {
      /* a. Let insertCount be 0. */
      insertCount := 0.;
      /* b. Let actualDeleteCount be len – actualStart. */
      actualDeleteCount := len - actualStart;
    /* 10. Else, */
    } else {
      /* a. Let insertCount be the number of actual arguments minus 2. */
      insertCount := int_to_float (l_len(args)) - 2.;
      /* b. Let dc be ToInteger(deleteCount). */
      dc := ToInteger(deleteCount);
      /* c. ReturnIfAbrupt(dc). */
      @ReturnIfAbrupt(dc);
      /* d. Let actualDeleteCount be min(max(dc,0), len – actualStart). */
      actualDeleteCount := min(max(dc, 0.), len - actualStart);
    }
  }

  /* 11. If len+insertCount−actualDeleteCount > 253-1, throw a TypeError exception. */
  if ((len + insertCount - actualDeleteCount) > ((2. ** 53.) - 1.))
    throw TypeErrorConstructorInternal();
  /* 12. Let A be ArraySpeciesCreate(O, actualDeleteCount). */
  A := ArraySpeciesCreate(O, actualDeleteCount);
  /* 13. ReturnIfAbrupt(A). */
  @ReturnIfAbrupt(A);
  /* 14. Let k be 0. */
  k := 0.;

  /* 15. Repeat, while k < actualDeleteCount */
  while (k < actualDeleteCount) {
    /* a. Let from be ToString(actualStart+k). */
    from := ToString(actualStart + k);
    /* b. Let fromPresent be HasProperty(O, from). */
    fromPresent := HasProperty(O, from);
    /* c. ReturnIfAbrupt(fromPresent). */
    @ReturnIfAbrupt(fromPresent);
    /* d. If fromPresent is true, then */
    if (fromPresent == true) {
      /* i. Let fromValue be Get(O, from). */
      fromValue := Get(O, from);
      /* ii. ReturnIfAbrupt(fromValue). */
      @ReturnIfAbrupt(fromValue);
      /* iii. Let status be CreateDataPropertyOrThrow(A, ToString(k), fromValue). */
      status := CreateDataPropertyOrThrow(A, ToString(k), fromValue);
      /* iv. ReturnIfAbrupt(status). */
      @ReturnIfAbrupt(status);
    }
    /* e. Increment k by 1. */
    k := k + 1.;
  }
  /* 16. Let setStatus be Set(A, "length", actualDeleteCount, true). */
  setStatus := Set(A, "length", actualDeleteCount, true);
  /* 17. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 18. Let items be a List whose elements are, in left to right order, the portion of the actual argument list starting with the third
         argument. The list is empty if fewer than three arguments were passed. */
  items := items;
  /* 19. Let itemCount be the number of elements in items. */
  itemCount := int_to_float (l_len(items));
  /* 20. If itemCount < actualDeleteCount, then */
  if (itemCount < actualDeleteCount) {
    /* a. Let k be actualStart. */
    k := actualStart;
    /* b. Repeat, while k < (len - actualDeleteCount) */
    while (k < (len - actualDeleteCount)) {
      /* i. Let from be ToString(k+actualDeleteCount). */
      from := ToString(k + actualDeleteCount);
      /* ii. Let to be ToString(k+itemCount). */
      to := ToString(k + itemCount);
      /* iii. Let fromPresent be HasProperty(O, from). */
      fromPresent := HasProperty(O, from);
      /* iv. ReturnIfAbrupt(fromPresent). */
      @ReturnIfAbrupt(fromPresent);
      /* v. If fromPresent is true, then */
      if (fromPresent == true) {
        /* 1. Let fromValue be Get(O, from). */
        fromValue := Get(O, from);
        /* 2. ReturnIfAbrupt(fromValue). */
        @ReturnIfAbrupt(fromValue);
        /* 3. Let setStatus be Set(O, to, fromValue, true). */
        setStatus := Set(O, to, fromValue, true);
        /* 4. ReturnIfAbrupt(setStatus). */
        @ReturnIfAbrupt(setStatus);
      /* vi. Else, fromPresent is false */
      } else {
        /* 1. Let deleteStatus be DeletePropertyOrThrow(O, to). */
        deleteStatus := DeletePropertyOrThrow(O, to);
        /* 2. ReturnIfAbrupt(deleteStatus). */
        @ReturnIfAbrupt(deleteStatus);
      }
      /* vii. Increase k by 1. */
      k := k + 1.;
    }
    /* c. Let k be len. */
    k := len;
    /* d. Repeat, while k > (len - actualDeleteCount + itemCount) */
    while (k > (len - actualDeleteCount + itemCount)) {
      /* i. Let deleteStatus be DeletePropertyOrThrow(O, ToString(k–1)). */
      deleteStatus := DeletePropertyOrThrow(O, ToString(k - 1.));
      /* ii. ReturnIfAbrupt(deleteStatus). */
      @ReturnIfAbrupt(deleteStatus);
      /* iii. Decrease k by 1. */
      k := k - 1.;
    }
  /* 21. Else if itemCount > actualDeleteCount, then */
  } else {
    if (itemCount > actualDeleteCount) {
      /* a. Let k be (len - actualDeleteCount). */
      k := (len - actualDeleteCount);
      /* b. Repeat, while k > actualStart */
      while (k > actualStart) {
        /* i. Let from be ToString(k + actualDeleteCount - 1). */
        from := ToString(k + actualDeleteCount - 1.);
        /* ii. Let to be ToString(k + itemCount - 1) */
        to := ToString(k + itemCount - 1.);
        /* iii. Let fromPresent be HasProperty(O, from). */
        fromPresent := HasProperty(O, from);
        /* iv. ReturnIfAbrupt(fromPresent). */
        @ReturnIfAbrupt(fromPresent);
        /* v. If fromPresent is true, then */
        if (fromPresent == true) {
          /* 1. Let fromValue be Get(O, from). */
          fromValue := Get(O, from);
          /* 2. ReturnIfAbrupt(fromValue). */
          @ReturnIfAbrupt(fromValue);
          /* 3. Let setStatus be Set(O, to, fromValue, true). */
          setStatus := Set(O, to, fromValue, true);
          /* 4. ReturnIfAbrupt(setStatus). */
          @ReturnIfAbrupt(setStatus);
        /* vi. Else, fromPresent is false */
        } else {
          /* 1. Let deleteStatus be DeletePropertyOrThrow(O, to). */
          deleteStatus := DeletePropertyOrThrow(O, to);
          /* 2. ReturnIfAbrupt(deleteStatus). */
          @ReturnIfAbrupt(deleteStatus);
        }
        /* vii. Decrease k by 1. */
        k := k - 1.;
      }
    }
  }
  /* 22. Let k be actualStart. */
  k := actualStart;
  /* 23. Repeat, while items is not empty */
  while (items != []) {
    /* a. Remove the first element from items and let E be the value of that element. */
    E := hd items;
    items := tl items;
    /* b. Let setStatus be Set(O, ToString(k), E, true). */
    setStatus := Set(O, ToString(k), E, true);
    /* c. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 24. Let setStatus be Set(O, "length", len – actualDeleteCount + itemCount, true). */
  setStatus := Set(O, "length", ((len - actualDeleteCount) + itemCount), true);
  /* 25. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 26. Return A. */
  return A;
}
/**
 * The length property of the splice method is 2.
 *
 * NOTE The splice function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the splice function can be
 * applied successfully to a host object is implementation-dependent.
 */



/**
 * 22.1.3.26 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
 *
 * The elements of the array are converted to Strings using their
 * toLocaleString methods, and these Strings are then concatenated,
 * separated by occurrences of a separator String that has been derived
 * in an implementation-defined locale-specific way. The result of calling
 * this function is intended to be analogous to the result of toString,
 * except that the result of this function is intended to be locale-specific.
 *
 * The result is calculated as follows:
 */
function arrayToLocaleString(global, this, NewTarget, strict, args) {
  /* 1. Let array be ToObject(this value). */
  array := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(array);
  /* 3. Let len be ToLength(Get(array, "length")) */
  len := ToLength(Get(array, "length"));
  /* 4. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 5. Let separator be the String value for the list-separator String appropriate
        for the host environment’s current locale (this is derived in an
        implementation-defined way). */
  separator := ","; /* TODO : Host Enviroment */
  /* 6. If len is zero, return the empty String. */
  if (len == 0.)
    return "";
  /* 7. Let firstElement be Get(array, "0"). */
  firstElement := Get(array, "0");
  /* 8. ReturnIfAbrupt(firstElement). */
  @ReturnIfAbrupt(firstElement);
  R := null;
  /* 9. If firstElement is undefined or null, then */
  if ((firstElement == 'undefined) || (firstElement == 'null)) {
    /* a. Let R be the empty String. */
    R := "";
  /* 10. Else */
  } else {
    /* a. Let R be ToString(Invoke(firstElement, "toLocaleString")). */
    R := ToString(Invoke(null, null, firstElement, "toLocaleString", []));
    /* b. ReturnIfAbrupt(R). */
    @ReturnIfAbrupt(R);
  }
  /* 11. Let k be 1. */
  k := 1.;
  /* 12. Repeat, while k < len */
  while (k < len) {
    /* a. Let S be a String value produced by concatenating R and separator. */
    S := s_concat([R, separator]);
    /* b. Let nextElement be Get(array, ToString(k)). */
    nextElement := Get(array, ToString(k));
    /* c. ReturnIfAbrupt(nextElement). */
    @ReturnIfAbrupt(nextElement);
    /* d. If nextElement is undefined or null, then */
    if ((nextElement == 'undefined) || (nextElement == 'null)) {
      /* i. Let R be the empty String. */
      R := "";
    /* e. Else */
    } else {
      /* a. Let R be ToString(Invoke(nextElement, "toLocaleString")). */
      R := ToString(Invoke(null, null, nextElement, "toLocaleString", []));
      /* b. ReturnIfAbrupt(R). */
      @ReturnIfAbrupt(R);
    }
    /* f. Let R be a String value produced by concatenating S and R. */
    R := s_concat([S, R]);
    /* g. Increase k by 1. */
    k := k + 1.;
  }
  /* 13. Return R. */
  return R;
}
/**
 * NOTE 1 The first parameter to this function is likely to be used in a
 * future version of this standard; it is recommended that implementations
 * do not use this parameter position for anything else.
 *
 * NOTE 2 The toLocaleString function is intentionally generic; it does not
 * require that its this value be an Array object. Therefore it can be
 * transferred to other kinds of objects for use as a method. Whether the
 * toLocaleString function can be applied successfully to a host object is
 * implementation-dependent.
 */



/**
 * 22.1.3.27 Array.prototype.toString ( )
 *
 * When the toString method is called, the following steps are taken:
 */
function arrayToString(global, this, NewTarget, strict, args) {
  /* 1. Let array be ToObject(this value). */
  array := ToObject(this);
  /* 2. ReturnIfAbrupt(array). */
  @ReturnIfAbrupt(array);
  /* 3. Let func be Get(array, "join"). */
  func := Get(array, "join");
  /* 4. ReturnIfAbrupt(func). */
  @ReturnIfAbrupt(func);
  /* 5. If IsCallable(func) is false, let func be the intrinsic function %ObjProto_toString% (19.1.3.6). */
  if (IsCallable(func) == false)
    func := getObjectPrototypeToString();
  /* 6. Return Call(func, array). */
  return Call(null, null, func, array, []);
}
/**
 * NOTE The toString function is intentionally generic; it does not
 * require that its this value be an Array object. Therefore it can be
 * transferred to other kinds of objects for use as a method. Whether
 * the toString function can be applied successfully to a host object
 * is implementation-dependent.
 */



/**
 * 22.1.3.28 Array.prototype.unshift ( ...items )
 *
 * The arguments are prepended to the start of the array, such that their
 * order within the array is the same as the order in which they appear
 * in the argument list.
 *
 * When the unshift method is called with zero or more arguments item1,
 * item2, etc., the following steps are taken:
 */
function arrayUnshift(global, this, NewTarget, strict, items) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Let len be ToLength(Get(O, "length")). */
  len := ToLength(Get(O, "length"));
  /* 4. ReturnIfAbrupt(len).*/
  @ReturnIfAbrupt(len);
  /* 5. Let argCount be the number of actual arguments. */
  argCount := int_to_float (l_len(items));
  /* 6. If argCount > 0, then */
  if (argCount > 0.) {
    /* a. If len+ argCount > 2^53-1, throw a TypeError exception.*/
    if ((len + argCount) > ((2. ** 53.) - 1.))
      throw TypeErrorConstructorInternal();
    /* b. Let k be len. */
    k := len;
    /* c. Repeat, while k > 0, */
    while (k > 0.) {
      /* i. Let from be ToString(k-1). */
      from := ToString(k - 1.);
      /* ii. Let to be ToString(k+argCount -1). */
      to := ToString(k + argCount - 1.);
      /* iii. Let fromPresent be HasProperty(O, from).*/
      fromPresent := HasProperty(O, from);
      /* iv. ReturnIfAbrupt(fromPresent). */
      @ReturnIfAbrupt(fromPresent);
      /* v. If fromPresent is true, then */
      if (fromPresent == true) {
        /* 1. Let fromValue be Get(O, from). */
        fromValue := Get(O, from);
        /* 2. ReturnIfAbrupt(fromValue). */
        @ReturnIfAbrupt(fromValue);
        /* 3. Let setStatus be Set(O, to, fromValue, true). */
        setStatus := Set(O, to, fromValue, true);
        /* 4. ReturnIfAbrupt(setStatus). */
        @ReturnIfAbrupt(setStatus);
      /* vi. Else, fromPresent is false */
      } else {
        /* 1. Let deleteStatus be DeletePropertyOrThrow(O, to). */
        deleteStatus := DeletePropertyOrThrow(O, to);
        /* 2. ReturnIfAbrupt(deleteStatus). */
        @ReturnIfAbrupt(deleteStatus);
      }
      /* vii. Decrease k by 1. */
      k := k - 1.;
    }
    /* d. Let j be 0. */
    j := 0.;
    /* e. Let items be an internal List whose elements are, in left
          to right order, the arguments that were passed to this function
          invocation. */
    items := items;
    /* f. Repeat, while items is not empty */
    while (items != []) {
      /* i. Remove the first element from items and let E be the value
            of that element. */
      E := hd items;
      items := tl items;
      /* ii. Let setStatus be Set(O, ToString(j), E, true). */
      setStatus := Set(O, ToString(j), E, true);
      /* iii. ReturnIfAbrupt(setStatus). */
      @ReturnIfAbrupt(setStatus);
      /* iv. Increase j by 1. */
      j := j + 1.;
    }
  }
  /* 7. Let setStatus be Set(O, "length", len+argCount, true). */
  setStatus := Set(O, "length", len + argCount, true);
  /* 8. ReturnIfAbrupt(setStatus). */
  @ReturnIfAbrupt(setStatus);
  /* 9. Return len+argCount. */
  return len + argCount;
}
/**
 * The length property of the unshift method is 1.
 *
 * NOTE The unshift function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the unshift function
 * can be applied successfully to a host object is implementation-dependent.
 */



/**
*  22.1.3.29 Array.prototype.values ( )
*
*  This function is the %ArrayProto_values% intrinsic object.
*/
function arrayValues(global, this, NewTarget, strict, args) {
  /* 1. Let O be ToObject(this value). */
  O := ToObject(this);
  /* 2. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 3. Return CreateArrayIterator(O, "value"). */
  return CreateArrayIterator(O, "value");
}

/**
*  22.1.3.30 Array.prototype [ @@iterator ] ( )
*/
/*
  The initial value of the @@iterator property is the same function object as the initial value of the Array.prototype.values property.
*/

/**
*  22.1.3.31 Array.prototype [ @@unscopables ]
*/
function createUnscopablesObject () {
  results := [];
  /* 1. Let blackList be ObjectCreate(null). */
  blackList := ObjectCreate('null, null);
  /* 2. Perform CreateDataProperty(blackList, "copyWithin", true). */
  result := CreateDataProperty(blackList, "copyWithin", true);
  results := l_add(results, result);
  /* 3. Perform CreateDataProperty(blackList, "entries", true). */
  result := CreateDataProperty(blackList, "entries", true);
  results := l_add(results, result);
  /* 4. Perform CreateDataProperty(blackList, "fill", true). */
  result := CreateDataProperty(blackList, "fill", true);
  results := l_add(results, result);
  /* 5. Perform CreateDataProperty(blackList, "find", true). */
  result := CreateDataProperty(blackList, "find", true);
  results := l_add(results, result);
  /* 6. Perform CreateDataProperty(blackList, "findIndex", true). */
  result := CreateDataProperty(blackList, "findIndex", true);
  results := l_add(results, result);
  /* 7. Perform CreateDataProperty(blackList, "keys", true). */
  result := CreateDataProperty(blackList, "keys", true);
  results := l_add(results, result);
  /* 8. Perform CreateDataProperty(blackList, "values", true). */
  result := CreateDataProperty(blackList, "values", true);
  results := l_add(results, result);
  /* 9. Assert: Each of the above calls will return true. */
  foreach (result : results)
    assert(result);
  /* 10. Return blackList. */
  return blackList;
}




/**
*  22.1.5 Array Iterator Objects
*
*  An Array Iterator is an object, that represents a specific iteration over some
*  specific Array instance object. There is not a named constructor for Array Iterator
*  objects. Instead, Array iterator objects are created by calling certain methods of
*  Array instance objects.
*/

/**
*  22.1.5.1 CreateArrayIterator Abstract Operation
*
*  Several methods of Array objects return Iterator objects. The abstract operation
*  CreateArrayIterator with arguments array and kind is used to create such iterator
*  objects. It performs the following steps:
*/
function CreateArrayIterator (array, kind) {
  /* 1. Assert: Type(array) is Object. */
  assert (Type(array) == "Object" );
  /* 2. Let iterator be ObjectCreate(%ArrayIteratorPrototype%, «‍[[IteratedObject]], [[ArrayIteratorNextIndex]], [[ArrayIterationKind]]»). */
  iterator := ObjectCreate(|Intrinsics|.ArrayIteratorPrototype, ["IteratedObject", "ArrayIteratorNextIndex", "ArrayIterationKind"]);
  /* 3. Set iterator’s [[IteratedObject]] internal slot to array. */
  iterator.IteratedObject := array;
  /* 4. Set iterator’s [[ArrayIteratorNextIndex]] internal slot to 0. */
  iterator.ArrayIteratorNextIndex := 0.;
  /* 5. Set iterator’s [[ArrayIterationKind]] internal slot to kind. */
  iterator.ArrayIterationKind := kind;
  iterator.done := false;
  /* 6. Return iterator. */
  return iterator;
}

/**
 * 22.1.5.2 The %ArrayIteratorPrototype% Object
 */
function initArrayIteratorPrototype(iterProto, realm, strict) {
  prototype := NewECMAScriptObjectFull(iterProto, "Object", true);
  setAllInternalMethodsOfOrdinaryObject(prototype);

  /* 22.1.5.2.1 %ArrayIteratorPrototype%.next( ) */
  nextObject := CreateBuiltInFunctionObject([], "arrayIteratorNext", realm, strict, null);
  descriptor := newDataPropertyDescriptorFull(nextObject, true, false, true);
  setJSProperty(prototype, "next", descriptor);
  /* Length */
  descLen := newDataPropertyDescriptorFull(0., false, false, true);
  setJSProperty(nextObject, "length", descLen);
  /* Name */
  descName := newDataPropertyDescriptorFull("next", false, false, true);
  setJSProperty(nextObject, "name", descName);

  /* 22.1.5.2.2 %ArrayIteratorPrototype% [ @@toStringTag ] */
  descriptor := newDataPropertyDescriptorFull("Array Iterator", false, false, true);
  setJSProperty(prototype, getToStringTagPropertyName(), descriptor);

  return prototype;
}

/**
*  22.1.5.2.1 %ArrayIteratorPrototype%.next( )
*/
function isArrayIteratorInstance(obj) {
  return ("IteratedObject" in_obj obj) &&& ("ArrayIteratorNextIndex" in_obj obj) &&& ("ArrayIterationKind" in_obj obj);
}

function arrayIteratorNext(global, this, NewTarget, strict, args) {
  /* 1. Let O be the this value. */
  O := this;
  /* 2. If Type(O) is not Object, throw a TypeError exception.*/
  if (Type(O) != "Object")
    throw TypeErrorConstructorInternal();
  /* 3. If O does not have all of the internal slots of an Array Iterator Instance (22.1.5.3), throw a TypeError exception. */
  if (!isArrayIteratorInstance(O))
    throw TypeErrorConstructorInternal();
  /* 4. Let a be the value of the [[IteratedObject]] internal slot of O. */
  a := O.IteratedObject;
  /* 5. If a is undefined, return CreateIterResultObject(undefined, true). */
  if (a == 'undefined)
    return CreateIterResultObject('undefined, true);
  /* 6. Let index be the value of the [[ArrayIteratorNextIndex]] internal slot of O. */
  index := O.ArrayIteratorNextIndex;
  /* 7. Let itemKind be the value of the [[ArrayIterationKind]] internal slot of O. */
  itemKind := O.ArrayIterationKind;
  /* 8. If a has a [[TypedArrayName]] internal slot, then */
  if ("TypedArrayName" in_obj a) {
    /* a. Let len be the value of O’s [[ArrayLength]] internal slot. */
    len := a.ArrayLength;
  /* 9. Else, */
  } else {
    /* a. Let len be ToLength(Get(a, "length")). */
    len := ToLength(Get(a, "length"));
    /* b. ReturnIfAbrupt(len). */
    @ReturnIfAbrupt(len);
  }
  /* 10. If index ≥ len, then */
  if (index >= len) {
    /* a. Set the value of the [[IteratedObject]] internal slot of O to undefined. */
    O.IteratedObject := 'undefined;
    tst := Get(a, "0");
    /* b. Return CreateIterResultObject(undefined, true). */
    return CreateIterResultObject('undefined, true);
  }
  /* 11. Set the value of the [[ArrayIteratorNextIndex]] internal slot of O to index+1. */
  O.ArrayIteratorNextIndex := index + 1.;
  /* 12. If itemKind is "key", return CreateIterResultObject(index, false). */
  if (itemKind == "key")
    return CreateIterResultObject(index, false);
  /* 13. Let elementKey be ToString(index). */
  elementKey := ToString(index);
  /* 14. Let elementValue be Get(a, elementKey). */
  elementValue := Get(a, elementKey);
  /* 15. ReturnIfAbrupt(elementValue). */
  @ReturnIfAbrupt(elementValue);
  /* 16. If itemKind is "value", let result be elementValue. */
  if (itemKind == "value") {
    result := elementValue;
  /* 17. Else, */
  } else {
    /* a. Assert: itemKind is "key+value". */
    assert (itemKind == "key+value");
    /* b. Let result be CreateArrayFromList(«index, elementValue»). */
    result := CreateArrayFromList([index, elementValue]);
  }
  /* 18. Return CreateIterResultObject(result, false). */
  return CreateIterResultObject(result, false);
}


/**
* 22.1.5.3 Properties of Array Iterator Instances
*
*  Array Iterator instances are ordinary objects that inherit properties from the
*  %ArrayIteratorPrototype% intrinsic object. Array Iterator instances are initially created
*  with the internal slots listed in Table 48.
*
*                     Table 48 — Internal Slots of Array Iterator Instances
*
*  --------------------------------------------------------------------------------------------------------------------
*  |       Internal Slot 	      |                                Description                                          |
*  --------------------------------------------------------------------------------------------------------------------
*  |     [[IteratedObject]] 	    | The object whose array elements are being iterated.                               |
*  | [[ArrayIteratorNextIndex]] 	| The integer index of the next integer index to be examined by this iteration.     |
*  |                           	  | A String value that identifies what is returned for each element of the iteration.|
*  |  [[ArrayIterationKind]]      |  The possible values are: "key", "value", "key+value".                            |
*  --------------------------------------------------------------------------------------------------------------------
*/
