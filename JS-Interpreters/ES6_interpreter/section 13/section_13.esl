function createThrowTypeErrorFunctionObject(functionPrototypeObject, strict) {
  /* 13.2.3 The [[ThrowTypeError]] Function Object */

  /* The [[ThrowTypeError]] object is a unique function object that is defined once as follows: */

  /* 1. Create a new native ECMAScript object and let F be that object. */
  F := NewECMAScriptObject();
  /* 2. Set all the internal methods of F as described in 8.12. */
  setAllInternalMethodsOfOrdinaryObject(F);
  /* 3. Set the [[Class]] internal property of F to "Function". */
  setInternalProperty(F, "Class", "Function");
  /* 4. Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in 15.3.3.1. */
  setInternalProperty(F, "Prototype", functionPrototypeObject);
  /* 5. Set the [[Call]] internal property of F as described in 13.2.1. */
  setInternalProperty(F, "Call", "BuiltInCall");
  /* 6. Set the [[Scope]] internal property of F to the Global Environment. */
  setInternalProperty(F, "Scope", getGlobalEnvironment(|global|));
  /* 7. Set the [[FormalParameters]] internal property of F to an empty List. */
  setInternalProperty(F, "FormalParameters", []);
  /* 8. Set the [[Code]] internal property of F to be a FunctionBody that unconditionally throws a TypeError exception and
        performs no other action. */
  setInternalProperty(F, "ECMAScriptCode", "internalTypeErrorThrower");
  /* 9. Call the [[DefineOwnProperty]] internal method of F with arguments "length", Property Descriptor {[[Value]]: 0,
        [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
  {F.DefineOwnProperty}(F, "length", {
    Value: 0.,
    Writable: false,
    Enumerable: false,
    Configurable: false
  });
  /* 10. Set the [[Extensible]] internal property of F to false. */
  setInternalProperty(F, "Extensible", false);
  /* 11. Let [[ThrowTypeError]] be F. */

  setInternalProperty(F, "internalLength", 0.);

  return F
};

/**
 * 13.2.14 Runtime Semantics: BlockDeclarationInstantiation (code, env)
 *
 * NOTE When a Block or CaseBlock production is evaluated a new declarative 
 * Environment Record is created and bindings for each block scoped variable, 
 * constant, function, generator function, or class declared in the block are 
 * instantiated in the Environment Record. 
 *
 * BlockDeclarationInstantiation is performed as follows using arguments code 
 * and env. code is the grammar production corresponding to the body of the 
 * block. env is the declarative Environment Record in which bindings are to be 
 * created. 
 */
function BlockDeclarationInstantiation(code, env) {
  /* 1. Let declarations be the LexicallyScopedDeclarations of code. */
  declarations := LexicallyScopedDeclarations(code);
  /* 2. For each element d in declarations do */
  foreach (d : declarations) {
    /* a. For each element dn of the BoundNames of d do */
    /* foreach(dn : BoundNames){ */
      /* i. If IsConstantDeclaration of d is true, then */
      if (IsConstantDeclaration(d)) {
        /* 1. Let status be env.CreateImmutableBinding(dn, true). */
        status := {env.CreateImmutableBinding}(env, d.name, true)
      }      
      /* ii. Else, */
      else {
        /* 1. Let status be env.CreateMutableBinding(dn, false). */
        status := {env.CreateMutableBinding}(env, d.name, false)
      };
      /* iii. Assert: status is never an abrupt completion. */
      assert(!isAnAbruptCompletion(status))
    /* b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then */
      /* i. Let fn be the sole element of the BoundNames of d */
      /* ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env. */
      /* iii. Perform env.InitializeBinding(fn, fo). */
  };
  return
};

function internalTypeErrorThrower(globalObject, this, NewTarget, strict, args) {
  throw TypeErrorConstructorInternal()
};

function getFunctionCode(F) {
  return F.ECMAScriptCode
};

function DescriptorValueIsStrictFunction(desc) {
  print "DEBUG DescriptorValueIsStrictFunction";
  print desc;
  F := desc.Value;
  if (typeof F = __$Obj) {
    return F.Strict
  };
  return false
};

function setAllInternalMethodsExceptGet(obj) {
  obj.GetOwnProperty    := "OrdinaryObjectGetOwnProperty";
  obj.Get               := "OrdinaryObjectGet";
  obj.Set               := "OrdinaryObjectSet";
  obj.HasProperty       := "OrdinaryObjectHasProperty";
  obj.Delete            := "OrdinaryObjectDelete";
  obj.DefineOwnProperty := "OrdinaryObjectDefineOwnProperty";
  obj.GetPrototypeOf    := "OrdinaryObjectGetPrototypeOf";
  obj.OwnPropertyKeys   := "OrdinaryObjectOwnPropertyKeys";
  obj.PreventExtensions := "OrdinaryObjectPreventExtensions";
  obj.IsExtensible      := "OrdinaryObjectIsExtensible";
  obj.Enumerate			    := "OrdinaryObjectEnumerate";

  obj.internalSlotsList := [];
  
  return obj
};


/*  */
function WrappedCall(externalScope, ref, F, this, args) {
  callResult := Call(externalScope, ref, F, this, args) catch CallHandler;
  print("WrappedCallDebug");
  print(callResult);

  if (!(Type(callResult) = "Completion")) {
    return NormalCompletion(callResult)
  };

  return callResult
};

function WrappedInvoke(externalScope, ref, F, this, args) {
  invokeResult := Invoke(externalScope, ref, F, this, args) catch CallHandler;
  
  if (!(Type(invokeResult) = "Completion")) {
    return NormalCompletion(invokeResult)
  };

  return invokeResult
};

function CallHandler(x) {
  print("inside CallHandler");
  print(x);

  return throwEmptyCompletion(x)
};

function CreateBuiltInConstructorObject(prototype, FormalParameterList, FunctionBody, Scope, Strict, n, name) {
  F := CreateGeneralBuiltInFunction(prototype, FormalParameterList, FunctionBody, Scope, Strict, n);
  setConfigurability(F, "length", true);
  {F.DefineOwnProperty}(F, "name", {
    Value: name,
    Writable: false,
    Enumerable: false,
    Configurable: true
  });
  return F
}

