/* Placeholder */

function getStringPrototype(strict) {
  refString := newPropertyReference(|global|, "String", strict);
  StringObject := GetValue(refString);
  refStringProto := newPropertyReference(StringObject, "prototype", strict);
  StringProto := GetValue(refStringProto);
  return StringProto;
}


function initStringObject(global, objectPrototype, strict) {
  objStringConstructor := CreateFunctionObject( [ "value" ], "StringConstructor", global, strict, 0.);
  objStringPrototype := initStringPrototype(global, objectPrototype, objStringConstructor, strict);

  descriptor := newDataPropertyDescriptorFull(objStringPrototype, false, false, false);
  setJSProperty(objStringConstructor, "prototype", descriptor);

  /* 15.5.3.2 String.fromCharCode ( [ char0 [ , char1 [ , ... ] ] ] ) */
  fromCharCode := CreateBuiltInFunctionObject(["chars"], "StringFromCharCode", global, strict, 0.);
  createBuiltInProperty(objStringConstructor, "fromCharCode", fromCharCode);

  return objStringConstructor;
}

/* 15.5.4 Properties of the String Prototype Object */
function initStringPrototype(global, objectPrototype, StringConstructor, strict) {
  prototype := NewECMAScriptObject();
  setAllInternalMethodsOfObject(prototype);

  /* The String prototype object is itself a String object (its [[Class]] is "String") whose value is an empty String. */
  setInternalProperty(prototype, "Class", "String");
  setInternalProperty(prototype, "PrimitiveValue", "");
  /* The value of the [[Prototype]] internal property of the String prototype object is the standard built-in Object
     prototype object (15.2.4). */
  setInternalProperty(prototype, "Prototype", objectPrototype);


  /* 15.5.4.1 String.prototype.constructor /
  /* The initial value of String.prototype.constructor is the built-in String constructor. */
  createBuiltInProperty(prototype, "constructor", StringConstructor);

  /* 15.5.4.2 String.prototype.toString ( ) */
  toStringFunctionObject:= CreateBuiltInFunctionObject( [], "StringPrototypetoString", global, strict, null);
  setJSProperty(prototype, "toString", newDataPropertyDescriptorFull( toStringFunctionObject, true, false, true ));

  /* 15.5.4.3 String.prototype.valueOf ( ) */
  valueOfFunctionObject := CreateBuiltInFunctionObject([], "StringPrototypevalueOf", global, strict, null);
  createBuiltInProperty(prototype, "valueOf", valueOfFunctionObject);

  /* 15.5.4.4 String.prototype.charAt (pos) */
  charAtFunctionObject:= CreateBuiltInFunctionObject( [ "pos" ], "StringPrototypecharAt", global, strict, null);
  setConfigurability(charAtFunctionObject, "length", true);
  setJSProperty(prototype, "charAt", newDataPropertyDescriptorFull( charAtFunctionObject, true, false, true ));

  /* 15.5.4.5 String.prototype.charCodeAt (pos) */
  charCodeAtFunctionObject:= CreateBuiltInFunctionObject( [ "pos" ], "StringPrototypecharCodeAt", global, strict, null);
  setConfigurability(charCodeAtFunctionObject, "length", true);
  setJSProperty(prototype, "charCodeAt", newDataPropertyDescriptorFull( charCodeAtFunctionObject, true, false, true ));

  /* 15.5.4.6 String.prototype.concat ( [ string1 [ , string2 [ , ... ] ] ] ) */
  concatFunctionObject:= CreateBuiltInFunctionObject( [ "strings" ], "StringPrototypeconcat", global, strict, 0.);
  setConfigurability(concatFunctionObject, "length", true);
  setJSProperty(prototype, "concat", newDataPropertyDescriptorFull( concatFunctionObject, true, false, true ));

  /* 15.5.4.7 String.prototype.indexOf (searchString, position) */
  indexOfFunctionObject := CreateBuiltInFunctionObject(["searchString", "position"], "StringPrototypeIndexOf", global, strict, null);
  /* The length property of the indexOf method is 1. */
  setJSProperty(indexOfFunctionObject, "length", newDataPropertyDescriptorFull(1., false, false, false));
  setConfigurability(indexOfFunctionObject, "length", true);
  createBuiltInProperty(prototype, "indexOf", indexOfFunctionObject);

  /* 15.5.4.8 String.prototype.lastIndexOf (searchString, position) */
  lastIndexOfFunctionObject := CreateBuiltInFunctionObject(["searchString", "position"], "StringPrototypelastIndexOf", global, strict, null);
  /* The length property of the lastIndexOf method is 1. */
  setJSProperty(lastIndexOfFunctionObject, "length", newDataPropertyDescriptorFull(1., false, false, false));
  setConfigurability(lastIndexOfFunctionObject, "length", true);
  createBuiltInProperty(prototype, "lastIndexOf", lastIndexOfFunctionObject);

  /* 15.5.4.9 String.prototype.localeCompare (that) */
  localeCompareFunctionObject := CreateBuiltInFunctionObject(["that"], "StringPrototypelocaleCompare", global, strict, null);
  setConfigurability(localeCompareFunctionObject, "length", true);
  createBuiltInProperty(prototype, "localeCompare", localeCompareFunctionObject);

  /* 15.5.4.10 String.prototype.match (regexp) */
  matchFunctionObject := CreateBuiltInFunctionObject(["regexp"], "StringPrototypeMatch", global, strict, null);
  setConfigurability(matchFunctionObject, "length", true);
  createBuiltInProperty(prototype, "match", matchFunctionObject);

  /* 15.5.4.11 String.prototype.replace (searchValue, replaceValue) */
  replaceFunctionObject := CreateBuiltInFunctionObject(["searchValue", "replaceValue"], "StringPrototypeReplace", global, strict, null);
  setConfigurability(replaceFunctionObject, "length", true);
  createBuiltInProperty(prototype, "replace", replaceFunctionObject);

  /* 15.5.4.12 String.prototype.search (regexp) */
  searchFunctionObject := CreateBuiltInFunctionObject(["regexp"], "StringPrototypeSearch", global, strict, null);
  setConfigurability(searchFunctionObject, "length", true);
  createBuiltInProperty(prototype, "search", searchFunctionObject);

  /* 15.5.4.13 String.prototype.slice (start, end) */
  sliceFunctionObject := CreateBuiltInFunctionObject(["start", "end"], "StringPrototypeSlice", global, strict, null);
  setConfigurability(sliceFunctionObject, "length", true);
  createBuiltInProperty(prototype, "slice", sliceFunctionObject);

  /* 15.5.4.14 String.prototype.split (separator, limit) */
  splitFunctionObject := CreateBuiltInFunctionObject(["separator", "limit"], "StringPrototypeSplit", global, strict, null);
  setConfigurability(splitFunctionObject, "length", true);
  createBuiltInProperty(prototype, "split", splitFunctionObject);

  /* 15.5.4.15 String.prototype.substring (start, end) */
  substringFunctionObject:= CreateBuiltInFunctionObject( [ "start", "end" ], "StringPrototypesubstring", global, strict, null);
  setConfigurability(substringFunctionObject, "length", true);
  setJSProperty(prototype, "substring", newDataPropertyDescriptorFull( substringFunctionObject , true, false, true));

  /* 15.5.4.16 String.prototype.toLowerCase ( ) */
  toLowerCaseFunctionObject:= CreateBuiltInFunctionObject( [], "StringPrototypetoLowerCase", global, strict, null);
  setConfigurability(toLowerCaseFunctionObject, "length", true);
  setJSProperty(prototype, "toLowerCase", newDataPropertyDescriptorFull( toLowerCaseFunctionObject, true, false, true ));

  /* 15.5.4.17 String.prototype.toLocaleLowerCase ( ) */
  toLocaleLowerCaseFunctionObject := CreateBuiltInFunctionObject([], "StringPrototypetoLocaleLowerCase", global, strict, null);
  setConfigurability(toLocaleLowerCaseFunctionObject, "length", true);
  createBuiltInProperty(prototype, "toLocaleLowerCase", toLocaleLowerCaseFunctionObject);

  /* 15.5.4.18 String.prototype.toUpperCase ( ) */
  toUpperCaseFunctionObject := CreateBuiltInFunctionObject([], "StringPrototypetoUpperCase", global, strict, null);
  setConfigurability(toUpperCaseFunctionObject, "length", true);
  createBuiltInProperty(prototype, "toUpperCase", toUpperCaseFunctionObject);

  /* 15.5.4.19 String.prototype.toLocaleUpperCase ( ) */
  toLocaleUpperCaseFunctionObject := CreateBuiltInFunctionObject([], "StringPrototypetoLocaleUpperCase", global, strict, null);
  setConfigurability(toLocaleUpperCaseFunctionObject, "length", true);
  createBuiltInProperty(prototype, "toLocaleUpperCase", toLocaleUpperCaseFunctionObject);

  /* 15.5.4.20 String.prototype.trim ( ) */
  trimFunctionObject := CreateBuiltInFunctionObject([], "StringPrototypeTrim", global, strict, null);
  createBuiltInProperty(prototype, "trim", trimFunctionObject);

  /* 15.5.5.1 length */
  /* The number of characters in the String value represented by this String object. */
  /* Once a String object is created, this property is unchanging. It has the attributes { [[Writable]]: false,
     [[Enumerable]]: false, [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(prototype, "length", 0., false, false, false);

  return prototype;
}



/* 15.5 String Objects */

/* 15.5.1 The String Constructor Called as a Function */
/* When String is called as a function rather than as a constructor, it performs a type conversion. */

/* 15.5.1.1 String ( [ value ] ) */
/* Returns a String value (not a String object) computed by ToString(value). If value is not supplied,
   the empty String "" is returned. */
function StringConstructorCalledAsFunction(value) {
  if (value = null)
    return ""
  else
    return ToString(value);
}

/* 15.5.2 The String Constructor */

/* When String is called as part of a new expression, it is a constructor: it initialises the newly created object. */

/* 15.5.2.1 new String ( [ value ] ) */

function StringConstructor (global, this, strict, args) {
  value := getOptionalParam(args, 0);

  if ((this = 'undefined) ||| (this = 'null))
    return StringConstructorCalledAsFunction(value);

  /* When String is called as part of a new expression, it is a constructor: it initialises the newly created object. */
  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfString(newlyConstructedObject);

  /* The [[Prototype]] internal property of the newly constructed object is set to the standard built-in String
    prototype object that is the initial value of String.prototype (15.5.3.1). */
  setInternalProperty(newlyConstructedObject, "Prototype", getStringPrototype(strict));
  /* The [[Class]] internal property of the newly constructed object is set to "String". */
  setInternalProperty(newlyConstructedObject, "Class", "String");
  /* The [[Extensible]] internal property of the newly constructed object is set to true. */
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  /* The [[PrimitiveValue]] internal property of the newly constructed object is set to ToString(value),
     or to the empty String if value is not supplied. */
  if (value = null)
    newlyConstructedObject.PrimitiveValue := "";
  else
    newlyConstructedObject.PrimitiveValue := ToString(value);
    
  /* 15.5.5 Properties of String Instances */
  /* String instances inherit properties from the String prototype object and their [[Class]] internal property value is
     "String". String instances also have a [[PrimitiveValue]] internal property, a length property, and a set of
     enumerable properties with array index names. */
  i := 0;
  len := s_len_u (newlyConstructedObject.PrimitiveValue);
  while (i < len) {
    i_str := int_to_string i;
    createBuiltInPropertyWithFullDescriptor(newlyConstructedObject, i_str, s_nth_u (newlyConstructedObject.PrimitiveValue, i), false, true, false);
    i := i + 1;
  }
  /* The [[PrimitiveValue]] internal property is the String value represented by this String object. The array index
     named properties correspond to the individual characters of the String value. A special [[GetOwnProperty]]
     internal method is used to specify the number, values, and attributes of the array index named properties. */

  /* 15.5.5.1 length */
  /* The number of characters in the String value represented by this String object. */
  /* Once a String object is created, this property is unchanging. It has the attributes { [[Writable]]: false,
     [[Enumerable]]: false, [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(newlyConstructedObject, "length", int_to_float (s_len_u (newlyConstructedObject.PrimitiveValue)), false, false, false);

  return newlyConstructedObject;
}


/* 15.5.3 Properties of the String Constructor */

/* The value of the [[Prototype]] internal property of the String constructor is the standard built-in Function prototype object (15.3.4).
Besides the internal properties and the length property (whose value is 1), the String constructor has the following properties: */


/* 15.5.3.1 String.prototype  */
/* The initial value of String.prototype is the standard built-in String prototype object (15.5.4).
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. */




/**
 * 15.5.3.2 String.fromCharCode ( [char0 [, char1 [, ... ]]])
 *
 * Returns a String value containing as many characters as the number of arguments.
 * Each argument specifies one character of the resulting String,
 * with the first argument specifying the first character, and so on, from left to right.
 * An argument is converted to a character by applying the operation ToUint16 (9.7)
 * and regarding the resulting 16-bit integer as the code unit value of a character.
 * If no arguments are supplied, the result is the empty String.
 *
 * The length property of the fromCharCode function is 1.
 */
function StringFromCharCode (global, this, strict, args) {
  args_ := args;
  R := "";
  while (!(args_ = [])) {
    /* Remove the first element from args and let next be the value of that element. */
    next  := hd args_;
    args_ := tl args_;
    /* An argument is converted to a character by applying the operation ToUint16 */
    R := s_concat([R, from_char_code_u ( int_of_float (ToUint16(next) )) ]);
  }
  return R;
}

/* 15.5.4 Properties of the String Prototype Object */
/* Verificar o true */
/* function String.prototype() {
  ret := {
    Prototype: "Object.Prototype",
    Class: "String",
    Extensible: true,
    PrimitiveValue: ""
  }
  return ret
}
*/

/* 15.5.4.1 String.prototype.constructor */


/* 15.5.4.2 String.prototype.toString() */
function StringPrototypetoString (global, this, strict, args) {
  /* Returns this String value. (Note that, for a String object, the toString method happens to return the same
     thing as the valueOf method.) */

  /* The toString function is not generic; it throws a TypeError exception if its this value is not a String or a
     String object. Therefore, it cannot be transferred to other kinds of objects for use as a method. */
  if (!isStringOrStringObject(this))
    throw TypeErrorConstructorInternal();

  if (Type(this) = "String")
    return this;

  return getInternalProperty(this, "PrimitiveValue");
}

/* 15.5.4.3 String.prototype.valueOf ( ) */
function StringPrototypevalueOf (global, this, strict, args) {
  /* Returns this String value. */

  /* The valueOf function is not generic; it throws a TypeError exception if its this value is not a String or String
     object. Therefore, it cannot be transferred to other kinds of objects for use as a method. */
  if (!isStringOrStringObject(this))
    throw TypeErrorConstructorInternal();
  
  if (Type(this) = "String")
    return this;

  return getInternalProperty(this, "PrimitiveValue");
}

/* 15.5.4.4 String.prototype.charAt (pos) */
/*  Returns a String containing the character at position pos in the String resulting from converting this object to a String.
If there is no character at that position, the result is the empty String. The result is a String value, not a String object.

If pos is a value of Number type that is an integer, then the result of x.charAt( pos) is equal to the result of x.substring( pos, pos+1).

When the charAt method is called with one argument pos, the following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let position be ToInteger(pos).

    Let size be the number of characters in S.

    If position < 0 or position ≥ size, return the empty String.

    Return a String of length 1, containing one character from S, namely the character at position position,
    where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on.

NOTE The charAt function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method. */

function StringPrototypecharAt(global, this, strict, args) {
  pos := l_nth(args, 0);

  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let position be ToInteger(pos). */
  position := int_of_float(ToInteger(pos));
  /* Let size be the number of characters in S. */
  size := s_len_u(S);
  /* If position < 0 or position ≥ size, return the empty String. */
  if ((position < 0) ||| (position >= size))
    return "";

  /* Return a String of length 1, containing one character from S, namely the character at position position
  where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on.*/
  return (s_nth_u (S, position));
}

/* 15.5.4.5 String.prototype.charCodeAt (pos) */

/*Returns a Number (a nonnegative integer less than 2^16) representing the code unit value of the character at position pos in the String resulting from converting this object to a String. If there is no character at that position, the result is NaN.

When the charCodeAt method is called with one argument pos, the following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let position be ToInteger(pos).

    Let size be the number of characters in S.

    If position < 0 or position ≥ size, return NaN.

    Return a value of Number type, whose value is the code unit value of the character at position position
     in the String S, where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on.

NOTE The charCodeAt function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypecharCodeAt (global, this, strict, args) {
  pos := l_nth(args, 0);

  /*Call CheckObjectCoercible passing the this value as its argument.*/
  CheckObjectCoercible(this);
  /*Let S be the result of calling ToString, giving it the this value as its argument.*/
  S := ToString(this);
  /*Let position be ToInteger(pos).*/
  position := int_of_float(ToInteger(pos));
  /*Let size be the number of characters in S.*/
  size := s_len_u(S);
  /* If position < 0 or position ≥ size, return NaN. */
  if ((position < 0) ||| (position >= size))
    return NaN;
  
  /*     Return a value of Number type, whose value is the code unit value of the character at position position
       in the String S, where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on. */
  return int_to_float (to_char_code_u (s_nth_u (S, position)));
}

/*15.5.4.6 String.prototype.concat ( [ string1 [ , string2 [ , … ] ] ] )  */
/*
When the concat method is called with zero or more arguments string1, string2, etc., it returns a String consisting of the characters of this object (converted to a String) followed by the characters of each of string1, string2, etc. (where each argument is converted to a String). The result is a String value, not a String object. The following steps are taken:

   Call CheckObjectCoercible passing the this value as its argument.

   Let S be the result of calling ToString, giving it the this value as its argument.

   Let args be an internal list that is a copy of the argument list passed to this function.

   Let R be S.

   Repeat, while args is not empty

       Remove the first element from args and let next be the value of that element.

       Let R be the String value consisting of the characters in the previous value of R followed by the characters of ToString(next).

   Return R.

The length property of the concat method is 1.

NOTE The concat function is intentionally generic; it does not require that its this value be a String object.
Therefore it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypeconcat(global, this, strict, args) {
  /*Call CheckObjectCoercible passing the this value as its argument.*/
  CheckObjectCoercible(this);
  /*Let S be the result of calling ToString, giving it the this value as its argument.*/
  S := ToString(this);
  /* Let args be an internal list that is a copy of the argument list passed to this function. */
  /* TO DO, both require args name) */
  args_ := args;
  /* Let R be S. */
  R := S;
  /* Repeat, while args is not empty */
  while (!(args_ = [])) {
    /* Remove the first element from args and let next be the value of that element. */
    next  := hd args_;
    args_ := tl args_;
    /* Let R be the String value consisting of the characters in the previous value of R followed by the characters of ToString(next). */
    R := s_concat([R, ToString(next)]);
  }
  /* Return R. */
  return R;
  /* The length property of the concat method is 1. */
  /* To Do */
}

/* 15.5.4.7 String.prototype.indexOf (searchString, position) */

/*  If searchString appears as a substring of the result of converting this object to a String, at one or more positions that are greater than or equal to position, then the index of the smallest such position is returned; otherwise, -1 is returned. If position is undefined, 0 is assumed, so as to search all of the String.

The indexOf method takes two arguments, searchString and position, and performs the following steps:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let searchStr be ToString(searchString).

    Let pos be ToInteger(position). (If position is undefined, this step produces the value 0).

    Let len be the number of characters in S.

    Let start be min(max(pos, 0), len).

    Let searchLen be the number of characters in searchStr.

    Return the smallest possible integer k not smaller than start such that k+ searchLen is not greater than len,
    and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same as the character at position j of searchStr);
    but if there is no such integer k, then return the value -1.

The length property of the indexOf method is 1.

NOTE The indexOf function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypeIndexOf (global, this, strict, args) {
  searchString := l_nth(args, 0);
  position := l_nth(args, 1);

  /*Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /*Let S be the result of calling ToString, giving it the this value as its argument.*/
  S := ToString(this);
  /* Let searchStr be ToString(searchString). */
  searchStr := ToString(searchString);
  /* Let pos be ToInteger(position). (If position is undefined, this step produces the value 0). */
  pos := ToInteger(position);
  /* Let len be the number of characters in S. */
  len := s_len_u(S);
  /* Let start be min(max(pos, 0), len). */
  start := min(max(pos, 0.), int_to_float len);
  /* Let searchLen be the number of characters in searchStr. */
  searchLen := s_len_u(searchStr);
  /*     Return the smallest possible integer k not smaller than start such that k+ searchLen is not greater than len,
      and for all nonnegative integers j less than searchLen,
      the character at position k+j of S is the same as the character at position j of searchStr);
      but if there is no such integer k, then return the value -1. */
  /* the smallest possible integer k not smaller than start */
  k := int_of_float start;
  /* for all nonnegative integers j */
  j := 0;
  /* such that k+ searchLen is not greater than len */
  while ((k + searchLen) <= len) {
  /* for all nonnegative integers j less than searchLen*/
    if (j < searchLen) {
      /* the character at position k+j of S is the same as the character at position j of searchStr */
      if (s_nth_u (S, k + j) = s_nth_u(searchStr, j)) {
        j := j + 1;
      } else {
        j := 0;
        k := k + 1;
      }
    } else {
      return int_to_float k;
    }
  }
  /* but if there is no such integer k, then return the value -1. */
  return -(1.);
}

/* 15.5.4.8 String.prototype.lastIndexOf (searchString, position) */
/*
If searchString appears as a substring of the result of converting this object to a String at one or more positions that are smaller than or equal to position, then the index of the greatest such position is returned; otherwise, -1 is returned. If position is undefined, the length of the String value is assumed, so as to search all of the String.

The lastIndexOf method takes two arguments, searchString and position, and performs the following steps:

   Return the largest possible nonnegative integer k not larger than start such that k+ searchLen is not greater than len,
   and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same
    as the character at position j of searchStr;
   but if there is no such integer k, then return the value -1.

The length property of the lastIndexOf method is 1.

NOTE The lastIndexOf function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypelastIndexOf(global, this, strict, args) {
  searchString := l_nth(args, 0);
  position := l_nth(args, 1);

  /*Call CheckObjectCoercible passing the this value as its argument.*/
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let searchStr be ToString(searchString). */
  searchStr := ToString(searchString);
  /*  Let numPos be ToNumber(position). (If position is undefined, this step produces the value NaN). */
  numPos := ToNumber(position);
  /*  If numPos is NaN, let pos be +∞; otherwise, let pos be ToInteger(numPos).*/
  if (is_NaN (numPos)) 
    pos := Infinity; 
  else 
    pos := ToInteger(numPos); 
  /* Let len be the number of characters in S.*/
  len := s_len_u(S);
  /* Let start min(max(pos, 0), len). */
  start := int_of_float (min(max(pos, 0.), int_to_float len));
  /* Let searchLen be the number of characters in searchStr. */
  searchLen := s_len_u(searchStr);
  /* k not larger than start */
  k := start;
  /* for all nonnegative integers j */
  j := 0;
  /* nonnegative integer k */
  while (k >= 0) {
     /* and for all nonnegative integers j less than searchLen */
     if (j < searchLen) {
       /* k+ searchLen is not greater than len */
       if ((k + searchLen) <= len) {
         /* the character at position k+j of S is the same as the character at position j of searchStr */
         if (s_nth_u(S, k + j) = s_nth_u(searchStr, j)) {
           j := j + 1;
         }
         else {
           j := 0;
           k := k - 1;
         }
       }
       else {
         k := k - 1;
       }
     }
     else {
       /* Return the largest possible nonnegative integer k */
       return int_to_float k;
     }
  }
  /* but if there is no such integer k, then return the value -1. */
  return -(1.);
}

/* 15.5.4.9 String.prototype.localeCompare (that) */

/* When the localeCompare method is called with one argument that,
it returns a Number other than NaN that represents the result of a locale-sensitive String
 comparison of the this value (converted to a String) with that (converted to a String).
  The two Strings are S and That. The two Strings are compared in an implementation-defined fashion.
  The result is intended to order String values in the sort order specified by the system default locale,
  and will be negative, zero, or positive, depending on whether S comes before That in the sort order,
   the Strings are equal, or S comes after That in the sort order, respectively.*/

function StringPrototypelocaleCompare (global, this, strict, args) {
  that := l_nth(args, 0);

  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let That be ToString(that). */
  That := ToString(that);
  /* The result is intended to order String values and
  will be negative, zero, or positive, depending on whether S comes before That in the sort order*/
  SLen := s_len_u (S);
  ThatLen := s_len_u (That);
  j := 0;
  while ((j < SLen) &&& (j < ThatLen)) {
    if (to_char_code_u(s_nth_u(S, j)) < to_char_code_u(s_nth_u(That, j))) {
      return -(1.);
    } else {
      if (to_char_code_u(s_nth_u(S, j)) > to_char_code_u(s_nth_u(That, j))) {
        return 1.;
      } else {
        j := j + 1;
      }
    }
  }
  if ((j < SLen) &&& !(j < ThatLen)) {
    return -(1.);
  }
  else {
    if (!(j < SLen) &&& (j < ThatLen)) {
      return 1.;
    } else {
      return 0.;
    }
  }
}

/**
 * 15.5.4.10 String.prototype.match (regexp)
 *
 * When the match method is called with argument regexp, the following steps are taken:
 */
function StringPrototypeMatch(global, this, strict, args) {
  regexp := l_nth(args, 0);

  /* 1. Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* 2. Let S be the result of calling ToString, giving it the this value
    as its argument. */
  S := ToString(this);
  /* 3. If Type(regexp) is Object and the value of the [[Class]] internal
    property of regexp is "RegExp", then let rx be regexp; */
  if ((Type(regexp) = "Object") &&& (regexp.Class = "RegExp")) {
    rx := regexp;
  }
  /* 4. Else, let rx be a new RegExp object created as if by the expression
    new RegExp( regexp) where RegExp is the standard built-in constructor with that name. */
  else {
    rx := RegExpConstructor(global, this, strict, [regexp, 'undefined]);
  }
  /* 5. Let global be the result of calling the [[Get]] internal method of
    rx with argument "global". */
  global := rx.OriginalFlags.gb;
  /* 6. Let exec be the standard built-in function RegExp.prototype.exec
    (see 15.10.6.2) */
  exec := getRegExpPrototypeExec(strict);
  /* 7. If global is not true, then */
  if (!(global = true)) {
    /* a. Return the result of calling the [[Call]] internal method of exec
      with rx as the this value and argument list containing S. */
    return {exec.Call}(null, null, exec, rx, [S]);
  }
  /* 8. Else, global is true */
  else {
    /* a. Call the [[Put]] internal method of rx with arguments "lastIndex" and 0. */
    {rx.Put}(rx, "lastIndex", 0., true);
    /* b. Let A be a new array created as if by the expression new Array()
      where Array is the standard built-in constructor with that name. */
    A := ArrayConstructor(global, this, strict, []);
    /* c. Let previousLastIndex be 0. */
    previousLastIndex := 0.;
    /* d. Let n be 0. */
    n := 0.;
    /* e. Let lastMatch be true. */
    lastMatch := true;
    /* f. Repeat, while lastMatch is true */
    while (lastMatch = true) {
      /* i. Let result be the result of calling the [[Call]] internal method
        of exec with rx as the this value and argument list containing S. */
      result := {exec.Call}(null, null, exec, rx, [S]);
      /* ii. If result is null, then set lastMatch to false. */
      if (result = 'null) {
        lastMatch := false;
      }
      /* iii. Else, result is not null */
      else {
        /* 1. Let thisIndex be the result of calling the [[Get]] internal
          method of rx with argument "lastIndex". */
        thisIndex := {rx.Get}(rx, "lastIndex");
        /* 2. If thisIndex = previousLastIndex then */
        if (thisIndex = previousLastIndex) {
          /* a. Call the [[Put]] internal method of rx with arguments
            "lastIndex" and thisIndex+1. */
          {rx.Put}(rx, "lastIndex", thisIndex + 1.);
          /* b. Set previousLastIndex to thisIndex+1. */
          previousLastIndex := thisIndex + 1.;
        }
        /* 3. Else, set previousLastIndex to thisIndex. */
        else {
          previousLastIndex := thisIndex;
        }
        /* 4. Let matchStr be the result of calling the [[Get]] internal
          method of result with argument "0". */
        matchStr := {result.Get}(result, "0");
        /* 5. Call the [[DefineOwnProperty]] internal method of A with
          arguments ToString(n), the Property Descriptor {[[Value]]: matchStr,
          [[Writable]]: true, [[Enumerable]]: true, [[configurable]]: true}, and false. */
        descriptorMatchStr := newDataPropertyDescriptorFull(matchStr, true, true, true);
        {A.DefineOwnProperty}(A, ToString(n), descriptorMatchStr, false);
        /* 6. Increment n. */
        n := n + 1.;
      }
    }
  }
  /* g. If n = 0, then return null. */
  if (n = 0)
    return null;
  /* h. Return A. */
  return A;
}
/**
 * NOTE The match function is intentionally generic; it does not require that its
 * this value be a String object. Therefore, it can be transferred to other kinds
 * of objects for use as a method.
 */



/**
 * 15.5.4.11 String.prototype.replace (searchValue, replaceValue)
 */
function StringPrototypeReplace(global, this, strict, args) {
  searchValue := l_nth(args, 0);
  replaceValue := l_nth(args, 1);

  /* 1. Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* 2. Let string be the result of calling ToString, giving it the this
        value as its argument. */
  str := ToString(this);

  /* If searchValue is a regular expression (an object whose [[Class]]
    internal property is "RegExp"), do the following: If searchValue.global
    is false, then search string for the first match of the regular expression
    searchValue. If searchValue.global is true, then search string for all
    matches of the regular expression searchValue. Do the search in the same
    manner as in String.prototype.match, including the update of
    searchValue.lastIndex. Let m be the number of left capturing parentheses
    in searchValue (using NcapturingParens as specified in 15.10.2.1). */
  if (isRegExpObject(searchValue)) {
    g := searchValue.OriginalFlags.gb;
    matchArr := RegExpPrototypeExec(global, searchValue, strict, [str]);
    if (matchArr = 'null)
      return str;

    m := {matchArr.Get}(matchArr, "length") - 1.;
    matches := [matchArr];

    if (g = true) {
      prevLastIndex := getJSProperty(searchValue, "lastIndex").Value;
      if (prevLastIndex = 0.) {
        prevLastIndex := 1.;
        setJSProperty(searchValue, "lastIndex", newDataPropertyDescriptorFull(1., true, false, false));
      }
      while (!(matchArr = 'null)) {
        matchArr := RegExpPrototypeExec(global, searchValue, strict, [str]);
        /* Update lastIndex in case of an empty string match */
        lastIndex := getJSProperty(searchValue, "lastIndex").Value;
        if (lastIndex = prevLastIndex) {
          lastIndex := lastIndex + 1.;
          setJSProperty(searchValue, "lastIndex", newDataPropertyDescriptorFull(lastIndex, true, false, false));
        }
        if (!(matchArr = 'null))
          matches := l_concat(matches, [matchArr]);
        prevLastIndex := lastIndex;
      }
    }
  }
  /* If searchValue is not a regular expression, let searchString be
    ToString(searchValue) and search string for the first occurrence
    of searchString. Let m be 0. */
  else {
    searchString := ToString(searchValue);
    matches := [];
    indexFound := StringPrototypeSearch(global, str, strict, [searchString]);

    if (indexFound >= 0.) {
      A := ArrayConstructor(global, this, strict, []);
      {A.DefineOwnProperty}(A, "index", newDataPropertyDescriptorFull(indexFound, true, true, true), true);
      {A.DefineOwnProperty}(A, "input", newDataPropertyDescriptorFull(str, true, true, true), true);
      {A.DefineOwnProperty}(A, "length", newDataPropertyDescriptorFull(1., true, false, false), true);
      {A.DefineOwnProperty}(A, "0", newDataPropertyDescriptorFull(searchString, true, true, true), true);
      matches := l_concat(matches, [A]);
    }

    m := 0.;
  }
  /* If replaceValue is a function, then for each matched substring, call the
  function with the following m + 3 arguments. Argument 1 is the substring that
  matched. If searchValue is a regular expression, the next m arguments are all
  of the captures in the MatchResult (see 15.10.2.1). Argument m + 2 is the offset
  within string where the match occurred, and argument m + 3 is string. The result
  is a String value derived from the original input by replacing each matched
  substring with the corresponding return value of the function call, converted
  to a String if need be. */
  /* Otherwise, let newstring denote the result of converting replaceValue to a
  String. The result is a String value derived from the original input String by
  replacing each matched substring with a String derived from newstring by replacing
  characters in newstring by replacement text as specified in Table 22. These $
  replacements are done left-to-right, and, once such a replacement is performed,
  the new replacement text is not subject to further replacements. For example,
  "$1,$2".replace(/(\$(\d))/g, "$$1-$1$2") returns "$1-$11,$1-$22". A $ in newstring
  that does not match any of the forms below is left as is. */
  /* Table 22 — Replacement Text Symbol Substitutions

    Characters    Replacement text

    $$            $
    $&            The matched substring.
    $`            The portion of string that precedes the matched substring.
    $'            The portion of string that follows the matched substring.
    $n            The nth capture, where n is a single digit in the range 1 to 9
                  and $ n is not followed by a decimal digit. If n≤m and the nth
                  capture is undefined, use the empty String instead. If n>m, the
                  result is implementation-defined.
    $nn           The nnth capture, where nn is a two-digit decimal number in the
                  range 01 to 99. If nn≤m and the nnth capture is undefined, use
                  the empty String instead. If nn>m, the result is implementation-defined. */

  originalString := str;
  prevOffset := 0;
  resultParts := [];

  i := 0;
  len := l_len matches;
  while (i < len) {
    A := l_nth(matches, i);
    args2 := [];
    captures := [];

    matchStr := {A.Get}(A, "0");
    args2 := l_concat(args2, [matchStr]);

    j := 1.;
    while (j <= m) {
      j_str := float_to_string j;
      matchStr2 := {A.Get}(A, j_str);
      captures := l_concat(captures, [matchStr2]);
      j := j + 1.;
    }

    args2 := l_concat(args2, captures);

    offset := {A.Get}(A, "index");
    args2 := l_concat(args2, [offset]);
    input := {A.Get}(A, "input");
    args2 := l_concat(args2, [input]);

    offset := int_of_float offset;
    startOffset := offset - prevOffset;

    beforeStr := s_substr_u(str, 0, startOffset);
    matchStrLen := s_len_u (matchStr);
    stringLen := (s_len_u (str)) - (s_len_u (beforeStr)) - matchStrLen;
    str := s_substr_u(str, startOffset + matchStrLen, stringLen);

    if ((Type(replaceValue) = "Object") &&& (replaceValue.Class = "Function")) {
      /* TODO - review "this" arg passed to the replace function is 'undefined 
      according to test test/test262/tests/built-ins/String/prototype/replace/15.5.4.11-1.js
      and test/test262/tests/built-ins/String/prototype/replace/15.5.4.11-1.js */
      newstring := {replaceValue.Call}(null, null, replaceValue, 'undefined, args2);
      newstring := ToString(newstring);
    } else {
      newstring := ToString(replaceValue);
      beforeStr2 := s_substr_u(originalString, 0, offset);
      off1 := offset + matchStrLen;
      off2 := (s_len_u (originalString)) - off1;
      afterStr2 := s_substr_u(originalString, off1, off2);
      newstring := resolveDollars(newstring, matchStr, beforeStr2, afterStr2, captures);
    }

    resultParts := l_concat (resultParts, [beforeStr, newstring]);
    prevOffset := offset + matchStrLen;
    i := i + 1;
  }

  resultParts := l_concat (resultParts, [str]);
  return s_concat resultParts;
}
/**
 * NOTE The replace function is intentionally generic; it does not require that its
 * this value be a String object. Therefore, it can be transferred to other kinds of
 * objects for use as a method.
 */



function resolveDollars(newstring, matchStr, beforeStr, afterStr, captures) {
  len := (s_len_u (newstring)) - 1;
  i := 0;
  while (i < len) {
    c1 := s_nth_u(newstring, i);
    c2 := s_nth_u(newstring, i + 1);
    c2_code := to_char_code_u (c2);
    if ((c1 = "$") &&& (c2 = "$")) {
      str1 := s_substr_u(newstring, 0, i + 1);
      startIndex := i + 2;
      if (startIndex > len) str2 := ""; else str2 := s_substr_u(newstring, startIndex, len + 1 - startIndex);
      newstring := s_concat [str1, str2];
      i := i + 1;

    } else if ((c1 = "$") &&& (c2 = "&")) {
      str1 := s_substr_u(newstring, 0, i);
      startIndex := i + 2;
      if (startIndex > len) str2 := ""; else str2 := s_substr_u(newstring, startIndex, len + 1 - startIndex);
      newstring := s_concat [str1, matchStr, str2];
      i := i + (s_len_u (matchStr));

    } else if ((c1 = "$") &&& (c2 = "`")) {
      str1 := s_substr_u(newstring, 0, i);
      startIndex := i + 2;
      if (startIndex > len) str2 := ""; else str2 := s_substr_u(newstring, startIndex, len + 1 - startIndex);
      newstring := s_concat [str1, beforeStr, str2];
      i := i + (s_len_u (beforeStr));

    } else if ((c1 = "$") &&& (c2 = "'")) {
      str1 := s_substr_u(newstring, 0, i);
      startIndex := i + 2;
      if (startIndex > len) str2 := ""; str2 := s_substr_u(newstring, startIndex, len + 1 - startIndex);
      newstring := s_concat [str1, afterStr, str2];
      i := i + (s_len_u (afterStr));

    } else if ((c1 = "$") &&& (c2_code >= 48) &&& (c2_code <= 57)) {
      startIndex := i + 2;
      c3 := "";
      if ((i + 2) <= len) {
        c3 := s_nth_u(newstring, i + 2);
        c3_code := to_char_code_u (c3);
        if ((c3_code >= 48) &&& (c3_code <= 57))
          startIndex := i + 3;
        else
          c3 := "";
      }
      num := int_of_string (s_concat [c2, c3]);
      if (num > (l_len captures)) {
        num := int_of_string c2;
        startIndex := i + 2;
      }
      if (!(num > (l_len captures))) {
        str1 := s_substr_u(newstring, 0, i);
        if (startIndex > len) str2 := ""; str2 := s_substr_u(newstring, startIndex, len + 1 - startIndex);
        m := l_nth(captures, num - 1);
        if (m = 'undefined)
          m := "";
        newstring := s_concat [str1, m, str2];
        i := i + (s_len_u (m));
      } else {
        i := i + 1;
      }
    } else {
      i := i + 1;
    }
    len := (s_len_u (newstring)) - 1;
  }
  return newstring;
}



/**
 * 15.5.4.12 String.prototype.search (regexp)
 *
 * When the search method is called with argument regexp, the following steps are taken:
 */
function StringPrototypeSearch(global, this, strict, args) {
  regexp := l_nth(args, 0);

  /* 1. Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* 2. Let string be the result of calling ToString, giving it
    the this value as its argument. */
  str := ToString(this);
  /* 3. If Type(regexp) is Object and the value of the [[Class]] internal
    property of regexp is "RegExp", then let rx be regexp; */
  if ((Type(regexp) = "Object") &&& (regexp.Class = "RegExp")) {
    rx := regexp;
  }
  /* 4. Else, let rx be a new RegExp object created as if by the expression
    new RegExp( regexp) where RegExp is the standard built-in constructor with that name. */
  else {
    rx := RegExpConstructor(global, this, strict, [regexp, 'undefined]);
  }
  /* 5. Search the value string from its beginning for an occurrence of the
    regular expression pattern rx. Let result be a Number indicating the offset
    within string where the pattern matched, or –1 if there was no match. The
    lastIndex and global properties of regexp are ignored when performing the
    search. The lastIndex property of regexp is left unchanged. */
  matchArr := RegExpPrototypeExec(global, rx, strict, [str]);
  result := -(1.);
  if (!(matchArr = 'null))
    result := getJSProperty(matchArr, "index").Value;

  /* 6. Return result. */
  return result;
}
/**
 * NOTE The search function is intentionally generic; it does not require that
 * its this value be a String object. Therefore, it can be transferred to other
 * kinds of objects for use as a method.
 */




/* 15.5.4.13 String.prototype.slice (start, end)  */
/*
The slice method takes two arguments, start and end, and returns a substring of the result of converting this object to a String,
 starting from character position start and running to, but not including, character position end (or through the end of the String if end is undefined).
If start is negative, it is treated as sourceLength+start where sourceLength is the length of the String.
If end is negative, it is treated as sourceLength+end where sourceLength is the length of the String.
 The result is a String value, not a String object.

The length property of the slice method is 2.

NOTE The slice function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method. */

function StringPrototypeSlice (global, this, strict, args) {
  start := l_nth(args, 0);
  end := l_nth(args, 1);

  /*Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let len be the number of characters in S. */
  len := int_to_float s_len_u(S);
  /* Let intStart be ToInteger(start). */
  intStart := ToInteger(start);
  /* If end is undefined, let intEnd be len; else let intEnd be ToInteger(end). */
  if (end = 'undefined) 
    intEnd := len; 
  else 
    intEnd := ToInteger(end);
  /* If intStart is negative, let from be max(len + intStart,0); else let from be min(intStart,len). */
  if (intStart < 0.) from := max(len + intStart, 0.); else from := min(intStart, len);
  /* If intEnd is negative, let to be max(len +intEnd,0); else let to be min(intEnd, len). */
  if (intEnd < 0.) to := max(len + intEnd, 0.); else to := min(intEnd, len);
  /* Let span be max(to – from,0). */
  span := max(to - from, 0.);
  /* Return a String containing span consecutive characters from S beginning with the character at position from.*/
  substring := "";
  j := 0.;
  while (j < span) {
    substring := s_concat ([substring, s_nth_u (S, int_of_float (from + j))]);
    j := j + 1.;
  }
  return substring;
}

/**
 * 15.5.4.14 String.prototype.split (separator, limit)
 *
 * Returns an Array object into which substrings of the result of converting
 * this object to a String have been stored. The substrings are determined by
 * searching from left to right for occurrences of separator; these occurrences
 * are not part of any substring in the returned array, but serve to divide up
 * the String value. The value of separator may be a String of any length or it
 * may be a RegExp object (i.e., an object whose [[Class]] internal property is
 * "RegExp"; see 15.10).
 *
 * The value of separator may be an empty String, an empty regular expression,
 * or a regular expression that can match an empty String. In this case, separator
 * does not match the empty substring at the beginning or end of the input String,
 * nor does it match the empty substring at the end of the previous separator match.
 * (For example, if separator is the empty String, the String is split up into
 * individual characters; the length of the result array equals the length of the
 * String, and each substring contains one character.) If separator is a regular
 * expression, only the first match at a given position of the this String is
 * considered, even if backtracking could yield a non-empty-substring match at that
 * position. (For example, "ab".split(/a*?/) evaluates to the array ["a","b"],
 * while "ab".split(/a* /) evaluates to the array["","b"].)
 *
 * If the this object is (or converts to) the empty String, the result depends
 * on whether separator can match the empty String. If it can, the result array
 * contains no elements. Otherwise, the result array contains one element, which
 * is the empty String.
 *
 * If separator is a regular expression that contains capturing parentheses,
 * then each time separator is matched the results (including any undefined results)
 * of the capturing parentheses are spliced into the output array. For example,
 *
 * "A<B>bold</B>and<CODE>coded</CODE>".split(/<(\/)?([^<>]+)>/)
 *
 * evaluates to the array
 * 
 * ["A", undefined, "B", "bold", "/", "B", "and", undefined,
 * "CODE", "coded", "/", "CODE", ""]
 *
 * If separator is undefined, then the result array contains just one String,
 * which is the this value (converted to a String). If limit is not undefined,
 * then the output array is truncated so that it contains no more than limit elements.
 *
 * When the split method is called, the following steps are taken:
 */
function StringPrototypeSplit (global, this, strict, args) {
  separator := l_nth(args, 0);
  limit := l_nth(args, 1);

  /* 1. Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* 2. Let S be the result of calling ToString, giving it the this
    value as its argument. */
  S := ToString(this);
  /* 3. Let A be a new array created as if by the expression new Array()
    where Array is the standard built-in constructor with that name. */
  A := ArrayConstructor(global, this, strict, []);
  /* 4. Let lengthA be 0. */
  lengthA := 0.;
  /* 5. If limit is undefined, let lim = 2^32–1; else let lim = ToUint32(limit). */
  if (limit = 'undefined) 
    lim := ((2. ** 32.) - 1.); 
  else 
    lim := ToUint32(limit);
  /* 6. Let s be the number of characters in S. */
  s := s_len_u (S);
  /* 7. Let p = 0. */
  p := 0;
  /* 8. If separator is a RegExp object (its [[Class]] is "RegExp"),
    let R = separator; otherwise let R = ToString(separator). */
  if (isRegExpObject(separator)) 
    R := separator; 
  else 
    R := ToString(separator);
  /* 9. If lim = 0, return A. */
  if (lim = 0.)
    return A;
  /* 10. If separator is undefined */
  if (separator = 'undefined) {
    /* a. Call the [[DefineOwnProperty]] internal method of A with arguments "0",
    Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true,
     [[Configurable]]: true}, and false. */
    {A.DefineOwnProperty}(A, "0", newDataPropertyDescriptorFull(S, true, true, true), false);
    /* b. Return A. */
    return A;
  }
  /* 11. If s = 0 */
  if (s = 0) {
    /* a. Call SplitMatch(S, 0, R) and let z be its MatchResult result. */
    z := SplitMatch(S, 0, R);
    /* b. If z is not failure, return A. */
    if (!isFailure(z)) {
      return A;
    } else {
      /* c. Call the [[DefineOwnProperty]] internal method of A with arguments "0",
      Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true,
       [[Configurable]]: true}, and false. */
      {A.DefineOwnProperty}(A, "0", newDataPropertyDescriptorFull(S, true, true, true), false);
      /* d. Return A. */
      return A;
    }
  }
  /* 12. Let q = p */
  q := p;
  /* 13. Repeat, while q ≠ s */
  while (!(q = s)) {
    /* a. Call SplitMatch(S, q, R) and let z be its MatchResult result. */
    z := SplitMatch(S, q, R);
    /* b. If z is failure, then let q = q+1. */
    if (isFailure(z)) {
      q := q + 1;
    }
    /* c. Else, z is not failure */
    else {
      /* i. z must be a State. Let e be z's endIndex and let cap be z's captures array. */
      e := z.endIndex;
      cap := z.caps;
      /* ii. If e = p, then let q = q+1. */
      if (e = p) {
        q := q + 1;
      }
      /* iii. Else, e ≠ p */
      else {
        /* 1. Let T be a String value equal to the substring of S consisting of
          the characters at positions p (inclusive) through q (exclusive). */
        T := s_substr_u(S, p, q - p);
        /* 2. Call the [[DefineOwnProperty]] internal method of A with arguments
          ToString(lengthA), Property Descriptor {[[Value]]: T, [[Writable]]: true,
          [[Enumerable]]: true, [[Configurable]]: true}, and false. */
        {A.DefineOwnProperty}(A, ToString(lengthA), newDataPropertyDescriptorFull(T, true, true, true), false);
        /* 3. Increment lengthA by 1. */
        lengthA := lengthA + 1.;
        /* 4. If lengthA = lim, return A. */
        if (lengthA = lim)
          return A;
        /* 5. Let p = e. */
        p := e;
        /* 6. Let i = 0. */
        i := 0;
        /* 7. Repeat, while i is not equal to the number of elements in cap. */
        len := cap.len;
        while (!(i = len)) {
          /* a. Let i = i+1. */
          i := i + 1;
          /* b. Call the [[DefineOwnProperty]] internal method of A with arguments
            ToString(lengthA), Property Descriptor {[[Value]]: cap[i], [[Writable]]:
            true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
          i_str := int_to_string i;
          {A.DefineOwnProperty}(A, ToString(lengthA), newDataPropertyDescriptorFull(cap[i_str], true, true, true), false);
          /* c. Increment lengthA by 1. */
          lengthA := lengthA + 1.;
          /* d. If lengthA = lim, return A. */
          if (lengthA = lim)
            return A;
        }
        /* 8. Let q = p. */
        q := p;
      }
    }
  }
  /* 14. Let T be a String value equal to the substring of S consisting
    of the characters at positions p (inclusive) through s (exclusive). */
  T := s_substr_u(S, p, s - p);
  /* 15. Call the [[DefineOwnProperty]] internal method of A with arguments
    ToString(lengthA), Property Descriptor {[[Value]]: T, [[Writable]]: true,
    [[Enumerable]]: true, [[Configurable]]: true}, and false. */
  {A.DefineOwnProperty}(A, ToString(lengthA), newDataPropertyDescriptorFull(T, true, true, true), false);
  /* 16. Return A. */
  return A;
}
/**
 * The length property of the split method is 2.
 *
 * NOTE 1 The split method ignores the value of separator.global for separators
 * that are RegExp objects.
 *
 * NOTE 2 The split function is intentionally generic; it does not require that
 * its this value be a String object. Therefore, it can be transferred to other
 * kinds of objects for use as a method.
 */


/**
 * The abstract operation SplitMatch takes three parameters, a String S, an
 * integer q, and a String or RegExp R, and performs the following in order
 * to return a MatchResult (see 15.10.2.1):
 */
function SplitMatch (S, q, R) {
  /* 1. If R is a RegExp object (its [[Class]] is "RegExp"), then */
  if (isRegExpObject(R)) {
    /* a. Call the [[Match]] internal method of R giving it the arguments S
      and q, and return the MatchResult result. */
    return {R.Match}(R, S, q);
  }
  /* 2. Type(R) must be String. Let r be the number of characters in R. */
  r := s_len_u (R);
  /* 3. Let s be the number of characters in S. */
  s := s_len_u (S);
  /* 4. If q+r > s then return the MatchResult failure. */
  if ((q + r) > s)
    return null;
  /* 5. If there exists an integer i between 0 (inclusive) and r (exclusive)
    such that the character at position q+i of S is different from the
    character at position i of R, then return failure. */
  i := 0;
  while (!(i = r)) {
    posA := s_nth_u(S, q + i);
    posB := s_nth_u(R, i);
    if (!(posA = posB))
      return null;
    i := i + 1;
  }
  /* 6. Let cap be an empty array of captures (see 15.10.2.1). */
  /* 7. Return the State (q+r, cap). (see 15.10.2.1) */
  return initialState(S, (q + r), false, false, false, 0);
}


/* 15.5.4.15 String.prototype.substring (start, end) */

/*  The substring method takes two arguments, start and end, and returns a substring of the result of converting this object to a String, starting from character position start and running to, but not including, character position end of the String (or through the end of the String is end is undefined). The result is a String value, not a String object.

If either argument is NaN or negative, it is replaced with zero; if either argument is larger than the length of the String, it is replaced with the length of the String.

If start is larger than end, they are swapped.

The following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let len be the number of characters in S.

    Let intStart be ToInteger(start).

    If end is undefined, let intEnd be len; else let intEnd be ToInteger(end).

    Let finalStart be min(max(intStart, 0), len).

    Let finalEnd be min(max(intEnd, 0), len).

    Let from be min(finalStart, finalEnd).

    Let to be max(finalStart, finalEnd).

    Return a String whose length is to - from, containing characters from S, namely the characters with indices from through to −1, in ascending order.

The length property of the substring method is 2.

NOTE The substring function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypesubstring (global, this, strict, args) {
  start := l_nth(args, 0);
  end := l_nth(args, 1);

  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument.*/
  S := ToString(this);
  /* Let len be the number of characters in S. */
  len := int_to_float s_len_u(S);
  /* Let intStart be ToInteger(start). */
  intStart := ToInteger(start);
  /* If end is undefined, let intEnd be len; else let intEnd be ToInteger(end). */
  if (end = 'undefined) 
    intEnd := len; 
  else 
    intEnd := ToInteger(end);
  /* Let finalStart be min(max(intStart, 0), len).*/
  finalStart := min(max(intStart, 0.), len);
  /* Let finalEnd be min(max(intEnd, 0), len). */
  finalEnd := min(max(intEnd, 0.), len);
  /* Let from be min(finalStart, finalEnd). */
  from := min(finalStart, finalEnd);
  /* Let to be max(finalStart, finalEnd). */
  to := max(finalStart, finalEnd);
  /* Return a String whose length is to - from, containing characters from S,
  namely the characters with indices from through to −1, in ascending order. */
  substring := "";
  j := from;
  while (j < to) {
    substring := s_concat ([substring, s_nth_u (S, int_of_float j)]);
    j := j + 1.;
  }

  return substring;

}



/* 15.5.4.16 String.prototype.toLowerCase ( ) */
/* The following steps are taken:

  1. Call CheckObjectCoercible passing the this value as its argument.

  2. Let S be the result of calling ToString, giving it the this value as its argument.

  3. Let L be a String where each character of L is either the Unicode lowercase equivalent
    of the corresponding character of S or the actual corresponding character of S
    if no Unicode lowercase equivalent exists.

  4. Return L.

For the purposes of this operation, the 16-bit code units of the Strings
are treated as code points in the Unicode Basic Multilingual Plane.
Surrogate code points are directly transferred from S to L without any mapping.

The result must be derived according to the case mappings in the Unicode character database
(this explicitly includes not only the UnicodeData.txt file,
but also the SpecialCasings.txt file that accompanies it in Unicode 2.1.8 and later).

NOTE 1 The case mapping of some characters may produce multiple characters.
In this case the result String may not be the same length as the source String.
Because both toUpperCase and toLowerCase have context-sensitive behaviour,
the functions are not symmetrical.
In other words, s.toUpperCase().toLowerCase() is not necessarily equal to s.toLowerCase().

NOTE 2 The toLowerCase function is intentionally generic;
it does not require that its this value be a String object.
Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypetoLowerCase (global, this, strict, args) {
  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /*Let L be a String where each character of L is either the Unicode lowercase equivalent
    of the corresponding character of S or the actual corresponding character of S
    if no Unicode lowercase equivalent exists. */
  /*L := to_lower_case (S);*/

  if (!isUnicodeCasingInitialized())
    initializeUnicodeCasing();

  L := "";
  i := 0;
  len := s_len_u (S);
  while (i < len) {
    c := s_nth_u(S, i);

    /* For some reason, a mapping may be present in both files. In this case, use the
    one in SpecialCasing.txt, except if it has a condition */
    j := 0;
    sc_len := l_len |specialCasing|;
    while (j < sc_len) {
      el := l_nth(|specialCasing|, j);
      if ((c = el.code) &&& !(el.lowercase = 'undefined)) {
        if (el.condition_list = 'undefined) {
          c := el.lowercase;
          j := sc_len + 1;
        } else if ((el.condition_list = "Final_Sigma") &&& (len > 1)) {
          if (i = (len - 1)) {
            if ((len = 2) &&& (s_nth_u(S, (i - 1)) = "\u{0345}")) {
              /* Don't use special casing */
              j := sc_len - 1;
            } else {
              c := el.lowercase;
              j := sc_len + 1;
            }            
          } else {
            nextC := s_nth_u(S, (i + 1));
            if ((i < (len - 2)) &&& (nextC = "\u{0345}")) {
              /* Don't use special casing */
              j := sc_len - 1;
            }
            else if (nextC = "\u{0345}") {
              c := el.lowercase;
              j := sc_len + 1;
            }
          }
        }
      }
      j := j + 1;
    }

    if ((j <= sc_len) &&& (c in_obj |unicodeData|) &&& !(|unicodeData|[c].lowercase = 'undefined))
      c := |unicodeData|[c].lowercase;
    L := s_concat([L, c]);
    i := i + 1;
  }


  /* Return L. */
  return L;
}

/* 15.5.4.17 String.prototype.toLocaleLowerCase ( ) */
/* This function works exactly the same as toLowerCase except that its result is intended
to yield the correct result for the host environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where the rules for that
language conflict with the regular Unicode case mappings.

NOTE 1 The first parameter to this function is likely to be used in a future version of this standard;
it is recommended that implementations do not use this parameter position for anything else.

NOTE 2 The toLocaleLowerCase function is intentionally generic; it does not require that its this value be a String object.
Therefore, it can be transferred to other kinds of objects for use as a method. */

function StringPrototypetoLocaleLowerCase (global, this, strict, args) {
  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /*Let L be a String where each character of L is either the Unicode lowercase equivalent
    of the corresponding character of S or the actual corresponding character of S
    if no Unicode lowercase equivalent exists. */
  /*L := to_lower_case (S);*/
  
  /* TO DO -> Passar isto tendo em conta a linguagem do ambiente */

  if (!isUnicodeCasingInitialized())
    initializeUnicodeCasing();

  L := "";
  i := 0;
  len := s_len_u (S);
  while (i < len) {
    c := s_nth_u(S, i);

    /* For some reason, a mapping may be present in both files. In this case, use the
    one in SpecialCasing.txt, except if it has a condition */
    j := 0;
    sc_len := l_len |specialCasing|;
    while (j < sc_len) {
      el := l_nth(|specialCasing|, j);
      if ((c = el.code) &&& !(el.lowercase = 'undefined)) {
        if (el.condition_list = 'undefined) {
          c := el.lowercase;
          j := sc_len + 1;
        } else if ((el.condition_list = "Final_Sigma") &&& (len > 1)) {
          if (i = (len - 1)) {
            if ((len = 2) &&& (s_nth_u(S, (i - 1)) = "\u{0345}")) {
              /* Don't use special casing */
              j := sc_len - 1;
            } else {
              c := el.lowercase;
              j := sc_len + 1;
            }            
          } else {
            nextC := s_nth_u(S, (i + 1));
            if ((i < (len - 2)) &&& (nextC = "\u{0345}")) {
              /* Don't use special casing */
              j := sc_len - 1;
            }
            else if (nextC = "\u{0345}") {
              c := el.lowercase;
              j := sc_len + 1;
            }
          }
        }
      }
      j := j + 1;
    }

    if ((j <= sc_len) &&& (c in_obj |unicodeData|) &&& !(|unicodeData|[c].lowercase = 'undefined))
      c := |unicodeData|[c].lowercase;
    L := s_concat([L, c]);
    i := i + 1;
  }


  /* Return L. */
  return L;
}

/* 15.5.4.18 String.prototype.toUpperCase ( ) */
/* This function behaves in exactly the same way as String.prototype.toLowerCase,
except that characters are mapped to their uppercase equivalents as specified in the Unicode Character Database.

NOTE The toUpperCase function is intentionally generic;
it does not require that its this value be a String object.
Therefore, it can be transferred to other kinds of objects for use as a method */

function StringPrototypetoUpperCase (global, this, strict, args) {
  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /*Let L be a String where each character of L is either the Unicode uppercase equivalent
    of the corresponding character of S or the actual corresponding character of S
    if no Unicode uppercase equivalent exists. */
  /*L := to_upper_case (S);*/

  if (!isUnicodeCasingInitialized())
    initializeUnicodeCasing();

  L := "";
  i := 0;
  len := s_len_u (S);
  while (i < len) {
    c := s_nth_u(S, i);

    /* For some reason, a mapping may be present in both files. In this case, use the
    one in SpecialCasing.txt, except if it has a condition */
    j := 0;
    sc_len := l_len |specialCasing|;
    while (j < sc_len) {
      el := l_nth(|specialCasing|, j);
      if ((c = el.code) &&& !(el.uppercase = 'undefined) &&& (el.condition_list = 'undefined)) {
        c := el.uppercase;
        j := sc_len + 1;
      }
      j := j + 1;
    }

    if ((j <= sc_len) &&& (c in_obj |unicodeData|) &&& !(|unicodeData|[c].uppercase = 'undefined))
      c := |unicodeData|[c].uppercase;

    L := s_concat([L, c]);
    i := i + 1;
  }

  /* Return L. */
  return L;
}

/* 15.5.4.19 String.prototype.toLocaleUpperCase ( ) */
/* This function works exactly the same as toUpperCase except that its result is intended to yield
the correct result for the host environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.

NOTE 1 The first parameter to this function is likely to be used in a future version of this standard;
it is recommended that implementations do not use this parameter position for anything else.

NOTE 2 The toLocaleUpperCase function is intentionally generic;
it does not require that its this value be a String object.
Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypetoLocaleUpperCase (global, this, strict, args) {
  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /*Let L be a String where each character of L is either the Unicode lowercase equivalent
    of the corresponding character of S or the actual corresponding character of S
    if no Unicode lowercase equivalent exists. */
  /*L := to_upper_case (S);*/
  
  /* TO DO -> Passar isto tendo em conta a linguagem do ambiente */
  if (!isUnicodeCasingInitialized())
    initializeUnicodeCasing();

  L := "";
  i := 0;
  len := s_len_u (S);
  while (i < len) {
    c := s_nth_u(S, i);

    /* For some reason, a mapping may be present in both files. In this case, use the
    one in SpecialCasing.txt, except if it has a condition */
    j := 0;
    sc_len := l_len |specialCasing|;
    while (j < sc_len) {
      el := l_nth(|specialCasing|, j);
      if ((c = el.code) &&& !(el.uppercase = 'undefined) &&& (el.condition_list = 'undefined)) {
        c := el.uppercase;
        j := sc_len + 1;
      }
      j := j + 1;
    }

    if ((j <= sc_len) &&& (c in_obj |unicodeData|) &&& !(|unicodeData|[c].uppercase = 'undefined))
      c := |unicodeData|[c].uppercase;
    L := s_concat([L, c]);
    i := i + 1;
  }


  /* Return L. */
  return L;
}


function isSpaceCharacter(c) {
  /* Table 2 — Whitespace Characters
      Code Unit            Value Name          Formal Name
      \u0009               Tab                 <TAB>
      \u000B               Vertical Tab        <VT>
      \u000C               Form Feed           <FF>
      \u0020               Space               <SP>
      \u00A0               No-break space      <#x0a>
      \uFEFF               Byte Order Mark     <BOM>
      Other category “Zs”  Any other Unicode   <USP>
                           “space separator” */

  /* https://www.compart.com/en/unicode/category/Zs */
  /*
   * \u0020 \u00A0 \u1680 \u2000 \u2001 \u2002
   * \u2003 \u2004 \u2005 \u2006 \u2007 \u2008
   * \u2009 \u200A \u202F \u205F \u3000
   */

  /* Table 3 — Line Terminator Characters
    Code Unit Value       Name                  Formal Name
    \u000A                Line Feed             <LF>
    \u000D                Carriage Return       <CR>
    \u2028                Line separator        <LS>
    \u2029                Paragraph separator   <PS> */
  spaces := ["\t", "\v", "\f", " ", "\u{00A0}", "\u{FEFF}", "\u{1680}", "\u{2000}",
    "\u{2001}", "\u{2002}", "\u{2003}", "\u{2004}", "\u{2005}", "\u{2006}", "\u{2007}",
    "\u{2008}", "\u{2009}", "\u{200A}", "\u{202F}", "\u{205F}", "\u{3000}", "\n", "\r",
    "\u{2028}", "\u{2029}"];
  foreach (s : spaces)
    if (s = c)
      return true;
  return false;
}


/* 15.5.4.20 String.prototype.trim ( ) */
/*The following steps are taken:*/
function StringPrototypeTrim (global, this, strict, args) {
  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let T be a String value that is a copy of S with both leading and trailing white space removed.
     The definition of white space is the union of WhiteSpace and LineTerminator. */
  /*T := trim (S);*/

  T := S;
  /* TODO: use the auxiliary functions created in section_15.1 */
  /* Remove leading spaces */
  if (!(T = "")) {
    len := s_len_u (T);
    i := 0;
    j := 0;
    while (i < len) {
      c := s_nth_u(T, j);
      if (isSpaceCharacter(c))
        j := j + 1;
      else
        i := len;
      i := i + 1;
    }

    T := s_substr_u(T, j, (len - j));
  }

  /* TODO: use the auxiliary functions created in section_15.1 */
  /* Remove trailing spaces */
  if (!(T = "")) {
    len := s_len_u (T);
    i := len - 1;
    j := len - 1;
    while (i >= 0) {
      c := s_nth_u(T, j);
      if (isSpaceCharacter(c))
        j := j - 1;
      else
        i := -1;
      i := i - 1;
    }
    T := s_substr_u(T, 0, (j + 1));
  }

  /* Return T. */
  return T;

}


/* 15.5.5.2 [[GetOwnProperty]] ( P ) */
/*
String objects use a variation of the [[GetOwnProperty]] internal method used for other native ECMAScript objects (8.12.1).
This special internal method is used to add access for named properties corresponding to individual characters of String objects.

Assume S is a String object and P is a String.

When the [[GetOwnProperty]] internal method of S is called with property name P, the following steps are taken:

   Let desc be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on S with argument P.

   If desc is not undefined return desc.

   If ToString(abs(ToInteger(P))) is not the same value as P, return undefined.

   Let str be the String value of the [[PrimitiveValue]] internal property of S.

   Let index be ToInteger(P).

   Let len be the number of characters in str.

   If len ≤ index, return undefined.

   Let resultStr be a String of length 1, containing one character from str,
   specifically the character at position index, where the first (leftmost) character
   in str is considered to be at position 0, the next one at position 1, and so on.

   Return a Property Descriptor { [[Value]]: resultStr, [[Enumerable]]: true,
    [[Writable]]: false, [[Configurable]]: false }
*/

function GetOwnPropertyString (S, P) {
  /* Assume S is a String object and P is a String. */
  /* Let desc be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on S with argument P. */
  desc := GetOwnProperty (S, P);
  /*   If desc is not undefined return desc. */
  if (!(desc = 'undefined))
    return desc;
  /* If ToString(abs(ToInteger(P))) is not the same value as P, return undefined. */
  if (!((ToString(abs(ToInteger(P)))) = P))
    return 'undefined;
  /* Let str be the String value of the [[PrimitiveValue]] internal property of S. */
  str := S.PrimitiveValue;
  /* Let index be ToInteger(P).*/
  index := ToInteger(P);
  /* Let len be the number of characters in str. */
  len := s_len_u(str);
  /* If len ≤ index, return undefined. */
  if ((int_to_float len) <= index)
    return 'undefined;
  /*    Let resultStr be a String of length 1, containing one character from str,
     specifically the character at position index, where the first (leftmost) character
     in str is considered to be at position 0, the next one at position 1, and so on. */
  resultStr := s_nth_u (str, int_of_float index);
  /* Return a Property Descriptor { [[Value]]: resultStr, [[Enumerable]]: true,
   [[Writable]]: false, [[Configurable]]: false } */
   return newDataPropertyDescriptorFull(resultStr, false, true, false);
}

/* Auxiliary function */
function isStringOrStringObject(arg) {
  if (Type(arg) = "String")
    return true;
  if ((Type(arg) = "Object") &&& (getInternalProperty(arg, "Class") = "String"))
    return true;
  return false;
}

function setAllInternalMethodsOfString(str) {
  setAllInternalMethodsOfObject(str);
  str.GetOwnProperty := "GetOwnPropertyString";
  return str;
}
