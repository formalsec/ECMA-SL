
/**
 * 15.4 Array Objects
 *
 * Array objects give special treatment to a certain class of property names.
 * A property name P (in the form of a String value) is an array index if and
 * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to
 * 2^32 − 1. A property whose property name is an array index is also called
 * an element. Every Array object has a length property whose value is always
 * a nonnegative integer less than 2^32. The value of the length property is
 * numerically greater than the name of every property whose name is an array
 * index; whenever a property of an Array object is created or changed, other
 * properties are adjusted as necessary to maintain this invariant.
 * Specifically, whenever a property is added whose name is an array index,
 * the length property is changed, if necessary, to be one more than the
 * numeric value of that array index; and whenever the length property is
 * changed, every property whose name is an array index whose value is not
 * smaller than the new length is automatically deleted. This constraint
 * applies only to own properties of an Array object and is unaffected by
 * length or array index properties that may be inherited from its prototypes.
 */



/* An object, O, is said to be sparse if the following algorithm returns true: */
function isSparseArray(O) {
  /* 1. Let len be the result of calling the [[Get]] internal method of O with
        argument "length". */
  len := {O.Get}(O, "length");
  /* 2. For each integer i in the range 0≤i<ToUint32(len) */
  i := 0;
  lenUint := ToUint32(len);

  while (i < lenUint) {
    /* a. Let elem be the result of calling the [[GetOwnProperty]] internal
          method of O with argument ToString(i). */
    elem := {O.GetOwnProperty}(O, ToString(i));
    /* b. If elem is undefined, return true. */
    if (elem = 'undefined)
      return true;
  }

  /* 3. Return false. */
  return false;
}

/**
 * A property name P (in the form of a String value) is an array index if and
 * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to 2^32−1.
 */
function IsArrayIndex(P) {
  p_uint := ToUint32(P);
  p_str := ToString(p_uint);
  return ((p_str = P) && !(p_uint = ((2. ** 32.) - 1.) )); /* (2^32)-1 = 4294967295 */
}

function getArrayPrototype(strict) {
  refArray := newPropertyReference(|global|, "Array", strict);
  ArrayObject := GetValue(refArray);
  refArrayProto := newPropertyReference(ArrayObject, "prototype", strict);
  objectArrayProto := GetValue(refArrayProto);
  return objectArrayProto;
}

function setAllInternalMethodsOfArray(arr) {
  setAllInternalMethodsOfObject(arr);
  arr.DefineOwnProperty := "DefineOwnPropertyArray";
  return arr;
}



/**
 * 15.4.4 Properties of the Array Prototype Object
 *
 * The value of the [[Prototype]] internal property of the Array prototype object
 * is the standard built-in Object prototype object (15.2.4).
 *
 * The Array prototype object is itself an array; its [[Class]] is "Array", and it
 * has a length property (whose initial value is +0) and the special [[DefineOwnProperty]]
 * internal method described in 15.4.5.1.
 *
 * In following descriptions of functions that are properties of the Array prototype
 * object, the phrase "this object" refers to the object that is the this value for
 * the invocation of the function. It is permitted for the this to be an
 * object for which the value of the [[Class]] internal property is not "Array".
 *
 * NOTE The Array prototype object does not have a valueOf property of its own; however,
 * it inherits the valueOf property from the standard built-in Object prototype Object.
 */
function initArrayPrototype(global, objectPrototype, strict) {
  prototype := NewECMAScriptObjectFull(objectPrototype, "Array", true);
  setAllInternalMethodsOfArray(prototype);

  setJSProperty(prototype, "length", newDataPropertyDescriptorFull(0., true, false, false));

  /* Add built-in function objects to array's prototype */

  /* 15.4.4.2 Array.prototype.toString ( ) */
  toStringObject := CreateBuiltInFunctionObject([], "arrayToString", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(toStringObject, true, false, true);
  setJSProperty(prototype, "toString", descriptor);

  /* 15.4.4.3 Array.prototype.toLocaleString ( ) */
  toLocaleStringObject := CreateBuiltInFunctionObject([], "arrayToLocaleString", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(toLocaleStringObject, true, false, true);
  setJSProperty(prototype, "toLocaleString", descriptor);

  /* 15.4.4.4 Array.prototype.concat ( [ item1 [ , item2 [ , ... ] ] ] ) */
  /* We pass 0 to the `internalLength` because while `items` is optional, the length of the
     function is 1. We have `items` in the `FormalParameterList` which makes the length of
     the function to be 1, but if we did not have the `internalLength` to be 0, then
     'undefined would be passed to items when no parameter is provided to `concat`, and
     this is not desired for optional parameters. */
  concatObject := CreateBuiltInFunctionObject(["items"], "arrayConcat", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(concatObject, true, false, true);
  setJSProperty(prototype, "concat", descriptor);

  /* 15.4.4.5 Array.prototype.join (separator) */
  joinObject := CreateBuiltInFunctionObject(["separator"], "arrayJoin", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(joinObject, true, false, true);
  setJSProperty(prototype, "join", descriptor);

  /* 15.4.4.6 Array.prototype.pop ( ) */
  popObject := CreateBuiltInFunctionObject([], "arrayPop", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(popObject, true, false, true);
  setJSProperty(prototype, "pop", descriptor);

  /* 15.4.4.7 Array.prototype.push ( [ item1 [ , item2 [ , ... ] ] ] ) */
  pushObject := CreateBuiltInFunctionObject(["items"], "arrayPush", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(pushObject, true, false, true);
  setJSProperty(prototype, "push", descriptor);

  /* 15.4.4.8 Array.prototype.reverse ( ) */
  reverseObject := CreateBuiltInFunctionObject([], "arrayReverse", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(reverseObject, true, false, true);
  setJSProperty(prototype, "reverse", descriptor);

  /* 15.4.4.9 Array.prototype.shift ( ) */
  shiftObject := CreateBuiltInFunctionObject([], "arrayShift", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(shiftObject, true, false, true);
  setJSProperty(prototype, "shift", descriptor);

  /* 15.4.4.10 Array.prototype.slice (start, end) */
  sliceObject := CreateBuiltInFunctionObject(["start", "end"], "arraySlice", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(sliceObject, true, false, true);
  setJSProperty(prototype, "slice", descriptor);

  /* 15.4.4.11 Array.prototype.sort (comparefn) */
  sortObject := CreateBuiltInFunctionObject(["comparefn"], "arraySort", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(sortObject, true, false, true);
  setJSProperty(prototype, "sort", descriptor);

  /* 15.4.4.12 Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , ... ] ] ] ) */
  spliceObject := CreateBuiltInFunctionObject(["start", "deleteCount"], "arraySplice", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(spliceObject, true, false, true);
  setJSProperty(prototype, "splice", descriptor);

  /* 15.4.4.13 Array.prototype.unshift ( [ item1 [ , item2 [ , ... ] ] ] ) */
  unshiftObject := CreateBuiltInFunctionObject(["items"], "arrayUnshift", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(unshiftObject, true, false, true);
  setJSProperty(prototype, "unshift", descriptor);

  /* 15.4.4.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] ) */
  indexOfObject := CreateBuiltInFunctionObject(["searchElement"], "arrayIndexOf", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(indexOfObject, true, false, true);
  setJSProperty(prototype, "indexOf", descriptor);

  /* 15.4.4.15 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] ) */
  lastIndexOfObject := CreateBuiltInFunctionObject(["searchElement"], "arrayLastIndexOf", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(lastIndexOfObject, true, false, true);
  setJSProperty(prototype, "lastIndexOf", descriptor);

  /* 15.4.4.16 Array.prototype.every ( callbackfn [ , thisArg ] ) */
  everyOfObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayEvery", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(everyOfObject, true, false, true);
  setJSProperty(prototype, "every", descriptor);

  /* 15.4.4.17 Array.prototype.some ( callbackfn [ , thisArg ] ) */
  someOfObject := CreateBuiltInFunctionObject(["callbackfn"], "arraySome", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(someOfObject, true, false, true);
  setJSProperty(prototype, "some", descriptor);

  /* 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] ) */
  forEachObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayForEach", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(forEachObject, true, false, true);
  setJSProperty(prototype, "forEach", descriptor);

  /* 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] ) */
  mapObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayMap", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(mapObject, true, false, true);
  setJSProperty(prototype, "map", descriptor);

  /* 15.4.4.20 Array.prototype.filter ( callbackfn [ , thisArg ] ) */
  filterObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayFilter", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(filterObject, true, false, true);
  setJSProperty(prototype, "filter", descriptor);

  /* 15.4.4.21 Array.prototype.reduce ( callbackfn [ , initialValue ] ) */
  reduceObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayReduce", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(reduceObject, true, false, true);
  setJSProperty(prototype, "reduce", descriptor);

  /* 15.4.4.22 Array.prototype.reduceRight ( callbackfn [ , initialValue ] ) */
  reduceRightObject := CreateBuiltInFunctionObject(["callbackfn"], "arrayReduceRight", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(reduceRightObject, true, false, true);
  setJSProperty(prototype, "reduceRight", descriptor);

  return prototype;
}



function initArrayObject(global, objectPrototype, strict) {
  objArrayPrototype := initArrayPrototype(global, objectPrototype, strict);
  objArrayConstructor := CreateFunctionObject(["items"], "ArrayConstructor", global, strict, 0.);

  descriptor := newDataPropertyDescriptorFull(objArrayConstructor, true, false, true);
  setJSProperty(objArrayPrototype, "constructor", descriptor);

  /* 15.4.3.2 Array.isArray ( arg ) */
  isArrayObject := CreateBuiltInFunctionObject(["arg"], "isArray", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(isArrayObject, true, false, true);
  setJSProperty(objArrayConstructor, "isArray", descriptor);

  descriptor := newDataPropertyDescriptorFull(objArrayPrototype, false, false, false);
  setJSProperty(objArrayConstructor, "prototype", descriptor);

  return objArrayConstructor;
}





/**
 * 15.4.1 The Array Constructor Called as a Function
 *
 * When Array is called as a function rather than as a constructor, it
 * creates and initialises a new Array object. Thus the function call
 * Array(…) is equivalent to the object creation expression new Array(…)
 * with the same arguments.
 */

/**
 * 15.4.1.1 Array ( [ item1 [ , item2 [ , … ] ] ] )
 *
 * When the Array function is called the following steps are taken:
 *
 * Create and return a new Array object exactly as if the standard
 * built-in constructor Array was used in a new expression with the
 * same arguments (15.4.2).
 */

/**
 * 15.4.2 The Array Constructor
 *
 * When Array is called as part of a new expression, it is a constructor:
 * it initialises the newly created object.
 */




/**
 * 15.4.2.1 new Array ( [ item0 [ , item1 [ , … ] ] ] ) # Ⓣ
 * This description applies if and only if the Array constructor is given
 * no arguments or at least two arguments.
 */
function ArrayConstructor(global, this, strict, items) {
  prototype := getArrayPrototype(strict);
  if ((l_len items) = 1) {
    len := l_nth (items, 0);
    return internalNewArrayLen(prototype, len);
  }
  return internalNewArray(prototype, items);
}

function internalNewArray(arrayPrototype, items) {
  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfArray(newlyConstructedObject);

  /* The [[Prototype]] internal property of the newly constructed object
      is set to the original Array prototype object, the one that is the
      initial value of Array.prototype (15.4.3.1). */
  setInternalProperty(newlyConstructedObject, "Prototype", arrayPrototype);
  /* The [[Extensible]] internal property of the newly constructed object
      is set to true. */
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  /* The [[Class]] internal property of the newly constructed object is
      set to "Array". */
  setInternalProperty(newlyConstructedObject, "Class", "Array");

  i := 0;
  /* The length property of the newly constructed object is set to the
     number of arguments. */
  len := l_len items;
  createBuiltInPropertyWithFullDescriptor(newlyConstructedObject, "length", ToUint32(int_to_float len), true, false, false);

  /* The 0 property of the newly constructed object is set to item0
     (if supplied); the 1 property of the newly constructed object is set
     to item1 (if supplied); and, in general, for as many arguments as there
     are, the k property of the newly constructed object is set to argument k,
     where the first argument is considered to be argument number 0. These
     properties all have the attributes {[[Writable]]: true,
     [[Enumerable]]: true, [[Configurable]]: true}. */
  while (i < len) {
    i_str := int_to_string i;
    createBuiltInPropertyWithFullDescriptor(newlyConstructedObject, i_str, l_nth (items, i), true, true, true);
    i := i + 1;
  }

  return newlyConstructedObject;
}




/**
 * 15.4.2.2 new Array (len)
 */
function internalNewArrayLen(arrayPrototype, len) {
  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfArray(newlyConstructedObject);

  /* The [[Prototype]] internal property of the newly constructed object
      is set to the original Array prototype object, the one that is the
      initial value of Array.prototype (15.4.3.1). */
  setInternalProperty(newlyConstructedObject, "Prototype", arrayPrototype);
  /* The [[Extensible]] internal property of the newly constructed object
      is set to true. */
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  /* The [[Class]] internal property of the newly constructed object is
      set to "Array". */
  setInternalProperty(newlyConstructedObject, "Class", "Array");

  lenIsNumber := (typeof (len) = "float");
  /* If the argument len is a Number and ToUint32(len) is equal to len, then
     the length property of the newly constructed object is set to ToUint32(len). */
  if (lenIsNumber &&& ((ToUint32(len) = len)))
    createBuiltInPropertyWithFullDescriptor(newlyConstructedObject, "length", ToUint32(len), true, false, false);

  /* If the argument len is a Number and ToUint32(len) is not equal to
     len, a RangeError exception is thrown. */
  if (lenIsNumber &&& !((ToUint32(len) = len)))
    throw RangeErrorConstructorInternal();

  /* If the argument len is not a Number, then the length property of the
     newly constructed object is set to 1 and the 0 property of the newly
     constructed object is set to len with attributes {[[Writable]]: true,
     [[Enumerable]]: true, [[Configurable]]: true}.. */
  if (!lenIsNumber) {
    createBuiltInPropertyWithFullDescriptor(newlyConstructedObject, "length", ToUint32(1.), true, false, false);
    createBuiltInPropertyWithFullDescriptor(newlyConstructedObject, "0", len, true, true, true);
  }

  return newlyConstructedObject;
}



/**
 * 15.4.3.2 Array.isArray ( arg )
 *
 * The isArray function takes one argument arg, and returns the Boolean
 * value true if the argument is an object whose class internal property
 * is "Array"; otherwise it returns false. The following steps are taken:
 */
function isArray(global, this, strict, args) {
  arg := l_nth(args, 0);
  /* 1. If Type(arg) is not Object, return false. */
  if (!(Type(arg) = "Object"))
    return false;
  /* 2. If the value of the [[Class]] internal property of arg is "Array",
        then return true. */
  if (arg.Class = "Array")
    return true;
  /* 3. Return false. */
  return false;
}




/**
 * 15.4.4.2 Array.prototype.toString ( )
 *
 * When the toString method is called, the following steps are taken:
 */
function arrayToString(global, this, strict, args) {
  /* 1. Let array be the result of calling ToObject on the this value. */
  array := ToObject(this);
  /* 2. Let func be the result of calling the [[Get]] internal method
        of array with argument "join". */
  func := {array.Get}(array, "join");
  /* 3. If IsCallable(func) is false, then let func be the standard
        built-in method Object.prototype.toString (15.2.4.2). */
  if (IsCallable(func) = false)
    func := getObjectPrototypeToString(strict);
  /* 4. Return the result of calling the [[Call]] internal method of func
        providing array as the this value and an empty arguments list. */
  return {func.Call}(null, null, func, array, []);
}
/**
 * NOTE The toString function is intentionally generic; it does not
 * require that its this value be an Array object. Therefore it can be
 * transferred to other kinds of objects for use as a method. Whether
 * the toString function can be applied successfully to a host object
 * is implementation-dependent.
 */




/**
 * 15.4.4.3 Array.prototype.toLocaleString ( )
 *
 * The elements of the array are converted to Strings using their
 * toLocaleString methods, and these Strings are then concatenated,
 * separated by occurrences of a separator String that has been derived
 * in an implementation-defined locale-specific way. The result of calling
 * this function is intended to be analogous to the result of toString,
 * except that the result of this function is intended to be locale-specific.
 *
 * The result is calculated as follows:
 */
function arrayToLocaleString(global, this, strict, args) {
  /* 1. Let O be the result of calling ToObject passing the this value as
        the argument. */
  O := ToObject(this);
  /* 2. Let arrayLen be the result of calling the [[Get]] internal method
        of array with argument "length". */
  arrayLen := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(arrayLen). */
  len := ToUint32(arrayLen);
  /* 4. Let separator be the String value for the list-separator String
        appropriate for the host environment’s current locale (this is
        derived in an implementation-defined way). */
  separator := ","; /* TODO */
  /* 5. If len is zero, return the empty String. */
  if (len = 0.)
    return "";
  /* 6. Let firstElement be the result of calling the [[Get]] internal
        method of array with argument "0". */
  firstElement := {O.Get}(O, "0");
  /* 7. If firstElement is undefined or null, then */
  if ((firstElement = 'undefined) || (firstElement = 'null)) {
    /* a. Let R be the empty String. */
    R := "";
  }
  /* 8. Else */
  else {
    /* a. Let elementObj be ToObject(firstElement). */
    elementObj := ToObject(firstElement);
    /* b. Let func be the result of calling the [[Get]] internal method
          of elementObj with argument "toLocaleString". */
    func := {elementObj.Get}(elementObj, "toLocaleString");
    /* c. If IsCallable(func) is false, throw a TypeError exception. */
    if (IsCallable(func) = false)
      throw TypeErrorConstructorInternal();
    /* d. Let R be the result of calling the [[Call]] internal method of func
          providing elementObj as the this value and an empty arguments list. */
    R := {func.Call}(null, null, func, elementObj, []);
  }
  /* 9. Let k be 1. */
  k := 1.;
  /* 10. Repeat, while k < len */
  while (k < len) {
    /* a. Let S be a String value produced by concatenating R and separator. */
    S := s_concat([ToString(R), separator]);
    /* b. Let nextElement be the result of calling the [[Get]] internal
          method of array with argument ToString(k). */
    nextElement := {O.Get}(O, ToString(k));
    /* c. If nextElement is undefined or null, then */
    if ((nextElement = 'undefined) || (nextElement = 'null)) {
      /* i. Let R be the empty String. */
      R := "";
    }
    /* d. Else */
    else {
      /* i. Let elementObj be ToObject(nextElement). */
      elementObj := ToObject(nextElement);
      /* ii. Let func be the result of calling the [[Get]] internal method of
             elementObj with argument "toLocaleString". */
      func := {elementObj.Get}(elementObj, "toLocaleString");
      /* iii. If IsCallable(func) is false, throw a TypeError exception. */
      if (IsCallable(func) = false)
        throw TypeErrorConstructorInternal();
      /* iv. Let R be the result of calling the [[Call]] internal method of func
             providing elementObj as the this value and an empty arguments list. */
      R := {func.Call}(null, null, func, elementObj, []);
    }
    /* e. Let R be a String value produced by concatenating S and R. */
    R := s_concat([S, ToString(R)]);
    /* f. Increase k by 1. */
    k := k + 1.;
  }
  /* 11. Return R. */
  return R;
}
/**
 * NOTE 1 The first parameter to this function is likely to be used in a
 * future version of this standard; it is recommended that implementations
 * do not use this parameter position for anything else.
 *
 * NOTE 2 The toLocaleString function is intentionally generic; it does not
 * require that its this value be an Array object. Therefore it can be
 * transferred to other kinds of objects for use as a method. Whether the
 * toLocaleString function can be applied successfully to a host object is
 * implementation-dependent.
 */




/**
 * 15.4.4.4 Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] )
 *
 * When the concat method is called with zero or more arguments item1, item2,
 * etc., it returns an array containing the array elements of the object
 * followed by the array elements of each argument in order.
 *
 * The following steps are taken:
 */
function arrayConcat(global, this, strict, items) {
  /* 1. Let O be the result of calling ToObject passing the this value
        as the argument. */
  O := ToObject(this);
  /* 2. Let A be a new array created as if by the expression new Array() where
        Array is the standard built-in constructor with that name. */
  A := ArrayConstructor(global, this, strict, []);
  /* 3. Let n be 0. */
  n := int_to_float 0;

  /* 4. Let items be an internal List whose first element is O and whose
        subsequent elements are, in left to right order, the arguments that
        were passed to this function invocation. */
  items := l_prepend(O, items);

  /* 5. Repeat, while items is not empty */
  while (!(items = [])) {
    /* a. Remove the first element from items and let E be the value of the
          element. */
    E := hd items;
    items := tl items;

    /* b. If the value of the [[Class]] internal property of E is "Array",
          then */
    if ((typeof (E) = "object") &&& (E.Class = "Array")) {
      /* i. Let k be 0. */
      k := int_to_float 0;
      /* ii. Let len be the result of calling the [[Get]] internal method
             of E with argument "length". */
      len := {E.Get}(E, "length");

      /* iii. Repeat, while k < len */
      while (k < len) {
        /* 1. Let P be ToString(k). */
        P := ToString(k);
        /* 2. Let exists be the result of calling the [[HasProperty]]
              internal method of E with P. */
        exists := {E.HasProperty}(E, P);
        /* 3. If exists is true, then */
        if (exists = true) {
          /* a. Let subElement be the result of calling the [[Get]] internal
                method of E with argument P. */
          subElement := {E.Get}(E, P);
          /* b. Call the [[DefineOwnProperty]] internal method of A with
                arguments ToString(n), Property Descriptor {[[Value]]:
                subElement, [[Writable]]: true, [[Enumerable]]: true,
                [[Configurable]]: true}, and false.*/
          descriptor := newDataPropertyDescriptorFull(subElement, true, true, true);
          {A.DefineOwnProperty}(A, ToString(n), descriptor, false);
        }
        /* 4. Increase n by 1. */
        n := n + 1.;
        /* 5. Increase k by 1. */
        k := k + 1.;
      }
    }
    /* c. Else, E is not an Array */
    else {
      /* i. Call the [[DefineOwnProperty]] internal method of A with
            arguments ToString(n), Property Descriptor {[[Value]]: E,
            [[Writable]]: true, [[Enumerable]]: true,
            [[Configurable]]: true}, and false. */
      descriptor := newDataPropertyDescriptorFull(E, true, true, true);
      {A.DefineOwnProperty}(A, ToString(n), descriptor, false);
      /* ii. Increase n by 1. */
      n := n + 1.;
    }
  }

  /** test/test262/tests/built-ins/Array/prototype/concat/S15.4.4.4_A1_T4.js */
  lenDesc := newDataPropertyDescriptorFull(n, true, false, false);
  {A.DefineOwnProperty}(A, "length", lenDesc, false);

  /* 6. Return A. */
  return A;
}
/**
 * The length property of the concat method is 1.
 *
 * NOTE The concat function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the concat function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.5 Array.prototype.join (separator)
 *
 * The elements of the array are converted to Strings, and these Strings
 * are then concatenated, separated by occurrences of the separator. If
 * no separator is provided, a single comma is used as the separator.
 *
 * The join method takes one argument, separator, and performs the
 * following steps:
 */
/* function join (global, this, [ separator ]) */
function arrayJoin(global, this, strict, args) {
  separator := l_nth(args, 0);

  /* 1. Let O be the result of calling ToObject passing the this value
        as the argument. */
  O := ToObject(this);
  /* 2. Let lenVal be the result of calling the [[Get]] internal method
        of O with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenVal). */
  len := ToUint32(lenVal);
  /* 4. If separator is undefined, let separator be the single-character
        String ",". */
  if (separator = 'undefined)
    separator := ",";
  /* 5. Let sep be ToString(separator). */
  sep := ToString(separator);
  /* 6. If len is zero, return the empty String. */
  if (len = 0.)
    return "";
  /* 7. Let element0 be the result of calling the [[Get]] internal method
        of O with argument "0". */
  element0 := {O.Get}(O, "0");
  /* 8. If element0 is undefined or null, let R be the empty String;
        otherwise, Let R be ToString(element0). */
  if ((element0 = 'undefined) || (element0 = 'null))
    R := "";
  else
    R := ToString(element0);
  /* 9. Let k be 1. */
  k := 1.;
  /* 10. Repeat, while k < len */
  while (k < len) {
    /* a. Let S be the String value produced by concatenating R and sep. */
    S := s_concat([R, sep]);
    /* b. Let element be the result of calling the [[Get]] internal method
          of O with argument ToString(k). */
    element := {O.Get}(O, ToString(k));
    /* c. If element is undefined or null, Let next be the empty String;
          otherwise, let next be ToString(element). */
    if ((element = 'undefined) || (element = 'null)) 
      next := "";
    else
      next := ToString(element);
    /* d. Let R be a String value produced by concatenating S and next. */
    R := s_concat([S, next]);
    /* e. Increase k by 1. */
    k := k + 1.;
  }
  /* 11. Return R. */
  return R;
}
/**
 * The length property of the join method is 1.
 *
 * NOTE The join function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore, it can be transferred
 * to other kinds of objects for use as a method. Whether the join function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.6 Array.prototype.pop ( )
 *
 * The last element of the array is removed from the array and returned.
 */
function arrayPop(global, this, strict, args) {
  /* 1. Let O be the result of calling ToObject passing the this value
        as the argument. */
  O := ToObject(this);
  /* 2. Let lenVal be the result of calling the [[Get]] internal method of
        O with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenVal). */
  len := ToUint32(lenVal);

  /* 4. If len is zero, */
  if (len = 0.) {
    /* a. Call the [[Put]] internal method of O with arguments "length",
          0, and true. */
    {O.Put}(O, "length", 0., true);
    /* b. Return undefined. */
    return 'undefined;
  }
  /* 5. Else, len > 0 */
  else {
    if (len > 0.) {
      /* a. Let indx be ToString(len–1). */
      indx := ToString(len - 1.);
      /* b. Let element be the result of calling the [[Get]] internal method
            of O with argument indx. */
      element := {O.Get}(O, indx);
      /* c. Call the [[Delete]] internal method of O with arguments indx
            and true. */
      {O.Delete}(O, indx, true);
      /* d. Call the [[Put]] internal method of O with arguments "length",
            indx, and true. */
      /* POSSIBLE ERROR IN THE STANDARD
        len - 1 instead of indx.*/
      {O.Put}(O, "length", len - 1., true);
      /* e. Return element. */
      return element;
    }
  }
}
/**
 * NOTE The pop function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the pop function can be applied
 * successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.7 Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )
 *
 * The arguments are appended to the end of the array, in the order in which
 * they appear. The new length of the array is returned as the result of the call.
 *
 * When the push method is called with zero or more arguments item1,item2, etc.,
 * the following steps are taken:
 */
function arrayPush(global, this, strict, items) {
  /* 1. Let O be the result of calling ToObject passing the this value as the
        argument. */
  O := ToObject(this);
  /* 2. Let lenVal be the result of calling the [[Get]] internal method of O
        with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let n be ToUint32(lenVal). */
  n := ToUint32(lenVal);
  /* 4. Let items be an internal List whose elements are, in left to right
        order, the arguments that were passed to this function invocation. */
  items := items;
  /* 5. Repeat, while items is not empty */
  while (!(items = [])) {
    /* a. Remove the first element from items and let E be the value of
          the element. */
    E := hd items;
    items := tl items;
    /* b. Call the [[Put]] internal method of O with arguments ToString(n),
          E, and true. */
    {O.Put}(O, ToString(n), E, true);
    /* c. Increase n by 1. */
    n := n + 1.;
  }
  /* 6. Call the [[Put]] internal method of O with arguments "length", n,
        and true. */
  {O.Put}(O, "length", n, true);
  /* 7. Return n. */
  return n;
}
/**
 * The length property of the push method is 1.
 *
 * NOTE The push function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the push function can be applied
 * successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.8 Array.prototype.reverse ( )
 *
 * The elements of the array are rearranged so as to reverse their order.
 * The object is returned as the result of the call.
 */
function arrayReverse(global, this, strict, args) {
  /* 1. Let O be the result of calling ToObject passing the this value as
        the argument. */
  O := ToObject(this);
  /* 2. Let lenVal be the result of calling the [[Get]] internal method of O
        with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenVal). */
  len := ToUint32(lenVal);
  /* 4. Let middle be floor(len/2). */
  middle := floor(len / 2.);
  /* 5. Let lower be 0. */
  lower := 0.;
  /* 6. Repeat, while lower ≠ middle */
  while (!(lower = middle)) {
    /* a. Let upper be len−lower −1. */
    upper := len - lower - 1.;
    /* b. Let upperP be ToString(upper). */
    upperP := ToString(upper);
    /* c. Let lowerP be ToString(lower). */
    lowerP := ToString(lower);
    /* d. Let lowerValue be the result of calling the [[Get]] internal
          method of O with argument lowerP. */
    lowerValue := {O.Get}(O, lowerP);
    /* e. Let upperValue be the result of calling the [[Get]] internal
          method of O with argument upperP . */
    upperValue := {O.Get}(O, upperP);
    /* f. Let lowerExists be the result of calling the [[HasProperty]]
          internal method of O with argument lowerP. */
    lowerExists := {O.HasProperty}(O, lowerP);
    /* g. Let upperExists be the result of calling the [[HasProperty]]
          internal method of O with argument upperP. */
    upperExists := {O.HasProperty}(O, upperP);
    /* h. If lowerExists is true and upperExists is true, then */
    if (lowerExists = true &&& upperExists = true) {
      /* i. Call the [[Put]] internal method of O with arguments lowerP,
            upperValue, and true . */
      {O.Put}(O, lowerP, upperValue, true);
      /* ii. Call the [[Put]] internal method of O with arguments upperP,
             lowerValue, and true . */
      {O.Put}(O, upperP, lowerValue, true);
    }
    /* i. Else if lowerExists is false and upperExists is true, then */
    elif (lowerExists = false &&& upperExists = true) {
      /* i. Call the [[Put]] internal method of O with arguments lowerP,
            upperValue, and true . */
      {O.Put}(O, lowerP, upperValue, true);
      /* ii. Call the [[Delete]] internal method of O, with arguments upperP
            and true. */
      {O.Delete}(O, upperP, true);
    }
    /* j. Else if lowerExists is true and upperExists is false, then */
    elif (lowerExists = true &&& upperExists = false) {
      /* i. Call the [[Delete]] internal method of O, with arguments lowerP
            and true . */
      {O.Delete}(O, lowerP, true);
      /* ii. Call the [[Put]] internal method of O with arguments upperP,
            lowerValue, and true . */
      {O.Put}(O, upperP, lowerValue, true);
    } else {
      /* k. Else, both lowerExists and upperExists are false */
      /* i. No action is required. */
    }
    /* l. Increase lower by 1. */
    lower := lower + 1.;
  }
  /* 7. Return O . */
  return O;
}
/**
 * NOTE The reverse function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore, it can be transferred
 * to other kinds of objects for use as a method. Whether the reverse function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.9 Array.prototype.shift ( )
 *
 * The first element of the array is removed from the array and returned.
 */
function arrayShift(global, this, strict, args) {
  /* 1. Let O be the result of calling ToObject passing the this value
        as the argument. */
  O := ToObject(this);
  /* 2. Let lenVal be the result of calling the [[Get]] internal method
        of O with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenVal). */
  len := ToUint32(lenVal);
  /* 4. If len is zero, then */
  if (len = 0.) {
    /* a. Call the [[Put]] internal method of O with arguments "length",
          0, and true. */
    {O.Put}(O, "length", 0., true);
    /* b. Return undefined. */
    return 'undefined;
  }
  /* 5. Let first be the result of calling the [[Get]] internal method
        of O with argument "0". */
  first := {O.Get}(O, "0");
  /* 6. Let k be 1. */
  k := 1.;
  /* 7. Repeat, while k < len */
  while (k < len) {
    /* a. Let from be ToString(k). */
    from := ToString(k);
    /* b. Let to be ToString(k–1). */
    to := ToString(k - 1.);
    /* c. Let fromPresent be the result of calling the [[HasProperty]]
          internal method of O with argument from. */
    fromPresent := {O.HasProperty}(O, from);
    /* d. If fromPresent is true, then */
    if (fromPresent = true) {
      /* i. Let fromVal be the result of calling the [[Get]] internal
            method of O with argument from. */
      fromVal := {O.Get}(O, from);
      /* ii. Call the [[Put]] internal method of O with arguments to,
             fromVal, and true. */
      {O.Put}(O, to, fromVal, true);
    }
    /* e. Else, fromPresent is false */
    else {
      /* i. Call the [[Delete]] internal method of O with arguments to
            and true. */
      {O.Delete}(O, to, true);
    }
    /* f. Increase k by 1. */
    k := k + 1.;
  }
  /* 8. Call the [[Delete]] internal method of O with arguments
        ToString(len–1) and true. */
  {O.Delete}(O, ToString(len - 1.), true);
  /* 9. Call the [[Put]] internal method of O with arguments "length",
        (len–1) , and true. */
  {O.Put}(O, "length", len - 1., true);
  /* 10. Return first. */
  return first;
}
/**
 * NOTE The shift function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the shift function can be applied
 * successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.10 Array.prototype.slice (start, end)
 *
 * The slice method takes two arguments, start and end, and returns an array containing
 * the elements of the array from element start up to, but not including, element end
 * (or through the end of the array if end is undefined). If start is negative, it is
 * treated as length+start where length is the length of the array. If end is negative,
 * it is treated as length+end where length is the length of the array. The following
 * steps are taken:
 */
function arraySlice(global, this, strict, args) {
  start := l_nth(args, 0);
  end := l_nth(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this value
        as the argument. */
  O := ToObject(this);
  /* 2. Let A be a new array created as if by the expression new Array() where
        Array is the standard built-in constructor with that name. */
  A := ArrayConstructor(global, this, strict, []);
  /* 3. Let lenVal be the result of calling the [[Get]] internal method of O
        with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 4. Let len be ToUint32(lenVal). */
  len := ToUint32(lenVal);
  /* 5. Let relativeStart be ToInteger(start). */
  relativeStart := ToInteger(start);
  /* 6. If relativeStart is negative, let k be max((len +relativeStart),0); else let k be min(relativeStart,len). */
  if (relativeStart < 0.) k := max((len + relativeStart), 0.); else k := min(relativeStart, len);
  /* 7. If end is undefined, let relativeEnd be len; else let relativeEnd be ToInteger(end). */
  if (end = 'undefined)
    relativeEnd := len;
  else
    relativeEnd := ToInteger(end);
  /* 8. If relativeEnd is negative, let final be max((len + relativeEnd),0); else
        let final be min(relativeEnd,len). */
  if (relativeEnd < 0.) final := max((len + relativeEnd), 0.); else final := min(relativeEnd, len);
  /* 9. Let n be 0. */
  n := 0.;
  /* 10. Repeat, while k < final */
  while (k < final) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]] internal method
          of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal method of O
            with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Call the [[DefineOwnProperty]] internal method of A with arguments
             ToString(n), Property Descriptor {[[Value]]: kValue, [[Writable]]:
             true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
      descriptor := newDataPropertyDescriptorFull(kValue, true, true, true);
      {A.DefineOwnProperty}(A, ToString(n), descriptor, false);
    }
    /* d. Increase k by 1. */
    k := k + 1.;
    /* e. Increase n by 1. */
    n := n + 1.;
  }
  /* 11. Return A. */
  return A;
}
/**
 * The length property of the slice method is 2.
 *
 * NOTE The slice function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the slice function can be applied
 * successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.11 Array.prototype.sort (comparefn) TODO
 *
 * The elements of this array are sorted. The sort is not necessarily stable
 * (that is, elements that compare equal do not necessarily remain in their
 * original order). If comparefn is not undefined, it should be a function
 * that accepts two arguments x and y and returns a negative value if x < y,
 * zero if x = y, or a positive value if x > y.
 */
function arraySort(global, this, strict, args) {
  comparefn := l_nth(args, 0);

  /* Let obj be the result of calling ToObject passing the this value
     as the argument. */
  obj := ToObject(this);
  /* Let len be the result of applying Uint32 to the result of calling
     the [[Get]] internal method of obj with argument "length". */
  len := ToUint32({obj.Get}(obj, "length"));
  /* If comparefn is not undefined and is not a consistent comparison
     function for the elements of this array (see below), the behaviour
     of sort is implementation-defined. */
  /* TODO */
  /* Let proto be the value of the [[Prototype]] internal property of obj. */
  proto := getInternalProperty(obj, "Prototype");
  /* If proto is not null and there exists an integer j such that all of the
     conditions below are satisfied then the behaviour of sort is
     implementation-defined:
     - obj is sparse (15.4)
     - 0 ≤ j < len
     - The result of calling the [[HasProperty]] internal method of proto
       with argument ToString(j) is true. */
  /* TODO */
  /* The behaviour of sort is also implementation defined if obj is sparse
     and any of the following conditions are true:
     - The [[Extensible]] internal property of obj is false.
     - Any array index property of obj whose name is a nonnegative integer
       less than len is a data property whose [[Configurable]] attribute
       is false. */
  /* TODO */
  /* The behaviour of sort is also implementation defined if any array
     index property of obj whose name is a nonnegative integer less than
     len is an accessor property or is a data property whose [[Writable]]
     attribute is false. */
  /* TODO */
  /* Otherwise, the following steps are taken. */
  /* 1. Perform an implementation-dependent sequence of calls to the [[Get]] ,
        [[Put]], and [[Delete]] internal methods of obj and to SortCompare
        (described below), where the first argument for each call to [[Get]],
        [[Put]], or [[Delete]] is a nonnegative integer less than len and where
        the arguments for calls to SortCompare are results of previous calls to
        the [[Get]] internal method. The throw argument to the [[Put]] and
        [[Delete]] internal methods will be the value true. If obj is not
        sparse then [[Delete]] must not be called. */

  /* INSERTION SORT - START */
  k := 1.;
  while (k < len) {
    j := k - 1.;
    while ((j >= 0.) && (SortCompare(obj, comparefn, j, j + 1.) > 0.)) {
      /* This algorithm is similar to the one in Array.prototype.reverse, step 6. */
      inext_str := ToString(j + 1.);
      i_str := ToString(j);
      jValNextExists := {obj.HasProperty}(obj, inext_str);
      jValExists := {obj.HasProperty}(obj, i_str);
      jValNext := {obj.Get}(obj, inext_str);
      jVal := {obj.Get}(obj, i_str);
      if (jValExists &&& jValNextExists) {
        {obj.Put}(obj, inext_str, jVal, true);
        {obj.Put}(obj, i_str, jValNext, true);
      } elif (!jValExists &&& jValNextExists) {
        {obj.Put}(obj, i_str, jValNext, true);
        {obj.Delete}(obj, inext_str, true);
      } elif (jValExists &&& !jValNextExists) {
        {obj.Put}(obj, inext_str, jVal, true);
        {obj.Delete}(obj, i_str, true);
      }
      j := j - 1.;
    }
    k := k + 1.;
  }
  /* INSERTION SORT - END */

  /* 2. Return obj. */
  return obj;

  /* The returned object must have the following two properties.
     - There must be some mathematical permutation π of the nonnegative
       integers less than len, such that for every nonnegative integer j
       less than len, if property old[j] existed, then new[π(j)] is exactly
       the same value as old[j],. But if property old[j] did not exist,
       then new[π(j)] does not exist.
     - Then for all nonnegative integers j and k, each less than len,
       if SortCompare(j,k) < 0 (see SortCompare below), then π(j) < π(k).

    Here the notation old[j] is used to refer to the hypothetical result
    of calling the [[Get]] internal method of obj with argument j before
    this function is executed, and the notation new[j] to refer to the
    hypothetical result of calling the [[Get]] internal method of obj
    with argument j after this function has been executed.

    A function comparefn is a consistent comparison function for a set
    of values S if all of the requirements below are met for all values
    a, b, and c (possibly the same value) in the set S: The notation
    a <CF b means comparefn(a,b) < 0; a =CF b means comparefn(a,b) = 0
    (of either sign); and a >CF b means comparefn(a,b) > 0.

    - Calling comparefn(a,b) always returns the same value v when given
    a specific pair of values a and b as its two arguments. Furthermore,
    Type(v) is Number, and v is not NaN. Note that this implies that
    exactly one of a <CF b, a =CF b, and a >CF b will be true for a
    given pair of a and b.
    - Calling comparefn(a,b) does not modify the this object.
    - a =CF a (reflexivity)
    - If a =CF b, then b =CF a (symmetry)
    - If a =CF b and b =CF c, then a =CF c (transitivity of =CF)
    - If a <CF b and b <CF c, then a <CF c (transitivity of <CF)
    - If a >CF b and b >CF c, then a >CF c (transitivity of >CF)

    NOTE The above conditions are necessary and sufficient to ensure
    that comparefn divides the set S into equivalence classes and that
    these equivalence classes are totally ordered. */
}
/**
 * NOTE 1 Because non-existent property values always compare greater than
 * undefined property values, and undefined always compares greater than any
 * other value, undefined property values always sort to the end of the
 * result, followed by non-existent property values.
 *
 * NOTE 2 The sort function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore, it can be transferred
 * to other kinds of objects for use as a method. Whether the sort function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * When the SortCompare abstract operation is called with two arguments
 * j and k, the following steps are taken:
 */
function SortCompare(obj, comparefn, j, k) {
  /* 1. Let jString be ToString(j). */
  jString := ToString(j);
  /* 2. Let kString be ToString(k). */
  kString := ToString(k);
  /* 3. Let hasj be the result of calling the [[HasProperty]] internal
        method of obj with argument jString. */
  hasj := {obj.HasProperty}(obj, jString);
  /* 4. Let hask be the result of calling the [[HasProperty]] internal
        method of obj with argument kString. */
  hask := {obj.HasProperty}(obj, kString);
  /* 5. If hasj and hask are both false, then return +0. */
  if ((hasj = false) &&& (hask = false))
    return 0.;
  /* 6. If hasj is false, then return 1. */
  if (hasj = false)
    return 1.;
  /* 7. If hask is false, then return –1. */
  if (hask = false)
    return -(1.);
  /* 8. Let x be the result of calling the [[Get]] internal method of
        obj with argument jString. */
  x := {obj.Get}(obj, jString);
  /* 9. Let y be the result of calling the [[Get]] internal method of
        obj with argument kString. */
  y := {obj.Get}(obj, kString);
  /* 10. If x and y are both undefined, return +0. */
  if ((x = 'undefined) &&& (y = 'undefined))
    return 0.;
  /* 11. If x is undefined, return 1. */
  if (x = 'undefined)
    return 1.;
  /* 12. If y is undefined, return −1. */
  if (y = 'undefined)
    return -(1.);
  /* 13. If the argument comparefn is not undefined, then */
  if (!(comparefn = 'undefined)) {
    /* a. If IsCallable(comparefn) is false, throw a TypeError exception. */
    if (IsCallable(comparefn) = false)
      throw TypeErrorConstructorInternal();
    /* b. Return the result of calling the [[Call]] internal method of
          comparefn passing undefined as the this value and with arguments x and y. */
    return {comparefn.Call}(null, null, comparefn, 'undefined, [x, y]);
  }
  /* 14. Let xString be ToString(x). */
  xString := ToString(x);
  /* 15. Let yString be ToString(y). */
  yString := ToString(y);
  /* 16. If xString < yString, return −1. */
  if (xString < yString)
    return -(1.);
  /* 17. If xString > yString, return 1. */
  if (xString > yString)
    return 1.;
  /* 18. Return +0. */
  return 0.;
}




/**
 * 15.4.4.12 Array.prototype.splice (start, deleteCount [ , item1
 * [ , item2 [ , … ] ] ] )
 *
 * When the splice method is called with two or more arguments start,
 * deleteCount and (optionally) item1, item2, etc., the deleteCount elements
 * of the array starting at array index start are replaced by the arguments
 * item1, item2, etc. An Array object containing the deleted elements (if any)
 * is returned. The following steps are taken:
 */
function arraySplice(global, this, strict, args) {
  start := l_nth(args, 0);
  deleteCount := l_nth(args, 1);
  items := getOptionalParamList(args, 2);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let A be a new array created as if by the expression new Array()
        where Array is the standard built-in constructor with that name. */
  A := ArrayConstructor(global, this, strict, []);
  /* 3. Let lenVal be the result of calling the [[Get]] internal method
        of O with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 4. Let len be ToUint32(lenVal). */
  len := ToUint32(lenVal);
  /* 5. Let relativeStart be ToInteger(start). */
  relativeStart := ToInteger(start);
  /* 6. If relativeStart is negative, let actualStart be max((len + relativeStart),0);
        else let actualStart be min(relativeStart, len). */
  if (relativeStart < 0.) actualStart := max((len + relativeStart), 0.); actualStart := min(relativeStart, len);
  /* 7. Let actualDeleteCount be min(max(ToInteger(deleteCount),0),len - actualStart). */
  actualDeleteCount := min(max(ToInteger(deleteCount), 0.), len - actualStart);
  /* 8. Let k be 0. */
  k := 0.;
  /* 9. Repeat, while k < actualDeleteCount */
  while (k < actualDeleteCount) {
    /* a. Let from be ToString(actualStart+k). */
    from := ToString(actualStart + k);
    /* b. Let fromPresent be the result of calling the [[HasProperty]]
          internal method of O with argument from. */
    fromPresent := {O.HasProperty}(O, from);
    /* c. If fromPresent is true, then */
    if (fromPresent = true) {
      /* i. Let fromValue be the result of calling the [[Get]] internal
            method of O with argument from. */
      fromValue := {O.Get}(O, from);
      /* ii. Call the [[DefineOwnProperty]] internal method of A with arguments
             ToString(k), Property Descriptor {[[Value]]: fromValue,[[Writable]]:
             true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
      descriptor := newDataPropertyDescriptorFull(fromValue, true, true, true);
      {A.DefineOwnProperty}(A, ToString(k), descriptor, false);
    }
    /* d. Increment k by 1. */
    k := k + 1.;
  }
  /* 10. Let items be an internal List whose elements are, in left to
         right order, the portion of the actual argument list starting
         with item1. The list will be empty if no such items are present. */
  items := items;
  /* 11. Let itemCount be the number of elements in items. */
  itemCount := int_to_float (l_len items);
  /* 12. If itemCount < actualDeleteCount, then */
  if (itemCount < actualDeleteCount) {
    /* a. Let k be actualStart. */
    k := actualStart;
    /* b. Repeat, while k < (len - actualDeleteCount) */
    while (k < (len - actualDeleteCount)) {
      /* i. Let from be ToString(k+actualDeleteCount). */
      from := ToString(k + actualDeleteCount);
      /* ii. Let to be ToString(k+itemCount). */
      to := ToString(k + itemCount);
      /* iii. Let fromPresent be the result of calling the
              [[HasProperty]] internal method of O with argument from. */
      fromPresent := {O.HasProperty}(O, from);
      /* iv. If fromPresent is true, then */
      if (fromPresent = true) {
        /* 1. Let fromValue be the result of calling the [[Get]]
              internal method of O with argument from. */
        fromValue := {O.Get}(O, from);
        /* 2. Call the [[Put]] internal method of O with arguments
              to, fromValue, and true. */
        {O.Put}(O, to, fromValue, true);
      } else {
      /* v. Else, fromPresent is false */
        /* 1. Call the [[Delete]] internal method of O with arguments
              to and true. */
        {O.Delete}(O, to, true);
      }
      /* vi. Increase k by 1. */
      k := k + 1.;
    }
    /* c. Let k be len. */
    k := len;
    /* d. Repeat, while k > (len - actualDeleteCount + itemCount) */
    while (k > (len - actualDeleteCount + itemCount)) {
      /* i. Call the [[Delete]] internal method of O with arguments
            ToString(k-1) and true. */
      {O.Delete}(O, ToString(k - 1.), true);
      /* ii. Decrease k by 1. */
      k := k - 1.;
    }
  }
  /* 13. Else if itemCount > actualDeleteCount, then */
  elif (itemCount > actualDeleteCount) {
    /* a. Let k be (len - actualDeleteCount). */
    k := (len - actualDeleteCount);
    /* b. Repeat, while k > actualStart */
    while (k > actualStart) {
      /* i. Let from be ToString(k + actualDeleteCount - 1). */
      from := ToString(k + actualDeleteCount - 1.);
      /* ii. Let to be ToString(k + itemCount - 1) */
      to := ToString(k + itemCount - 1.);
      /* iii. Let fromPresent be the result of calling the [[HasProperty]]
              internal method of O with argument from. */
      fromPresent := {O.HasProperty}(O, from);
      /* iv. If fromPresent is true, then */
      if (fromPresent = true) {
        /* 1. Let fromValue be the result of calling the [[Get]] internal
              method of O with argument from. */
        fromValue := {O.Get}(O, from);
        /* 2. Call the [[Put]] internal method of O with arguments to,
              fromValue, and true. */
        {O.Put}(O, to, fromValue, true);
      }
      /* v. Else, fromPresent is false */
      else {
        /* 1. Call the [[Delete]] internal method of O with argument
              to and true. */
        {O.Delete}(O, to, true);
      }
      /* vi. Decrease k by 1. */
      k := k - 1.;
    }
  }
  /* 14. Let k be actualStart. */
  k := actualStart;
  /* 15. Repeat, while items is not empty */
  while (!(items = [])) {
    /* a. Remove the first element from items and let E be the value
          of that element. */
    E := hd items;
    items := tl items;
    /* b. Call the [[Put]] internal method of O with arguments
          ToString(k), E, and true. */
    {O.Put}(O, ToString(k), E, true);
    /* c. Increase k by 1. */
    k := k + 1.;
  }
  /* 16. Call the [[Put]] internal method of O with arguments "length",
         (len - actualDeleteCount + itemCount), and true. */
  {O.Put}(O, "length", ((len - actualDeleteCount) + itemCount), true);
  /* 17. Return A. */
  return A;
}
/**
 * The length property of the splice method is 2.
 *
 * NOTE The splice function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the splice function can be
 * applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.13 Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )
 *
 * The arguments are prepended to the start of the array, such that their
 * order within the array is the same as the order in which they appear
 * in the argument list.
 *
 * When the unshift method is called with zero or more arguments item1,
 * item2, etc., the following steps are taken:
 */
function arrayUnshift(global, this, strict, items) {
  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenVal be the result of calling the [[Get]] internal
        method of O with argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenVal). */
  len := ToUint32(lenVal);
  /* 4. Let argCount be the number of actual arguments. */
  argCount := int_to_float (l_len items);
  /* 5. Let k be len. */
  k := len;
  /* 6. Repeat, while k > 0, */
  while (k > 0.) {
    /* a. Let from be ToString(k-1). */
    from := ToString(k - 1.);
    /* b. Let to be ToString(k+argCount -1). */
    to := ToString(k + argCount - 1.);
    /* c. Let fromPresent be the result of calling the [[HasProperty]]
          internal method of O with argument from. */
    fromPresent := {O.HasProperty}(O, from);
    /* d. If fromPresent is true, then */
    if (fromPresent = true) {
      /* i. Let fromValue be the result of calling the [[Get]]
            internal method of O with argument from. */
      fromValue := {O.Get}(O, from);
      /* ii. Call the [[Put]] internal method of O with arguments
             to, fromValue, and true. */
      {O.Put}(O, to, fromValue, true);
    }
    /* e. Else, fromPresent is false */
    else {
      /* i. Call the [[Delete]] internal method of O with arguments
            to, and true. */
      {O.Delete}(O, to, true);
    }
    /* f. Decrease k by 1. */
    k := k - 1.;
  }
  /* 7. Let j be 0. */
  j := 0.;
  /* 8. Let items be an internal List whose elements are, in left
        to right order, the arguments that were passed to this function
        invocation. */
  items := items;
  /* 9. Repeat, while items is not empty */
  while (!(items = [])) {
    /* a. Remove the first element from items and let E be the value
          of that element. */
    E := hd items;
    items := tl items;
    /* b. Call the [[Put]] internal method of O with arguments
          ToString(j), E, and true. */
    {O.Put}(O, ToString(j), E, true);
    /* c. Increase j by 1. */
    j := j + 1.;
  }
  /* 10. Call the [[Put]] internal method of O with arguments "length",
         len+argCount, and true. */
  {O.Put}(O, "length", len + argCount, true);
  /* 11. Return len+argCount. */
  return len + argCount;
}
/**
 * The length property of the unshift method is 1.
 *
 * NOTE The unshift function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the unshift function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] )
 *
 * indexOf compares searchElement to the elements of the array, in ascending
 * order, using the internal Strict Equality Comparison Algorithm (11.9.6),
 * and if found at one or more positions, returns the index of the first such
 * position; otherwise, -1 is returned.
 *
 * The optional second argument fromIndex defaults to 0 (i.e. the whole array
 * is searched). If it is greater than or equal to the length of the array, -1
 * is returned, i.e. the array will not be searched. If it is negative, it is
 * used as the offset from the end of the array to compute fromIndex. If the
 * computed index is less than 0, the whole array will be searched.
 *
 * When the indexOf method is called with one or two arguments, the following
 * steps are taken:
 */
function arrayIndexOf(global, this, strict, args) {
  searchElement := l_nth(args, 0);
  fromIndex := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this value
        as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal method
        of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue). */
  len := ToUint32(lenVal);
  /* 4. If len is 0, return -1. */
  if (len = 0.)
    return -(1.);
  /* 5. If argument fromIndex was passed let n be ToInteger(fromIndex); else let n be 0. */
  if (!(fromIndex = null))
    n :=  ToInteger(fromIndex);
  else
    n := 0.;
  /* 6. If n ≥ len, return -1. */
  if (n >= len)
    return -(1.);
  /* 7. If n ≥ 0, then */
  if (n >= 0.) {
    /* This comparison with -0 was extracted from ES7 standard. Fix bug. */
    /* a. If n is -0, let k be +0; else let k be n. */
    if (isMinusZero(n)) k := 0.; else k := n;
  } else {
  /* 8. Else, n<0 */
    /* a. Let k be len - abs(n). */
    k := len - abs(n);
    /* b. If k is less than 0, then let k be 0. */
    if (k < 0.)
      k := 0.;
  }
  /* 9. Repeat, while k<len */
  while (k < len) {
    /* a. Let kPresent be the result of calling the [[HasProperty]] internal
          method of O with argument ToString(k). */
    kPresent := {O.HasProperty}(O, ToString(k));
    /* b. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let elementK be the result of calling the [[Get]] internal method
            of O with the argument ToString(k). */
      elementK := {O.Get}(O, ToString(k));
      /* ii. Let same be the result of applying the Strict Equality Comparison
            Algorithm to searchElement and elementK. */
      same := StrictEqualityComparison(searchElement, elementK);
      /* iii. If same is true, return k. */
      if (same = true)
        return k;
    }
    /* c. Increase k by 1. */
    k := k + 1.;
  }
  /* 10. Return -1. */
  return -(1.);
}
/**
 * The length property of the indexOf method is 1.
 *
 * NOTE The indexOf function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the indexOf function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.15 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
 *
 * lastIndexOf compares searchElement to the elements of the array in
 * descending order using the internal Strict Equality Comparison Algorithm
 * (11.9.6), and if found at one or more positions, returns the index of the
 * last such position; otherwise, -1 is returned.
 *
 * The optional second argument fromIndex defaults to the array's length minus
 * one (i.e. the whole array is searched). If it is greater than or equal to
 * the length of the array, the whole array will be searched. If it is
 * negative, it is used as the offset from the end of the array to compute
 * fromIndex. If the computed index is less than 0, -1 is returned.
 *
 * When the lastIndexOf method is called with one or two arguments, the
 * following steps are taken:
 */
function arrayLastIndexOf(global, this, strict, args) {
  searchElement := l_nth(args, 0);
  fromIndex := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue). */
  len := ToUint32(lenVal);
  /* 4. If len is 0, return -1. */
  if (len = 0.)
    return -(1.);
  /* 5. If argument fromIndex was passed let n be ToInteger(fromIndex); else let n be len. */
  if (!(fromIndex = null))
    n := ToInteger(fromIndex);
  else 
    n := len;
  /* 6. If n ≥ 0, then let k be min(n, len - 1). */
  if (n >= 0.) {
    /* This comparison with -0 was extracted from ES7 standard. Fix bug. */
    /* a. If n is -0, let k be +0; else let k be min(n, len - 1). */
    if (isMinusZero(n)) k := 0.; else k := min(n, len - 1.);
  }
  /* 7. Else, n < 0 */
  else {
    /* a. Let k be len - abs(n). */
    k := len - abs(n);
  }
  /* 8. Repeat, while k≥ 0 */
  while (k >= 0.) {
    /* a. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument ToString(k). */
    kPresent := {O.HasProperty}(O, ToString(k));
    /* b. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let elementK be the result of calling the [[Get]] internal
            method of O with the argument ToString(k). */
      elementK := {O.Get}(O, ToString(k));
      /* ii. Let same be the result of applying the Strict Equality
             Comparision Algorithm to searchElement and elementK. */
      same := StrictEqualityComparison(searchElement, elementK);
      /* iii. If same is true, return k. */
      if (same = true)
        return k;
    }
    /* c. Decrease k by 1. */
    k := k - 1.;
  }
  /* 9. Return -1. */
  return -(1.);
}
/**
 * The length property of the lastIndexOf method is 1.
 *
 * NOTE The lastIndexOf function is intentionally generic; it does not
 * require that its this value be an Array object. Therefore it can be
 * transferred to other kinds of objects for use as a method. Whether the
 * lastIndexOf function can be applied successfully to a host object is
 * implementation-dependent.
 */




/**
 * 15.4.4.16 Array.prototype.every ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments and returns
 * a value that is coercible to the Boolean value true or false. every calls
 * callbackfn once for each element present in the array, in ascending order,
 * until it finds one where callbackfn returns false. If such an element is
 * found, every immediately returns false. Otherwise, if callbackfn returned
 * true for all elements, every will return true. callbackfn is called only
 * for elements of the array which actually exist; it is not called for
 * missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value
 * for each invocation of callbackfn. If it is not provided, undefined is
 * used instead.
 *
 * callbackfn is called with three arguments: the value of the element,
 * the index of the element, and the object being traversed.
 *
 * every does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by every is set before the first call
 * to callbackfn. Elements which are appended to the array after the call
 * to every begins will not be visited by callbackfn. If existing elements
 * of the array are changed, their value as passed to callbackfn will be the
 * value at the time every visits them; elements that are deleted after the
 * call to every begins and before being visited are not visited. every acts
 * like the "for all" quantifier in mathematics. In particular, for an empty
 * array, it returns true.
 *
 * When the every method is called with one or two arguments, the following
 * steps are taken:
 */
function arrayEvery(global, this, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue). */
  len := ToUint32(lenVal);
  /* 4. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) = false)
    throw TypeErrorConstructorInternal();
  /* 5. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (!(thisArg = null)) T := thisArg; T := 'undefined;
  /* 6. Let k be 0. */
  k := 0.;
  /* 7. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Let testResult be the result of calling the [[Call]] internal
             method of callbackfn with T as the this value and argument
             list containing kValue, k, and O. */
      testResult := {callbackfn.Call}(null, null, callbackfn, T, [kValue, k, O]);
      /* iii. If ToBoolean(testResult) is false, return false. */
      if (ToBoolean(testResult) = false)
        return false;
    }
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 8. Return true. */
  return true;
}
/**
 * The length property of the every method is 1.
 *
 * NOTE The every function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the every function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.17 Array.prototype.some ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments and returns
 * a value that is coercible to the Boolean value true or false. some calls
 * callbackfn once for each element present in the array, in ascending order,
 * until it finds one where callbackfn returns true. If such an element is
 ª found, some immediately returns true. Otherwise, some returns false.
 * callbackfn is called only for elements of the array which actually exist;
 * it is not called for missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value for
 * each invocation of callbackfn. If it is not provided, undefined is used instead.
 *
 * callbackfn is called with three arguments: the value of the element, the
 * index of the element, and the object being traversed.
 *
 * some does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by some is set before the first call to
 * callbackfn. Elements that are appended to the array after the call to
 * some begins will not be visited by callbackfn. If existing elements of
 * the array are changed, their value as passed to callbackfn will be the
 * value at the time that some visits them; elements that are deleted after
 * the call to some begins and before being visited are not visited. some
 * acts like the "exists" quantifier in mathematics. In particular, for an
 * empty array, it returns false.
 *
 * When the some method is called with one or two arguments, the following
 * steps are taken:
 */
function arraySome(global, this, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue). */
  len := ToUint32(lenVal);
  /* 4. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) = false)
    throw TypeErrorConstructorInternal();
  /* 5. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (!(thisArg = null)) T := thisArg; else T := 'undefined;
  /* 6. Let k be 0. */
  k := 0.;
  /* 7. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Let testResult be the result of calling the [[Call]] internal
             method of callbackfn with T as the this value and argument
             list containing kValue, k, and O. */
      testResult := {callbackfn.Call}(null, null, callbackfn, T, [kValue, k, O]);
      /* iii. If ToBoolean(testResult) is true, return true. */
      if (ToBoolean(testResult) = true)
        return true;
    }
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 8. Return false. */
  return false;
}
/**
 * The length property of the some method is 1.
 *
 * NOTE The some function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the some function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments. forEach
 * calls callbackfn once for each element present in the array, in ascending
 * order. callbackfn is called only for elements of the array which actually
 * exist; it is not called for missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value for
 * each invocation of callbackfn. If it is not provided, undefined is used
 * instead.
 *
 * callbackfn is called with three arguments: the value of the element,
 * the index of the element, and the object being traversed.
 *
 * forEach does not directly mutate the object on which it is called but
 * the object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by forEach is set before the first
 * call to callbackfn. Elements which are appended to the array after the
 * call to forEach begins will not be visited by callbackfn. If existing
 * elements of the array are changed, their value as passed to callback
 * will be the value at the time forEach visits them; elements that are
 * deleted after the call to forEach begins and before being visited are
 * not visited.
 *
 * When the forEach method is called with one or two arguments, the
 * following steps are taken:
 */
function arrayForEach(global, this, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue). */
  len := ToUint32(lenVal);
  /* 4. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) = false)
    throw TypeErrorConstructorInternal();
  /* 5. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (!(thisArg = null)) T := thisArg; else T := 'undefined;
  /* 6. Let k be 0. */
  k := 0.;
  /* 7. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Call the [[Call]] internal method of callbackfn with T
             as the this value and argument list containing kValue, k, and O. */
      {callbackfn.Call}(null, null, callbackfn, T, [kValue, k, O]);
    }
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 8. Return undefined. */
  return 'undefined;
}
/**
 * The length property of the forEach method is 1.
 *
 * NOTE The forEach function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the forEach function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments. map calls
 * callbackfn once for each element in the array, in ascending order, and
 * constructs a new Array from the results. callbackfn is called only for
 * elements of the array which actually exist; it is not called for missing
 * elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value
 * for each invocation of callbackfn. If it is not provided, undefined is
 * used instead.
 *
 * callbackfn is called with three arguments: the value of the element,
 * the index of the element, and the object being traversed.
 *
 * map does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by map is set before the first call
 * to callbackfn. Elements which are appended to the array after the call
 * to map begins will not be visited by callbackfn. If existing elements of
 * the array are changed, their value as passed to callbackfn will be the
 * value at the time map visits them; elements that are deleted after the
 * call to map begins and before being visited are not visited.
 *
 * When the map method is called with one or two arguments, the following
 * steps are taken:
 */
function arrayMap(global, this, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue). */
  len := ToUint32(lenVal);
  /* 4. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) = false)
    throw TypeErrorConstructorInternal();
  /* 5. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (!(thisArg = null)) T := thisArg; else T := 'undefined;
  /* 6. Let A be a new array created as if by the expression new Array( len)
        where Array is the standard built-in constructor with that name and
        len is the value of len. */
  A := ArrayConstructor(global, this, strict, [len]);
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Let mappedValue be the result of calling the [[Call]] internal
             method of callbackfn with T as the this value and argument list
             containing kValue, k, and O. */
      mappedValue := {callbackfn.Call}(null, null, callbackfn, T, [kValue, k, O]);
      /* iii. Call the [[DefineOwnProperty]] internal method of A with
              arguments Pk, Property Descriptor {[[Value]]: mappedValue,
              [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true},
              and false. */
      descriptor := newDataPropertyDescriptorFull(mappedValue, true, true, true);
      {A.DefineOwnProperty}(A, Pk, descriptor, false);
    }
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 9. Return A. */
  return A;
}
/**
 * The length property of the map method is 1.
 *
 * NOTE The map function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the map function can be applied
 * successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.20 Array.prototype.filter ( callbackfn [ , thisArg ] )
 *
 * callbackfn should be a function that accepts three arguments and returns a
 * value that is coercible to the Boolean value true or false. filter calls
 * callbackfn once for each element in the array, in ascending order, and
 * constructs a new array of all the values for which callbackfn returns true.
 * callbackfn is called only for elements of the array which actually exist; it
 * is not called for missing elements of the array.
 *
 * If a thisArg parameter is provided, it will be used as the this value for
 * each invocation of callbackfn. If it is not provided, undefined is used instead.
 *
 * callbackfn is called with three arguments: the value of the element, the
 * index of the element, and the object being traversed.
 *
 * filter does not directly mutate the object on which it is called but the
 * object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by filter is set before the first call to
 * callbackfn. Elements which are appended to the array after the call to filter
 * begins will not be visited by callbackfn. If existing elements of the array
 * are changed their value as passed to callbackfn will be the value at the time
 * filter visits them; elements that are deleted after the call to filter begins
 * and before being visited are not visited.
 *
 * When the filter method is called with one or two arguments, the following
 * steps are taken:
 */
function arrayFilter(global, this, strict, args) {
  callbackfn := l_nth(args, 0);
  thisArg := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue). */
  len := ToUint32(lenVal);
  /* 4. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) = false)
    throw TypeErrorConstructorInternal();
  /* 5. If thisArg was supplied, let T be thisArg; else let T be undefined. */
  if (!(thisArg = null)) T := thisArg; else T := 'undefined;
  /* 6. Let A be a new array created as if by the expression new Array()
        where Array is the standard built-in constructor with that name. */
  A := ArrayConstructor(global, this, strict, []);
  /* 7. Let k be 0. */
  k := 0.;
  /* 8. Let to be 0. */
  to := 0.;
  /* 9. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Let selected be the result of calling the [[Call]] internal
             method of callbackfn with T as the this value and argument list
             containing kValue, k, and O. */
      selected := {callbackfn.Call}(null, null, callbackfn, T, [kValue, k, O]);
      /* iii. If ToBoolean(selected) is true, then */
      if (ToBoolean(selected) = true) {
        /* 1. Call the [[DefineOwnProperty]] internal method of A with arguments
              ToString(to), Property Descriptor {[[Value]]: kValue, [[Writable]]:
              true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
        descriptor := newDataPropertyDescriptorFull(kValue, true, true, true);
        {A.DefineOwnProperty}(A, ToString(to), descriptor, false);
        /* 2. Increase to by 1. */
        to := to + 1.;
      }
    }
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 10. Return A. */
  return A;
}
/**
 * The length property of the filter method is 1.
 *
 * NOTE The filter function is intentionally generic; it does not require that
 * its this value be an Array object. Therefore it can be transferred to other
 * kinds of objects for use as a method. Whether the filter function can be
 * applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.21 Array.prototype.reduce ( callbackfn [ , initialValue ] )
 *
 * callbackfn should be a function that takes four arguments. reduce calls
 * the callback, as a function, once for each element present in the array,
 * in ascending order.
 *
 * callbackfn is called with four arguments: the previousValue (or value
 * from the previous call to callbackfn), the currentValue (value of the
 * current element), the currentIndex, and the object being traversed. The
 * first time that callback is called, the previousValue and currentValue
 * can be one of two values. If an initialValue was provided in the call to
 * reduce, then previousValue will be equal to initialValue and currentValue
 * will be equal to the first value in the array. If no initialValue was
 * provided, then previousValue will be equal to the first value in the array
 * and currentValue will be equal to the second. It is a TypeError if the
 * array contains no elements and initialValue is not provided.
 *
 * reduce does not directly mutate the object on which it is called but
 * the object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by reduce is set before the first call
 * to callbackfn. Elements that are appended to the array after the call to
 * reduce begins will not be visited by callbackfn. If existing elements of
 * the array are changed, their value as passed to callbackfn will be the
 * value at the time reduce visits them; elements that are deleted after
 * the call to reduce begins and before being visited are not visited.
 *
 * When the reduce method is called with one or two arguments, the
 * following steps are taken:
 */
function arrayReduce(global, this, strict, args) {
  callbackfn := l_nth(args, 0);
  initialValue := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue ). */
  len := ToUint32(lenVal);
  /* 4. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) = false)
    throw TypeErrorConstructorInternal();
  /* 5. If len is 0 and initialValue is not present, throw a TypeError exception. */
  if ((len = 0) &&& (initialValue = null))
    throw TypeErrorConstructorInternal();
  /* 6. Let k be 0. */
  k := 0.;
  /* 7. If initialValue is present, then */
  if (!(initialValue = null)) {
    /* a. Set accumulator to initialValue. */
    accumulator := initialValue;
  }
  /* 8. Else, initialValue is not present */
  else {
    /* a. Let kPresent be false. */
    kPresent := false;
    /* b. Repeat, while kPresent is false and k < len */
    while ((kPresent = false) && (k < len)) {
      /* i. Let Pk be ToString(k). */
      Pk := ToString(k);
      /* ii. Let kPresent be the result of calling the [[HasProperty]]
             internal method of O with argument Pk. */
      kPresent := {O.HasProperty}(O, Pk);
      /* iii. If kPresent is true, then */
      if (kPresent = true) {
        /* 1. Let accumulator be the result of calling the [[Get]]
              internal method of O with argument Pk. */
        accumulator := {O.Get}(O, Pk);
      }
      /* iv. Increase k by 1. */
      k := k + 1.;
    }
    /* c. If kPresent is false, throw a TypeError exception. */
    if (kPresent = false)
      throw TypeErrorConstructorInternal();
  }
  /* 9. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Let accumulator be the result of calling the [[Call]] internal
             method of callbackfn with undefined as the this value and
             argument list containing accumulator, kValue, k, and O. */
      accumulator := {callbackfn.Call}(null, null, callbackfn, 'undefined, [accumulator, kValue, k, O]);
    }
    /* d. Increase k by 1. */
    k := k + 1.;
  }
  /* 10. Return accumulator. */
  return accumulator;
}
/**
 * The length property of the reduce method is 1.
 *
 * NOTE The reduce function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred
 * to other kinds of objects for use as a method. Whether the reduce function
 * can be applied successfully to a host object is implementation-dependent.
 */




/**
 * 15.4.4.22 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )
 *
 * callbackfn should be a function that takes four arguments. reduceRight calls
 * the callback, as a function, once for each element present in the array, in
 * descending order.
 *
 * callbackfn is called with four arguments: the previousValue (or value from
 * the previous call to callbackfn), the currentValue (value of the current
 * element), the currentIndex, and the object being traversed. The first time
 * the function is called, the previousValue and currentValue can be one of two
 * values. If an initialValue was provided in the call to reduceRight, then
 * previousValue will be equal to initialValue and currentValue will be equal
 * to the last value in the array. If no initialValue was provided, then
 * previousValue will be equal to the last value in the array and currentValue
 * will be equal to the second-to-last value. It is a TypeError if the array
 * contains no elements and initialValue is not provided.
 *
 * reduceRight does not directly mutate the object on which it is called but
 * the object may be mutated by the calls to callbackfn.
 *
 * The range of elements processed by reduceRight is set before the first call
 * to callbackfn. Elements that are appended to the array after the call to
 * reduceRight begins will not be visited by callbackfn. If existing elements
 * of the array are changed by callbackfn, their value as passed to callbackfn
 * will be the value at the time reduceRight visits them; elements that are
 * deleted after the call to reduceRight begins and before being visited are
 * not visited.
 *
 * When the reduceRight method is called with one or two arguments,
 * the following steps are taken:
 */
function arrayReduceRight(global, this, strict, args) {
  callbackfn := l_nth(args, 0);
  initialValue := getOptionalParam(args, 1);

  /* 1. Let O be the result of calling ToObject passing the this
        value as the argument. */
  O := ToObject(this);
  /* 2. Let lenValue be the result of calling the [[Get]] internal
        method of O with the argument "length". */
  lenVal := {O.Get}(O, "length");
  /* 3. Let len be ToUint32(lenValue ). */
  len := ToUint32(lenVal);
  /* 4. If IsCallable(callbackfn) is false, throw a TypeError exception. */
  if (IsCallable(callbackfn) = false)
    throw TypeErrorConstructorInternal();
  /* 5. If len is 0 and initialValue is not present, throw a TypeError exception. */
  if ((len = 0) &&& (initialValue = null))
    throw TypeErrorConstructorInternal();
  /* 6. Let k be len-1. */
  k := len - 1.;
  /* 7. If initialValue is present, then */
  if (!(initialValue = null)) {
    /* a. Set accumulator to initialValue. */
    accumulator := initialValue;
  }
  /* 8. Else, initialValue is not present */
  else {
    /* a. Let kPresent be false. */
    kPresent := false;
    /* b. Repeat, while kPresent is false and k ≥ 0 */
    while ((kPresent = false) && (k >= 0.)) {
      /* i. Let Pk be ToString(k). */
      Pk := ToString(k);
      /* ii. Let kPresent be the result of calling the [[HasProperty]]
             internal method of O with argument Pk. */
      kPresent := {O.HasProperty}(O, Pk);
      /* iii. If kPresent is true, then */
      if (kPresent = true) {
        /* 1. Let accumulator be the result of calling the [[Get]]
              internal method of O with argument Pk. */
        accumulator := {O.Get}(O, Pk);
      }
      /* iv. Decrease k by 1. */
      k := k - 1.;
    }
    /* c. If kPresent is false, throw a TypeError exception. */
    if (kPresent = false)
      throw TypeErrorConstructorInternal();
  }
  /* 9. Repeat, while k ≥ 0 */
  while (k >= 0.) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kPresent be the result of calling the [[HasProperty]]
          internal method of O with argument Pk. */
    kPresent := {O.HasProperty}(O, Pk);
    /* c. If kPresent is true, then */
    if (kPresent = true) {
      /* i. Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk. */
      kValue := {O.Get}(O, Pk);
      /* ii. Let accumulator be the result of calling the [[Call]] internal
             method of callbackfn with undefined as the this value and
             argument list containing accumulator, kValue, k, and O. */
      accumulator := {callbackfn.Call}(null, null, callbackfn, 'undefined, [accumulator, kValue, k, O]);
    }
    /* d. Decrease k by 1. */
    k := k - 1.;
  }
  /* 10. Return accumulator. */
  return accumulator;
}
/**
 * The length property of the reduceRight method is 1.
 *
 * NOTE The reduceRight function is intentionally generic; it does not require
 * that its this value be an Array object. Therefore it can be transferred to
 * other kinds of objects for use as a method. Whether the reduceRight function
 * can be applied successfully to a host object is implementation-dependent.
 */





/**
 * 15.4.5.1 [[DefineOwnProperty]] ( P, Desc, Throw )
 *
 * Array objects use a variation of the [[DefineOwnProperty]] internal method
 * used for other native ECMAScript objects (8.12.9).
 *
 * Assume A is an Array object, Desc is a Property Descriptor, and Throw is a
 * Boolean flag.
 *
 * In the following algorithm, the term “Reject” means “If Throw is true, then
 * throw a TypeError exception, otherwise return false.”
 *
 * When the [[DefineOwnProperty]] internal method of A is called with property
 * P, Property Descriptor Desc, and Boolean flag Throw, the following steps are
 * taken:
 */
function DefineOwnPropertyArray(A, P, Desc, Throw) {
  /* 1. Let oldLenDesc be the result of calling the [[GetOwnProperty]] internal
      method of A passing "length" as the argument. The result will never be
      undefined or an accessor descriptor because Array objects are created
      with a length data property that cannot be deleted or reconfigured. */
  oldLenDesc := {A.GetOwnProperty}(A, "length");

  /* 2. Let oldLen be oldLenDesc.[[Value]]. */
  oldLen := oldLenDesc.Value;

  /* 3. If P is "length", then */
  if (P = "length") {
    /* a. If the [[Value]] field of Desc is absent, then */
    if (!("Value" in_obj Desc)) {
      /* i. Return the result of calling the default [[DefineOwnProperty]] internal
          method (8.12.9) on A passing "length", Desc, and Throw as arguments. */
      return DefineOwnProperty(A, "length", Desc, Throw);
    }
    /* b. Let newLenDesc be a copy of Desc. */
    newLenDesc := CopyDescriptor(Desc);
    /* c. Let newLen be ToUint32(Desc.[[Value]]). */
    newLen := ToUint32(Desc.Value);
    /* d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError
          exception.*/
    if (!(newLen = ToNumber(Desc.Value)))
      throw RangeErrorConstructorInternal();
    /* e. Set newLenDesc.[[Value]] to newLen. */
    newLenDesc.Value := newLen;
    /* f. If newLen ≥ oldLen, then */
    if (newLen >= oldLen) {
      /* i. Return the result of calling the default [[DefineOwnProperty]]
            internal method (8.12.9) on A passing "length", newLenDesc,
            and Throw as arguments. */
      return DefineOwnProperty(A, "length", newLenDesc, Throw);
    }
    /* g. Reject if oldLenDesc.[[Writable]] is false. */
    if (oldLenDesc.Writable = false)
      @Reject(Throw);

    /* h. If newLenDesc.[[Writable]] is absent or has the value true,
          let newWritable be true. */
    if (!("Writable" in_obj newLenDesc) ||| newLenDesc.Writable = true)
      newWritable := true;
    /* i. Else, */
    else {
      /* i. Need to defer setting the [[Writable]] attribute to false in
            case any elements cannot be deleted. */
      /* TODO ???*/
      /* ii. Let newWritable be false. */
      newWritable := false;
      /* iii. Set newLenDesc.[[Writable] to true. */
      newLenDesc.Writable := true;
    }
    /* j. Let succeeded be the result of calling the default
          [[DefineOwnProperty]] internal method (8.12.9) on A passing
          "length", newLenDesc, and Throw as arguments. */
    succeeded := DefineOwnProperty(A, "length", newLenDesc, Throw);
    /* k. If succeeded is false, return false.. */
    if (succeeded = false)
      return false;
    /* l. While newLen < oldLen repeat, */
    while (newLen < oldLen) {
      /* i. Set oldLen to oldLen – 1. */
      oldLen := oldLen - 1.;
      /* ii. Let deleteSucceeded be the result of calling the
             [[Delete]] internal method of A passing ToString(oldLen)
             and false as arguments. */
      deleteSucceeded := {A.Delete}(A, ToString(oldLen), false);
      /* iii. If deleteSucceeded is false, then */
      if (deleteSucceeded = false) {
        /* 1. Set newLenDesc.[[Value] to oldLen+1. */
        newLenDesc.Value := oldLen + 1.;
        /* 2. If newWritable is false, set newLenDesc.[[Writable] to false. */
        if (newWritable = false)
          newLenDesc.Writable := false;
        /* 3. Call the default [[DefineOwnProperty]] internal method (8.12.9)
              on A passing "length", newLenDesc, and false as arguments. */
        DefineOwnProperty(A, "length", newLenDesc, false);
        /* 4. Reject. */
        @Reject(Throw);
      }
    }
    /* m. If newWritable is false, then */
    if (newWritable = false) {
      /* i. Call the default [[DefineOwnProperty]] internal method (8.12.9)
            on A passing "length", Property Descriptor{[[Writable]]: false},
            and false as arguments. This call will always return true. */
      DefineOwnProperty(A, "length", { Writable: false }, false);
    }
    /* n. Return true. */
    return true;
  }
  /* 4. Else if P is an array index (15.4), then */
  elif (IsArrayIndex(P)) {
    /* a. Let index be ToUint32(P). */
    index := ToUint32(P);
    /* b. Reject if index ≥ oldLen and oldLenDesc.[[Writable]] is false. */
    if ((index >= oldLen) &&& (oldLenDesc.Writable = false))
      @Reject(Throw);
    /* c. Let succeeded be the result of calling the default [[DefineOwnProperty]]
          internal method (8.12.9) on A passing P, Desc, and false as arguments. */
    succeeded := DefineOwnProperty(A, P, Desc, false);
    /* d. Reject if succeeded is false. */
    if (succeeded = false)
      @Reject(Throw);
    /* STANDARD IS WRONG */
    newLen := ToUint32(index + 1.);
    /* e. If index ≥ oldLen */
    if (newLen > oldLen) {
      /* i. Set oldLenDesc.[[Value]] to index + 1. */
      oldLenDesc.Value := newLen;
      /* ii. Call the default [[DefineOwnProperty]] internal method (8.12.9)
            on A passing "length", oldLenDesc, and false as arguments. This
            call will always return true. */
      DefineOwnProperty(A, "length", oldLenDesc, false);
    }
    /* f. Return true. */
    return true;
  }
  /* 5. Return the result of calling the default [[DefineOwnProperty]] internal
        method (8.12.9) on A passing P, Desc, and Throw as arguments. */
  return DefineOwnProperty(A, P, Desc, Throw);
}

