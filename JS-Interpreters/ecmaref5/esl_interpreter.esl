/* Copyright (C) 2022-2025 formalsec programmers
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import "esl_sections.esl";

function JS_Interpreter_Program(p, callingExecCtx) {
  /* 14 Program */
  match p : type with
  | { sourceType: "script", type: "Program", codeType: "eval", body: SourceElementsopt, strict: strict } -> {
    if (SourceElementsopt == [])
      return normalEmptyCompletion('empty);
    result := JS_Interpreter_SourceElements(SourceElementsopt, callingExecCtx);
    return result;
  }
  | { sourceType: "script", type: "EarlySyntaxError", codeType: "eval", message: message } -> {
    if (message == "Invalid left-hand side in assignment")
      return throwEmptyCompletion(ReferenceErrorConstructorInternal());
    return throwEmptyCompletion(SyntaxErrorConstructorInternal());
  }
  | { sourceType: "script", type: "Program", body: SourceElements, strict: strict } -> {
    /* The production Program : SourceElements opt is evaluated as follows: */

    /* 1. The code of this Program is strict mode code if the Directive Prologue (14.1) of its SourceElements
          contains a Use Strict Directive or if any of the conditions of 10.1.1 apply. If the code of this
          Program is strict mode code, SourceElements is evaluated in the following steps as strict mode code.
          Otherwise SourceElements is evaluated in the following steps as non-strict mode code. */

    /* 2. If SourceElements is not present, return (normal, empty, empty). */
    if (SourceElements == [])
      return normalEmptyCompletion('empty);
    /* 3. Let progCxt be a new execution context for global code as described in 10.4.1. */
    progCxt := EnteringGlobalCode(p);
    /* 4. Let result be the result of evaluating SourceElements. */
    result := JS_Interpreter_SourceElements(SourceElements, progCxt);
    /* 5. Exit the execution context progCxt. */
    /* exitExecutionContext(progCxt); */ /* TODO */
    /* 6. Return result. */
    return result;
  }
  | { sourceType: "script", type: "EarlySyntaxError", message: message } -> {
    EnteringGlobalCode(p);
    if (message == "Invalid left-hand side in assignment")
      return throwEmptyCompletion(ReferenceErrorConstructorInternal());
    return throwEmptyCompletion(SyntaxErrorConstructorInternal());
  }
}

function Interpreter_Statement_Guard(error) {
  return throwEmptyCompletion(error);
}

function JS_Interpreter_SourceElements(SourceElements, scope) {
  if (l_len(SourceElements) == 1)
    return JS_Interpreter_SourceElements_SourceElement(l_nth(SourceElements, 0), scope);

  SourceElement := l_nth (SourceElements, l_len(SourceElements) - 1);
  SourceElements := l_remove_last (SourceElements);
  return JS_Interpreter_SourceElements_SourceElements_SourceElement(SourceElements, SourceElement, scope);
}

/* The production SourceElements : SourceElements SourceElement is evaluated as follows: */
function JS_Interpreter_SourceElements_SourceElements_SourceElement(SourceElements, SourceElement, scope) {
  /* 1. Let headResult be the result of evaluating SourceElements. */
  headResult := JS_Interpreter_SourceElements(SourceElements, scope);
  /* 2. If headResult is an abrupt completion, return headResult. */
  if (isAnAbruptCompletion(headResult))
    return headResult;
  /* 3. Let tailResult be result of evaluating SourceElement. */
  tailResult := JS_Interpreter_SourceElements_SourceElement(SourceElement, scope);
  /* 4. If tailResult.value is empty, let (V) = headResult.value, otherwise let (V) = tailResult.value. */
  if (getCompletionValue(tailResult) == 'empty) V := getCompletionValue(headResult); else V := getCompletionValue(tailResult);
  /* 5. Return (tailResult.type, V, tailResult.target) */
  return newCompletion(getCompletionType(tailResult), V, getCompletionTarget(tailResult));
}

/* The production SourceElement : Statement is evaluated as follows: */
function JS_Interpreter_SourceElements_SourceElement(Statement, scope) {
  result := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
  /* 1. Return the result of evaluating Statement. */
  return result;
}

/* The production SourceElement : FunctionDeclaration is evaluated as follows: */
function JS_Interpreter_SourceElements_FunctionDeclaration() {
  /* 1. Return (normal, empty, empty). */
  return normalEmptyCompletion('empty);
}

function JS_Interpreter_SourceElements_old(SourceElements, scope) {
  /* The production SourceElements : SourceElements SourceElement is evaluated as follows: */

  i := 0;
  lSourceElements := l_len(SourceElements);
  while (i < lSourceElements) {
    /* 1. Let headResult be the result of evaluating SourceElements. */
    /* 2. If headResult is an abrupt completion, return headResult. */
    /* 3. Let tailResult be result of evaluating SourceElement. */
    /* 4. If tailResult.value is empty, let (V) = headResult.value, otherwise let (V) = tailResult.value. */
    result := JS_Interpreter_Stmt(l_nth(SourceElements, i), scope) catch Interpreter_Statement_Guard;
    if (isAnAbruptCompletion(result))
      return result;
    V := getCompletionValue(result);
    i := i + 1;
  }
  /* 5. Return (tailResult.type, V, tailResult.target) */
  return newCompletion(getCompletionType(result), V, getCompletionTarget(result));
}


function JS_Interpreter_Expr(Expression, scope) {
  return JS_Interpreter_PrimaryExpression(Expression, scope);
}

/* 11.1 Primary Expressions */
function JS_Interpreter_PrimaryExpression(PrimaryExpression, scope) {
  match PrimaryExpression : type with
  /* 11.1.1 The this Keyword */
  | { type: "ThisExpression" } -> {
    /* The this keyword evaluates to the value of the ThisBinding of the current execution context. */
    return getThisBinding(scope);
  }
  /* 11.1.2 Identifier Reference */
  | { type: "Identifier", name: name } -> {
    /* An Identifier is evaluated by performing Identifier Resolution as specified in 10.3.1. The result of evaluating an
       Identifier is always a value of type Reference. */
    return IdentifierResolution(name, scope);
  }
  | { type: "Literal", regex: re, source: source } -> {
    return JS_Interpreter_RegEx_TopLevel(re, source);
  }
  /* 11.1.3 Literal Reference */
  | { type: "Literal", value: value } -> {
    /* A Literal is evaluated as described in 7.8. */
    return formingTheValueOfTheNumericLiteral(value);
  }
  /* 11.1.4 Array Initialiser */
  | { type: "ArrayExpression", elements: ElementList } -> {
    if (is_elisionopt_list (ElementList))
      return JS_Interpreter_ArrayLiteral_Elisionopt(ElementList, scope);

    ret := strip_final_elisions(ElementList);
    ElementList := hd ret;
    Elisionopt := l_nth(ret, 1);
    if (l_len(Elisionopt) == 0)
      return JS_Interpreter_ArrayLiteral_ElementList(ElementList, scope);
    return JS_Interpreter_ArrayLiteral_ElementList_Elisionopt(ElementList, Elisionopt, scope);
  }
  /* TODO Old version, that does not follow the standard as-is! To remove? */
  | { type: "ArrayExpression", elements: ElementList } -> {
    /* 11.1.4 Array Initialiser */
    arrayPrototype := getArrayPrototype(false);
    array := internalNewArray(arrayPrototype, []);
    len := l_len(ElementList);
    i := 0;
    while (i < len) {
      el := l_nth (ElementList, i);
      if (el != null) {
        initResult := JS_Interpreter_Expr(el, scope);
        initValue := GetValue(initResult);
        descriptor := newDataPropertyDescriptorFull(initValue, true, true, true);
        {array.DefineOwnProperty}(array, ToString(ToUint32(int_to_float i)), descriptor, false);
      }
      i := i + 1;
    }
    descriptor := newDataPropertyDescriptorFull(ToUint32(int_to_float i), true, false, false);
    {array.DefineOwnProperty}(array, "length", descriptor, false);
    return array;
  }
  /* 11.1.5 Object Initialiser */
  /* An object initialiser is an expression describing the initialisation of an Object, written in a form resembling a
    literal. It is a list of zero or more pairs of property names and associated values, enclosed in curly braces. The
    values need not be literals; they are evaluated each time the object initialiser is evaluated. */
  | { type: "ObjectExpression", properties: [] } -> {
    /* The production ObjectLiteral : { } is evaluated as follows: */

    /* Return a new object created as if by the expression new Object() where Object
        is the standard built-in constructor with that name. */
    return ObjectConstructor(|global|, 'null, isContainedInStrictCode(scope), [null]);
  }
  | { type: "ObjectExpression", properties: PropertyNameAndValueList } -> {
    /* The productions ObjectLiteral : { PropertyNameAndValueList } and
      ObjectLiteral : { PropertyNameAndValueList ,} are evaluated as follows: */

    /* 1. Return the result of evaluating PropertyNameAndValueList. */
    return JS_Interpreter_PropertyNameAndValueList(PropertyNameAndValueList, scope);
  }
  | { type: "ProtoAssignment", object: Object, value: Expression } -> {
    /* This pattern match is specific to this implementation and
       does not exist specified in the ES5 standard.
       Was created to test the assignment of a value to the Prototype of an object. */
    objectReference := JS_Interpreter_Expr(Object, scope);
    objectLocation := GetValue(objectReference);
    valueReference := JS_Interpreter_Expr(Expression, scope);
    value := GetValue(valueReference);
    objectLocation.Prototype := value;
    return value;
  }
  | { type: "ESLPrint", value: Argument } -> {
    arg := JS_Interpreter_Expr(Argument, scope);
    argValue := GetValue(arg);
    print s_concat(["JSPrint - ", argValue]);
    return argValue;
  }
  | default -> {
    return JS_Interpreter_LeftHandSide_Expressions(PrimaryExpression, scope);
  }
}

/*
  This function is not being called in any part of the interpreter.
  This is here present just for strictly implementing the ES5 standard
  and is also present in order to improve our automatically HTML standard generation.
 */
/* 11.1.6 The Grouping Operator */
function JS_Interpreter_Grouping(Expression, scope) {
  /* 1. Return the result of evaluating Expression. This may be of type Reference */
  return JS_Interpreter_Expr(Expression, scope);
}

/* 11.2 Left-Hand-Side Expressions */
function JS_Interpreter_LeftHandSide_Expressions(LeftHandSideExpression, scope) {
  match LeftHandSideExpression : type with
  /* 11.2.1 Property Accessors */
  | { type: "MemberExpression", object: MemberExpression, property: Expression } -> {
    /* The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows: */

    /* 1. Let baseReference be the result of evaluating MemberExpression. */
    baseReference := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let baseValue be GetValue(baseReference). */
    baseValue := GetValue(baseReference);
    /* 3. Let propertyNameReference be the result of evaluating Expression. */
    propertyNameReference := JS_Interpreter_Expr(Expression, scope);
    /* 4. Let propertyNameValue be GetValue(propertyNameReference). */
    propertyNameValue := GetValue(propertyNameReference);
    /* 5. Call CheckObjectCoercible(baseValue). */
    CheckObjectCoercible(baseValue);
    /* 6. Let propertyNameString be ToString(propertyNameValue). */
    propertyNameString := ToString(propertyNameValue);
    /* 7. If the syntactic production that is being evaluated is contained in strict mode code,
          let strict be true, else let strict be false. */
    if (isContainedInStrictCode(scope)) strict := true; else strict := false;
    /* 8. Return a value of type Reference whose base value is baseValue and whose referenced name is
          propertyNameString, and whose strict mode flag is strict. */
    return newPropertyReference(baseValue, propertyNameString, strict);
  }
  /* 11.2.2 The new Operator */
  | { type: "NewExpression", callee: MemberExpression, arguments: Arguments } -> {
    /* The production MemberExpression : new MemberExpression Arguments is evaluated as follows: */

    /* 1. Let ref be the result of evaluating MemberExpression. */
    ref := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let constructor be GetValue(ref). */
    constructor := GetValue(ref);
    /* 3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (11.2.4). */
    argList := JS_Interpreter_Arguments(Arguments, scope);
    /* 4. If Type(constructor) is not Object, throw a TypeError exception. */
    if (Type(constructor) != "Object")
      throw TypeErrorConstructorInternal();
    /* 5. If constructor does not implement the [[Construct]] internal method, throw a TypeError exception. */
    if (!("Construct" in_obj constructor))
      throw TypeErrorConstructorInternal();
    /* 6. Return the result of calling the [[Construct]] internal method on constructor, providing the list argList as the
          argument values. */
    return {constructor.Construct}(scope, ref, constructor, argList);
  }
  /* 11.2.3 Function Calls */
  | { type: "CallExpression", callee: MemberExpression, arguments: Arguments } -> {
    /* The production CallExpression : MemberExpression Arguments is evaluated as follows: */

    /* 1. Let ref be the result of evaluating MemberExpression. */
    ref := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let func be GetValue(ref). */
    func := GetValue(ref);
    /* 3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (see 11.2.4). */
    argList := JS_Interpreter_Arguments(Arguments, scope);
    /* 4. If Type(func) is not Object, throw a TypeError exception. */
    if (Type(func) != "Object")
      throw TypeErrorConstructorInternal();
    /* 5. If IsCallable(func) is false, throw a TypeError exception. */
    if (IsCallable(func) == false)
      throw TypeErrorConstructorInternal();
    /* 6. If Type(ref) is Reference, then */
    if (Type(ref) == "Reference") {
      /* a. If IsPropertyReference(ref) is true, then */
      if (IsPropertyReference(ref) == true) {
        /* i. Let thisValue be GetBase(ref). */
        thisValue := GetBase(ref);
      }
      /* b. Else, the base of ref is an Environment Record */
      else {
        /* i. Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). */
        thisValue := ImplicitThisValue(GetBase(ref));
      }
    }
    /* 7. Else, Type(ref) is not Reference. */
    else {
      /* a. Let thisValue be undefined. */
      thisValue := 'undefined;
    }
    /* 8. Return the result of calling the [[Call]] internal method on func, providing thisValue as the this value
          and providing the list argList as the argument values. */
    return {func.Call}(scope, ref, func, thisValue, argList);
  }
  /* 11.2.5 Function Expressions */
  | { type: "FunctionExpression", id: Identifier, params: FormalParameterList, body: FunctionBody } -> {
    /* The production MemberExpression : FunctionExpression is evaluated as follows: */

    /* 1. Return the result of evaluating FunctionExpression. */
    return JS_Interpreter_FunctionExpression(LeftHandSideExpression, scope);
  }
  | default -> {
    return JS_Interpreter_Postfix_Expressions(LeftHandSideExpression, scope);
  }
}

/* 11.3 Postfix Expressions */
function JS_Interpreter_Postfix_Expressions(PostfixExpression, scope) {
  match PostfixExpression : type with
  /* 11.3.1 Postfix Increment Operator */
  | { type: "UpdateExpression", operator: "++", argument: LeftHandSideExpression, prefix: false } -> {
    /* The production PostfixExpression : LeftHandSideExpression [no LineTerminator here] ++ is evaluated as follows: */

    /* 1. Let lhs be the result of evaluating LeftHandSideExpression. */
    lhs := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(lhs) is Reference is true */
      (Type(lhs) == "Reference") &&
      /* IsStrictReference(lhs) is true */
      (IsStrictReference(lhs) == true) &&
      /* Type(GetBase(lhs)) is Environment Record */
      (Type(GetBase(lhs)) == "EnvironmentRecord") &&
      /* GetReferencedName(lhs) is either "eval" or "arguments" */
      ((GetReferencedName(lhs) == "eval") || (GetReferencedName(lhs) == "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal();
    }
    /* 3. Let oldValue be ToNumber(GetValue(lhs)). */
    oldValue := ToNumber(GetValue(lhs));
    /* 4. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator
          (see 11.6.3). */
    newValue := oldValue + 1.;
    /* 5. Call PutValue(lhs, newValue). */
    PutValue(lhs, newValue);
    /* 6. Return oldValue. */
    return oldValue;
  }
  /* 11.3.2 Postfix Decrement Operator */
  | { type: "UpdateExpression", operator: "--", argument: LeftHandSideExpression, prefix: false } -> {
    /* The production PostfixExpression : LeftHandSideExpression [no LineTerminator here] -- is evaluated as follows: */

    /* 1. Let lhs be the result of evaluating LeftHandSideExpression. */
    lhs := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(lhs) is Reference is true */
      (Type(lhs) == "Reference") &&
      /* IsStrictReference(lhs) is true */
      (IsStrictReference(lhs) == true) &&
      /* Type(GetBase(lhs)) is Environment Record */
      (Type(GetBase(lhs)) == "EnvironmentRecord") &&
      /* GetReferencedName(lhs) is either "eval" or "arguments" */
      ((GetReferencedName(lhs) == "eval") || (GetReferencedName(lhs) == "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal();
    }
    /* 3. Let oldValue be ToNumber(GetValue(lhs)). */
    oldValue := ToNumber(GetValue(lhs));
    /* 4. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the -
          operator (11.6.3). */
    newValue := oldValue - 1.;
    /* 5. Call PutValue(lhs, newValue). */
    PutValue(lhs, newValue);
    /* 6. Return oldValue. */
    return oldValue;
  }
  | default -> {
    return JS_Interpreter_Unary_Operators(PostfixExpression, scope);
  }
}

/* 11.4 Unary Operators */
function JS_Interpreter_Unary_Operators(UnaryExpr, scope) {
  match UnaryExpr : type with
  /* 11.4.1 The delete Operator */
  | { type: "UnaryExpression", operator: "delete", argument: UnaryExpression } -> {
    /* The production UnaryExpression : delete UnaryExpression is evaluated as follows: */
    /* 1. Let ref be the result of evaluating UnaryExpression. */
    ref := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. If Type(ref) is not Reference, return true. */
    if (Type(ref) != "Reference")
      return true;
    /* 3. If IsUnresolvableReference(ref) then, */
    if (IsUnresolvableReference(ref)) {
      /* a. If IsStrictReference(ref) is true, throw a SyntaxError exception. */
      if (IsStrictReference(ref) == true)
        throw SyntaxErrorConstructorInternal();
      /* b. Else, return true. */
      else
        return true;
    }
    /* 4. If IsPropertyReference(ref) is true, then */
    if (IsPropertyReference(ref) == true) {
      /* a. Return the result of calling the [[Delete]] internal method on ToObject(GetBase(ref)) providing
            GetReferencedName(ref) and IsStrictReference(ref) as the arguments. */
      obj := ToObject(GetBase(ref));
      return {obj.Delete}(obj, GetReferencedName(ref), IsStrictReference(ref));
    }
    /* 5. Else, ref is a Reference to an Environment Record binding, so */
    else {
      /* a. If IsStrictReference(ref) is true, throw a SyntaxError exception. */
      if (IsStrictReference(ref) == true)
        throw SyntaxErrorConstructorInternal();
      /* b. Let bindings be GetBase(ref). */
      bindings := GetBase(ref);
      /* c. Return the result of calling the DeleteBinding concrete method of bindings, providing
            GetReferencedName(ref) as the argument. */
      return DeleteBinding(bindings, GetReferencedName(ref));
    }

    /* NOTE When a delete operator occurs within strict mode code, a SyntaxError exception is thrown if its
            UnaryExpression is a direct reference to a variable, function argument, or function name.
            In addition, if a delete operator occurs within strict mode code and the property to be deleted has
            the attribute { [[Configurable]]: false }, a TypeError exception is thrown. */
  }
  /* 11.4.2 The void Operator */
  | { type: "UnaryExpression", operator: "void", argument: UnaryExpression } -> {
    /* The production UnaryExpression : void UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Call GetValue(expr). */
    GetValue(expr);
    /* 3. Return undefined. */
    return 'undefined;
  }
  /* 11.4.3 The typeof Operator */
  | { type: "UnaryExpression", operator: "typeof", argument: UnaryExpression } -> {
    /* The production UnaryExpression : typeof UnaryExpression is evaluated as follows: */

    /* 1. Let val be the result of evaluating UnaryExpression. */
    val := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. If Type(val) is Reference, then */
    if (Type(val) == "Reference") {
      /* a. If IsUnresolvableReference(val) is true, return "undefined". */
      if (IsUnresolvableReference(val) == true)
        return "undefined";
      /* b. Let val be GetValue(val). */
      val := GetValue(val);
    }

    /* 3. Return a String determined by Type(val) according to Table 20. */
    return typeofOperatorTable(val);
  }
  /* 11.4.4 Prefix Increment Operator */
  | { type: "UpdateExpression", operator: "++", argument: UnaryExpression, prefix: true } -> {
    /* The production UnaryExpression : ++ UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(expr) is Reference is true */
      (Type(expr) == "Reference") &&
      /* IsStrictReference(expr) is true */
      (IsStrictReference(expr) == true) &&
      /* Type(GetBase(expr)) is Environment Record */
      (Type(GetBase(expr)) == "EnvironmentRecord") &&
      /* GetReferencedName(expr) is either "eval" or "arguments" */
      ((GetReferencedName(expr) == "eval") || (GetReferencedName(expr) == "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal();
    }
    /* 3. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 4. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator
          (see 11.6.3). */
    newValue := oldValue + 1.;
    /* 5. Call PutValue(expr, newValue). */
    PutValue(expr, newValue);
    /* 6. Return newValue.*/
    return newValue;
  }
  /* 11.4.5 Prefix Decrement Operator */
  | { type: "UpdateExpression", operator: "--", argument: UnaryExpression, prefix: true } -> {
    /* The production UnaryExpression : -- UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(expr) is Reference is true */
      (Type(expr) == "Reference") &&
      /* IsStrictReference(expr) is true */
      (IsStrictReference(expr) == true) &&
      /* Type(GetBase(expr)) is Environment Record */
      (Type(GetBase(expr)) == "EnvironmentRecord") &&
      /* GetReferencedName(expr) is either "eval" or "arguments" */
      ((GetReferencedName(expr) == "eval") || (GetReferencedName(expr) == "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal();
    }
    /* 3. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 4. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the -
          operator (see 11.6.3). */
    newValue := oldValue - 1.;
    /* 5. Call PutValue(expr, newValue). */
    PutValue(expr, newValue);
    /* 6. Return newValue.*/
    return newValue;
  }
  /* 11.4.6 Unary + Operator */
  | { type: "UnaryExpression", operator: "+", argument: UnaryExpression } -> {
    /* The unary + operator converts its operand to Number type. */
    /* The production UnaryExpression : + UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Return ToNumber(GetValue(expr)). */
    return ToNumber(GetValue(expr));
  }
  /* 11.4.7 Unary - Operator */
  | { type: "UnaryExpression", operator: "-", argument: UnaryExpression } -> {
    /* The unary - operator converts its operand to Number type and then negates it. Note that negating +0
       produces -0, and negating -0 produces +0. */
    /* The production UnaryExpression : - UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 3. If oldValue is NaN, return NaN. */
    if (is_NaN (oldValue))
      return NaN;
    /* 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite
          sign. */
    return -oldValue;
  }
  /* 11.4.8 Bitwise NOT Operator ( ~ ) */
  | { type: "UnaryExpression", operator: "~", argument: UnaryExpression } -> {
    /* The production UnaryExpression : ~ UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Let oldValue be ToInt32(GetValue(expr)). */
    oldValue := ToInt32(GetValue(expr));
    /* 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer. */
    return ~oldValue;
  }
  /* 11.4.9 Logical NOT Operator ( ! ) */
  | { type: "UnaryExpression", operator: "!", argument: UnaryExpression } -> {
    /* The production UnaryExpression : ! UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Let oldValue be ToBoolean(GetValue(expr)). */
    oldValue := ToBoolean(GetValue(expr));
    /* 3. If oldValue is true, return false. */
    if (oldValue == true)
      return false;
    /* 4. Return true. */
    return true;
  }
  | default -> {
    return JS_Interpreter_Multiplicative_Operators(UnaryExpr, scope);
  }
}

/* 11.5 Multiplicative Operators */
function JS_Interpreter_Multiplicative_Operators(MultiplicativeExpr, scope) {
  match MultiplicativeExpr : type with
  | { type: "BinaryExpression", operator: "*", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */
    return applyingTheMultiplicationOperator(leftNum, rightNum);
  }
  | { type: "BinaryExpression", operator: "/", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */
    return applyingTheDivisionOperator(leftNum, rightNum);
  }
  | { type: "BinaryExpression", operator: "%", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */
    return applyingTheRemainderOperator(leftNum, rightNum);
  }
  | default -> {
    return JS_Interpreter_Additive_Operators(MultiplicativeExpr, scope);
  }
}

/* 11.6 Additive Operators */
function JS_Interpreter_Additive_Operators(AdditiveExpr, scope) {
  match AdditiveExpr : type with
  /* 11.6.1 The Addition operator ( + ) */
  | { type: "BinaryExpression", operator: "+", left: AdditiveExpression, right: MultiplicativeExpression } -> {
    /* The addition operator either performs string concatenation or numeric addition. */
    /* The production AdditiveExpression : AdditiveExpression + MultiplicativeExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating AdditiveExpression. */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating MultiplicativeExpression. */
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lprim be ToPrimitive(lval). */
    lprim := ToPrimitive(lval, null);
    /* 6. Let rprim be ToPrimitive(rval). */
    rprim := ToPrimitive(rval, null);
    /* 7. If Type(lprim) is String or Type(rprim) is String, then */
    if ((Type(lprim) == "String") || (Type(rprim) == "String")) {
      /* a. Return the String that is the result of concatenating ToString( lprim) followed by ToString(rprim) */
      return s_concat([ToString(lprim), ToString(rprim)]);
    }
    /* 8. Return the result of applying the addition operation to ToNumber( lprim) and ToNumber(rprim). See the
          Note below 11.6.3. */
    return applyingTheAdditionOperation(ToNumber(lprim), ToNumber(rprim));

    /* NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6. All native ECMAScript objects
              except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the
              absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner. */

    /* NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the relational operators (11.8.5), by using the
              logical-or operation instead of the logical-and operation. */
  }
  /* 11.6.2 The Subtraction Operator ( - ) */
  | { type: "BinaryExpression", operator: "-", left: AdditiveExpression, right: MultiplicativeExpression } -> {
    /* The production AdditiveExpression : AdditiveExpression - MultiplicativeExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating AdditiveExpression. */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating MultiplicativeExpression. */
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToNumber(lval). */
    lnum := ToNumber(lval);
    /* 6. Let rnum be ToNumber(rval). */
    rnum := ToNumber(rval);
    /* 7. Return the result of applying the subtraction operation to lnum and rnum.
          See the note below 11.6.3. */
    return applyingTheSubtractionOperation(lnum, rnum);
  }
  | default -> {
    return JS_Interpreter_Bitwise_Shift_Operators(AdditiveExpr, scope);
  }
}

/* 11.7 Bitwise Shift Operators */
function JS_Interpreter_Bitwise_Shift_Operators (ShiftExpr, scope) {
  match ShiftExpr : type with
  /* 11.7.1 The Left Shift Operator ( << ) */
  | { type: "BinaryExpression", operator: "<<", left: ShiftExpression, right: AdditiveExpression } -> {
    /* Performs a bitwise left shift operation on the left operand by the amount specified by the right operand. */
    /* The production ShiftExpression : ShiftExpression << AdditiveExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer. */
    return lnum << shiftCount;
  }
  /* 11.7.2 The Signed Right Shift Operator ( >> ) */
  | { type: "BinaryExpression", operator: ">>", left: ShiftExpression, right: AdditiveExpression } -> {
    /* Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the
       right operand. */
    /* The production ShiftExpression : ShiftExpression >> AdditiveExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most
          significant bit is propagated. The result is a signed 32-bit integer. */
    return lnum >> shiftCount;
  }
  /* 11.7.3 The Unsigned Right Shift Operator ( >>> ) */
  | { type: "BinaryExpression", operator: ">>>", left: ShiftExpression, right: AdditiveExpression } -> {
    /* Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by
       the right operand. */
    /* The production ShiftExpression : ShiftExpression >>> AdditiveExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are
          filled with zero. The result is an unsigned 32-bit integer. */
    return lnum >>> shiftCount;
  }
  | default -> {
    return JS_Interpreter_Relational_Operators(ShiftExpr, scope);
  }
}

/* 11.8 Relational Operators */
/* The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship
  named by the operator holds between its two operands.
  The RelationalExpressionNoIn productions are evaluated in the same manner as the RelationalExpression
  productions except that the contained RelationalExpressionNoIn is evaluated instead of the contained
  RelationalExpression. */
function JS_Interpreter_Relational_Operators(RelationalExpr, scope) {
  match RelationalExpr : type with
  /* 11.8.1 The Less-than Operator ( < ) */
  | { type: "BinaryExpression", operator: "<", left: RelationalExpression, right: ShiftExpression } -> {
    /* The production RelationalExpression : RelationalExpression < ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison lval < rval. (see 11.8.5) */
    r := AbstractRelationalComparison(lval, rval, true);
    /* 6. If r is undefined, return false. Otherwise, return r.*/
    if (r == 'undefined)
      return false;
    
    return r;
  }
  /* 11.8.2 The Greater-than Operator ( > ) */
  | { type: "BinaryExpression", operator: ">", left: RelationalExpression, right: ShiftExpression } -> {
    /* The production RelationalExpression : RelationalExpression > ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false. (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is undefined, return false. Otherwise, return r. */
    if (r == 'undefined)
      return false;

    return r;
  }
  /* 11.8.3 The Less-than-or-equal Operator ( <= ) */
  | { type: "BinaryExpression", operator: "<=", left: RelationalExpression, right: ShiftExpression } -> {
    /* The production RelationalExpression : RelationalExpression <= ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false.
          (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is true or undefined, return false. Otherwise, return true. */
    if ((r == true) || (r == 'undefined))
      return false;
    return true;
  }
  /* 11.8.4 The Greater-than-or-equal Operator ( >= ) */
  | { type: "BinaryExpression", operator: ">=", left: RelationalExpression, right: ShiftExpression } -> {
    /* The production RelationalExpression : RelationalExpression >= ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison lval < rval. (see 11.8.5) */
    r := AbstractRelationalComparison(lval, rval, true);
    /* 6. If r is true or undefined, return false. Otherwise, return true. */
    if ((r == true) || (r == 'undefined))
      return false;
    return true;
  }
  /* 11.8.6 The instanceof operator */
  | { type: "BinaryExpression", operator: "instanceof", left: RelationalExpression, right: ShiftExpression } -> {
    /* The production RelationalExpression: RelationalExpression instanceof ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. If Type(rval) is not Object, throw a TypeError exception. */
    if (Type(rval) != "Object")
      throw TypeErrorConstructorInternal();
    /* 6. If rval does not have a [[HasInstance]] internal method, throw a TypeError exception. */
    if (!("HasInstance" in_obj rval))
      throw TypeErrorConstructorInternal();
    /* 7. Return the result of calling the [[HasInstance]] internal method of rval with argument lval. */
    return {rval.HasInstance}(rval, lval);
  }
  /* 11.8.7 The in operator */
  | { type: "BinaryExpression", operator: "in", left: RelationalExpression, right: ShiftExpression } -> {
    /* The production RelationalExpression : RelationalExpression in ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. If Type(rval) is not Object, throw a TypeError exception. */
    if (Type(rval) != "Object")
      throw TypeErrorConstructorInternal();
    /* 6. Return the result of calling the [[HasProperty]] internal method of rval with argument ToString(lval). */
    return {rval.HasProperty}(rval, ToString(lval));
  }
  | default -> {
    return JS_Interpreter_Equality_Operators(RelationalExpr, scope);
  }
}

/* 11.9 Equality Operators */
/* The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship
  named by the operator holds between its two operands.
  The EqualityExpressionNoIn productions are evaluated in the same manner as the EqualityExpression
  productions except that the contained EqualityExpressionNoIn and RelationalExpressionNoIn are evaluated
  instead of the contained EqualityExpression and RelationalExpression, respectively. */
function JS_Interpreter_Equality_Operators(EqualityExpr, scope) {
  match EqualityExpr : type with
  /* 11.9.1 The Equals Operator ( == ) */
  | { type: "BinaryExpression", operator: "==", left: EqualityExpression, right: RelationalExpression } -> {
    /* The production EqualityExpression : EqualityExpression == RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Return the result of performing abstract equality comparison rval == lval. (see 11.9.3). */
    return AbstractEqualityComparison(rval, lval);
  }
  /* 11.9.2 The Does-not-equals Operator ( != ) */
  | { type: "BinaryExpression", operator: "!=", left: EqualityExpression, right: RelationalExpression } -> {
    /* The production EqualityExpression : EqualityExpression != RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract equality comparison rval == lval. (see 11.9.3). */
    r := AbstractEqualityComparison(rval, lval);
    /* 6. If r is true, return false. Otherwise, return true. */
    if (r == true)
      return false;
    return true;
  }
  /* 11.9.4 The Strict Equals Operator ( === ) */
  | { type: "BinaryExpression", operator: "===", left: EqualityExpression, right: RelationalExpression } -> {
    /* The production EqualityExpression : EqualityExpression === RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Return the result of performing the strict equality comparison rval === lval. (See 11.9.6) */
    return StrictEqualityComparison(rval, lval);
  }
  /* 11.9.5 The Strict Does-not-equal Operator ( !== ) */
  | { type: "BinaryExpression", operator: "!==", left: EqualityExpression, right: RelationalExpression } -> {
    /* The production EqualityExpression : EqualityExpression !== RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing strict equality comparison rval === lval. (See 11.9.6) */
    r := StrictEqualityComparison(rval, lval);
    /* 6. If r is true, return false. Otherwise, return true. */
    if (r == true)
      return false;
    return true;
  }
  | default -> {
    return JS_Interpreter_Binary_Bitwise_Operators(EqualityExpr, scope);
  }
}

/* 11.10 Binary Bitwise Operators */
function JS_Interpreter_Binary_Bitwise_Operators(BitwiseExpression, scope) {
  match BitwiseExpression : type with
  /* 11.10 Binary Bitwise Operators */
  | { type: "BinaryExpression", operator: operator, left: A, right: B } -> {
    /* The production A : A @ B, where @ is one of the bitwise operators in the productions above, is evaluated as
      follows: */

    /* 1. Let lref be the result of evaluating A. */
    lref := JS_Interpreter_Expr(A, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating B. */
    rref := JS_Interpreter_Expr(B, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToInt32(rval). */
    rnum := ToInt32(rval);
    /* 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer */
    return applyBitwiseOperator(operator, lnum, rnum);
  }
  | default -> {
    return JS_Interpreter_Binary_Logical_Operators(BitwiseExpression, scope);
  }
}

/* 11.11 Binary Logical Operators */
function JS_Interpreter_Binary_Logical_Operators(LogicalExpression, scope) {
  match LogicalExpression : type with
  | { operator: "&&", left: LogicalANDExpression, right: BitwiseORExpression } -> {
    /* The production LogicalANDExpression : LogicalANDExpression && BitwiseORExpression is evaluated as follows:

    /* 1. Let lref be the result of evaluating LogicalANDExpression. */
    lref := JS_Interpreter_Expr(LogicalANDExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. If ToBoolean(lval) is false, return lval. */
    if (ToBoolean(lval) == false)
      return lval;
    /* 4. Let rref be the result of evaluating BitwiseORExpression. */
    rref := JS_Interpreter_Expr(BitwiseORExpression, scope);
    /* 5. Return GetValue(rref). */
    return GetValue(rref);
  }
  | { operator: "||", left: LogicalORExpression, right: LogicalANDExpression } -> {
    /* The production LogicalORExpression : LogicalORExpression || LogicalANDExpression is evaluated as follows:

    /* 1. Let lref be the result of evaluating LogicalORExpression. */
    lref := JS_Interpreter_Expr(LogicalORExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. If ToBoolean(lval) is true, return lval. */
    if (ToBoolean(lval) == true)
      return lval;
    /* 4. Let rref be the result of evaluating LogicalANDExpression. */
    rref := JS_Interpreter_Expr(LogicalANDExpression, scope);
    /* 5. Return GetValue(rref). */
    return GetValue(rref);
  }
  | default -> {
    return JS_Interpreter_Conditional_Operator(LogicalExpression, scope);
  }
}

/* 11.12 Conditional Operator ( ? : ) */
function JS_Interpreter_Conditional_Operator(ConditionalExpression, scope) {
  match ConditionalExpression : type with
  | { type: "ConditionalExpression", test: LogicalORExpression, consequent: firstAssignmentExpression, alternate: secondAssignmentExpression } -> {
    /* The production ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression is
       evaluated as follows: */

    /* 1. Let lref be the result of evaluating LogicalORExpression. */
    lref := JS_Interpreter_Expr(LogicalORExpression, scope);
    /* 2. If ToBoolean(GetValue(lref)) is true, then */
    if (ToBoolean(GetValue(lref)) == true) {
      /* a. Let trueRef be the result of evaluating the first AssignmentExpression. */
      trueRef := JS_Interpreter_Expr(firstAssignmentExpression, scope);
      /* b. Return GetValue(trueRef). */
      return GetValue(trueRef);
    }
    /* 3. Else */
    else {
      /* a. Let falseRef be the result of evaluating the second AssignmentExpression. */
      falseRef := JS_Interpreter_Expr(secondAssignmentExpression, scope);
      /* b. Return GetValue(falseRef). */
      return GetValue(falseRef);
    }

    /* The ConditionalExpressionNoIn production is evaluated in the same manner as the ConditionalExpression
       production except that the contained LogicalORExpressionNoIn, AssignmentExpression and AssignmentExpressionNoIn
       are evaluated instead of the contained LogicalORExpression, first AssignmentExpression and second AssignmentExpression, respectively. */

    /* NOTE The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in C and Java, which
            each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression.
            The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a
            conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression. */
  }
  | default -> {
    return JS_Interpreter_Assignment_Operators(ConditionalExpression, scope);
  }
}

/* 11.13 Assignment Operators */
/* The AssignmentExpressionNoIn productions are evaluated in the same manner as the AssignmentExpression
    productions except that the contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are evaluated
    instead of the contained ConditionalExpression and AssignmentExpression, respectively. */
function JS_Interpreter_Assignment_Operators(AssignmentExpr, scope) {
  match AssignmentExpr : type with
  /* 11.13.1 Simple Assignment ( == ) */
  | { operator: "=", left: LeftHandSideExpression, right: AssignmentExpression } -> {
    /* The production AssignmentExpression : LeftHandSideExpression == AssignmentExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating LeftHandSideExpression. */
    lref := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Let rref be the result of evaluating AssignmentExpression. */
    rref := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 3. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 4. Throw a SyntaxError exception if the following conditions are all true: */
      /* Type(lref) is Reference is true */
    if ((Type(lref) == "Reference") &&&
      /* IsStrictReference(lref) is true */
        (IsStrictReference(lref) == true) &&&
      /* Type(GetBase(lref)) is Environment Record */
        (Type(GetBase(lref)) == "EnvironmentRecord") &&&
      /* GetReferencedName(lref) is either "eval" or "arguments" */
        ((GetReferencedName(lref) == "eval") ||| (GetReferencedName(lref) == "arguments")))
      {
        throw SyntaxErrorConstructorInternal();
      }
    /* 5. Call PutValue(lref, rval). */
    PutValue(lref, rval);
    /* 6. Return rval. */
    return rval;

    /* NOTE When an assignment occurs within strict mode code, its LeftHandSide must not evaluate to an unresolvable
          reference. If it does a ReferenceError exception is thrown upon assignment. The LeftHandSide also may not be a
          reference to a data property with the attribute value {[[Writable]]:false}, to an accessor property with the attribute value
          {[[Set]]:undefined}, nor to a non-existent property of an object whose [[Extensible]] internal property has the value false. In
          these cases a TypeError exception is thrown. */
  }
  /* 11.13.2 Compound Assignment ( op= ) */
  | { operator: AssignmentOperator, left: LeftHandSideExpression, right: AssignmentExpression } -> {
    /* The production AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression, where
       AssignmentOperator is @= and @ represents one of the operators indicated above, is evaluated as follows: */

    /* 1. Let lref be the result of evaluating LeftHandSideExpression. */
    lref := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AssignmentExpression. */
    rref := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of applying operator @ to lval and rval. */
    r := applyOperator(AssignmentOperator, lval, rval);
    /* 6. Throw a SyntaxError exception if the following conditions are all true: */
      /* Type(lref) is Reference is true */
    if ((Type(lref) == "Reference") &&
      /* IsStrictReference(lref) is true */
        (IsStrictReference(lref) == true) &&
      /* Type(GetBase(lref)) is Environment Record */
        (Type(GetBase(lref)) == "EnvironmentRecord") &&
      /* GetReferencedName(lref) is either "eval" or "arguments" */
        ((GetReferencedName(lref) == "eval") || (GetReferencedName(lref) == "arguments")))
      {
        throw SyntaxErrorConstructorInternal();
      }
    /* 7. Call PutValue(lref, r). */
    PutValue(lref, r);
    /* 8. Return r. */
    return r;

    /* NOTE See NOTE 11.13.1. */
  }
  | default -> {
    return JS_Interpreter_Comma_Operator(AssignmentExpr, scope);
  }
}

/* 11.14 Comma Operator ( , ) */
function JS_Interpreter_Comma_Operator(Expression, scope) {
  match Expression : type with
  | { type: "SequenceExpression", expressions: Expressions } -> {
    AssignmentExpression := l_nth (Expressions, l_len(Expressions) - 1);
    Expressions := l_remove_last (Expressions);
    if (l_len(Expressions) == 1) Expression := l_nth(Expressions, 0); else Expression := { type: "SequenceExpression", expressions: Expressions };
    return JS_Interpreter_Comma_Operator_Expression_AssignmentExpression(Expression, AssignmentExpression, scope);
  }
}

/* 11.14 Comma Operator ( , ) */
function JS_Interpreter_Comma_Operator_Expression_AssignmentExpression(Expression, AssignmentExpression, scope) {
  /* 1. Let lref be the result of evaluating Expression. */
  lref := JS_Interpreter_Expr(Expression, scope);
  /* 2. Call GetValue(lref). */
  GetValue(lref);
  /* 3. Let rref be the result of evaluating AssignmentExpression. */
  rref := JS_Interpreter_Expr(AssignmentExpression, scope);
  /* 4. Return GetValue(rref). */
  return GetValue(rref);

  /* The ExpressionNoIn production is evaluated in the same manner as the Expression production except that the
      contained ExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained Expression and
      AssignmentExpression, respectively. */

  /* NOTE GetValue must be called even though its value is not used because it may have observable side-effects. */
}

/* The production ArrayLiteral : [ Elisionopt ] is evaluated as follows: */
function JS_Interpreter_ArrayLiteral_Elisionopt(Elision, scope) {
  /* 1. Let array be the result of creating a new object as if by the expression new Array() where Array is the standard built-in constructor with that name. */
  array := ArrayConstructor(|global|, null, isContainedInStrictCode(scope), []);
  /* 2. Let pad be the result of evaluating Elision; if not present, use the numeric value zero. */
  pad := JS_Interpreter_Elision(Elision);
  /* 3. Call the [[Put]] internal method of array with arguments "length", pad, and false. */
  {array.Put}(array, "length", pad, false);
  /* 4. Return array. */
  return array;
}

/* The production ArrayLiteral : [ ElementList ] is evaluated as follows: */
function JS_Interpreter_ArrayLiteral_ElementList(ElementList, scope) {
  /* 1. Return the result of evaluating ElementList. */
  return JS_Interpreter_ElementList(ElementList, scope);
}

/* The production ArrayLiteral : [ ElementList , Elisionopt ] is evaluated as follows: */
function JS_Interpreter_ArrayLiteral_ElementList_Elisionopt(ElementList, Elision, scope) {
  /* 1. Let array be the result of evaluating ElementList. */
  array := JS_Interpreter_ElementList(ElementList, scope);
  /* 2. Let pad be the result of evaluating Elision; if not present, use the numeric value zero. */
  pad := JS_Interpreter_Elision(Elision);
  /* 3. Let len be the result of calling the [[Get]] internal method of array with argument "length". */
  len := {array.Get}(array, "length");
  /* 4. Call the [[Put]] internal method of array with arguments "length", ToUint32(pad+len), and false. */
  {array.Put}(array, "length", ToUint32(pad+len), false);
  /* 5. Return array. */
  return array;
}

function JS_Interpreter_Elision(Elision) {
  if (l_len(Elision) == 0)
    return 0.;
  if (l_len(Elision) == 1)
    return JS_Interpreter_Elision_Base(Elision);

  Elision := l_remove_last (Elision);
  return JS_Interpreter_Elision_Recursive(Elision);
}

/* The production Elision : , is evaluated as follows: */
function JS_Interpreter_Elision_Base(Elision) {
  /* 1. Return the numeric value 1. */
  return 1.;
}

/* The production Elision : Elision , is evaluated as follows: */
function JS_Interpreter_Elision_Recursive(Elision) {
  /* 1. Let preceding be the result of evaluating Elision. */
  preceding := JS_Interpreter_Elision(Elision);
  /* 2. Return preceding+1. */
  return preceding + 1.;
}

function JS_Interpreter_ElementList(Elements, scope) {
  obj := rearrange_elementList(Elements);
  match obj : type with
  | { type: "Base", elisionOpt: Elision, assignmentExpression: AssignmentExpression } -> {
    /* The production ElementList : Elisionopt AssignmentExpression is evaluated as follows: */

    /* 1. Let array be the result of creating a new object as if by the expression new Array() where Array is the standard built-in constructor with that name. */
    array := ArrayConstructor(|global|, null, isContainedInStrictCode(scope), []);
    /* 2. Let firstIndex be the result of evaluating Elision; if not present, use the numeric value zero. */
    firstIndex := JS_Interpreter_Elision(Elision);
    /* 3. Let initResult be the result of evaluating AssignmentExpression. */
    initResult := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 4. Let initValue be GetValue(initResult). */
    initValue := GetValue(initResult);
    /* 5. Call the [[DefineOwnProperty]] internal method of array with arguments ToString(firstIndex), the Property Descriptor { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
    {array.DefineOwnProperty}(array, ToString(firstIndex), newDataPropertyDescriptorFull(initValue, true, true, true), false);
    /* 6. Return array. */
    return array;
  }
  | { type: "Recursive", elementList: ElementList, elisionOpt: Elision, assignmentExpression: AssignmentExpression } -> {
    /* The production ElementList : ElementList , Elisionopt AssignmentExpression is evaluated as follows: */

    /* 1. Let array be the result of evaluating ElementList. */
    array := JS_Interpreter_ElementList(ElementList, scope);
    /* 2. Let pad be the result of evaluating Elision; if not present, use the numeric value zero. */
    pad := JS_Interpreter_Elision(Elision);
    /* 3. Let initResult be the result of evaluating AssignmentExpression. */
    initResult := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 4. Let initValue be GetValue(initResult). */
    initValue := GetValue(initResult);
    /* 5. Let len be the result of calling the [[Get]] internal method of array with argument "length". */
    len := {array.Get}(array, "length");
    /* 6. Call the [[DefineOwnProperty]] internal method of array with arguments ToString(ToUint32((pad+len)) and the Property Descriptor { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
    {array.DefineOwnProperty}(array, ToString(ToUint32(pad+len)), newDataPropertyDescriptorFull(initValue, true, true, true), false);
    /* 7. Return array. */
    return array;
  }
}

/* 11.2.4 Argument Lists */
function JS_Interpreter_Arguments_old(ArgumentsList, scope) {
  /* The evaluation of an argument list produces a List of values (see 8.8). */

  /* The production ArgumentList : ArgumentList , AssignmentExpression is evaluated as follows:*/
  args := [];
  lArguments := l_len(ArgumentsList);
  i := 0;
  /* 1. Let precedingArgs be the result of evaluating ArgumentList. */
  while (lArguments > i) {
    /* 2. Let ref be the result of evaluating AssignmentExpression. */
    ref := JS_Interpreter_Expr(l_nth(ArgumentsList, i), scope);
    /* 3. Let arg be GetValue(ref). */
    arg := GetValue(ref);
    args := l_add(args, arg);
    i := i + 1;
  }

  /* 4. Return a List whose length is one greater than the length of precedingArgs and whose items are the items of
        precedingArgs, in order, followed at the end by arg which is the last item of the new list. */
  return args;
}

/* 11.2.4 Argument Lists */
function JS_Interpreter_Arguments(ArgumentList, scope) {
  if (l_len(ArgumentList) == 0)
    return JS_Interpreter_Arguments_Empty();
  return JS_Interpreter_Arguments_ArgumentList(ArgumentList, scope);
}

/* The production Arguments : ( ) is evaluated as follows: */
function JS_Interpreter_Arguments_Empty() {
  /* 1. Return an empty List. */
  return [];
}

/* The production Arguments : ( ArgumentList ) is evaluated as follows: */
function JS_Interpreter_Arguments_ArgumentList(ArgumentList, scope) {
  /* 1. Return the result of evaluating ArgumentList. */
  return JS_Interpreter_ArgumentList(ArgumentList, scope);
}

function JS_Interpreter_ArgumentList(ArgumentList, scope) {
  if (l_len(ArgumentList) == 1)
    return JS_Interpreter_ArgumentList_AssignmentExpression(l_nth(ArgumentList, 0), scope);
  AssignmentExpression := l_nth(ArgumentList, l_len (ArgumentList) - 1);
  ArgumentList := l_remove_last (ArgumentList);
  return JS_Interpreter_ArgumentList_ArgumentList_AssignmentExpression(ArgumentList, AssignmentExpression, scope);
}

/* The production ArgumentList : AssignmentExpression is evaluated as follows: */
function JS_Interpreter_ArgumentList_AssignmentExpression(AssignmentExpression, scope) {
  /* 1. Let ref be the result of evaluating AssignmentExpression. */
  ref := JS_Interpreter_Expr(AssignmentExpression, scope);
  /* 2. Let arg be GetValue(ref). */
  arg := GetValue(ref);
  /* 3. Return a List whose sole item is arg. */
  return [ arg ];
}

/* The production ArgumentList : ArgumentList, AssignmentExpression is evaluated as follows: */
function JS_Interpreter_ArgumentList_ArgumentList_AssignmentExpression(ArgumentList, AssignmentExpression, scope) {
  /* 1. Let precedingArgs be the result of evaluating ArgumentList. */
  precedingArgs := JS_Interpreter_ArgumentList(ArgumentList, scope);
  /* 2. Let ref be the result of evaluating AssignmentExpression. */
  ref := JS_Interpreter_Expr(AssignmentExpression, scope);
  /* 3. Let arg be GetValue(ref). */
  arg := GetValue(ref);
  /* 4. Return a List whose length is one greater than the length of precedingArgs and whose items are the items of precedingArgs,
        in order, followed at the end by arg which is the last item of the new list. */
  return l_add(precedingArgs, arg);
}

function JS_Interpreter_FunctionDeclaration(FunctionDeclaration, scope) {
  print "JS_Interpreter_FunctionDeclaration";
  /* 13 Function Definition */
  match FunctionDeclaration : type with
  | { id: Identifier, params: FormalParameterListopt, body: FunctionBody } -> {
    /* The production FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Return the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt , and body specified by FunctionBody. Pass in the VariableEnvironment of the running
          execution context as the Scope. Pass in true as the Strict flag if the FunctionDeclaration is contained in
          strict code or if its FunctionBody is strict code. */
    return CreateFunctionObject(FormalParameterListopt, FunctionBody, getVariableEnvironment(scope), isStrictModeCode(FunctionBody, scope), null);
  }
}

function JS_Interpreter_FunctionExpression(FunctionExpression, scope) {
  /* 13 Function Definition */
  match FunctionExpression : type with
  | { id: null, params: FormalParameterList, body: FunctionBody } -> {
    /* The production FunctionExpression : function ( FormalParameterList opt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Return the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt and body specified by FunctionBody. Pass in the LexicalEnvironment of the running
          execution context as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in
          strict code or if its FunctionBody is strict code. */
    return CreateFunctionObject(FormalParameterList, FunctionBody, getLexicalEnvironment(scope), isStrictModeCode(FunctionBody, scope), null);
  }
  | { id: Identifier, params: FormalParameterListopt, body: FunctionBody } -> {
    Identifier := Identifier.name;

    /* The production FunctionExpression : function Identifier ( FormalParameterList opt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context‘s
          Lexical Environment as the argument. */
    funcEnv := NewDeclarativeEnvironment(getLexicalEnvironment(scope));
    /* 2. Let envRec be funcEnv’s environment record. */
    envRec := getEnvironmentRecord(funcEnv);
    /* 3. Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument. */
    CreateImmutableBinding(envRec, Identifier);
    /* 4. Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the
          Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code. */
    closure := CreateFunctionObject(FormalParameterListopt, FunctionBody, funcEnv, isStrictModeCode(FunctionBody, scope), null);
    /* 5. Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure
          as the arguments. */
    InitializeImmutableBinding(envRec, Identifier, closure);
    /* 6. Return closure. */
    return closure;

    /* NOTE The Identifier in a FunctionExpression can be referenced from inside the FunctionExpression's FunctionBody to
            allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the Identifier in a
            FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression. */
  }
}

function JS_Interpreter_FunctionBody(FunctionBody, scope) {
  match FunctionBody : type with
  | { body: SourceElements } -> {
    /* The production FunctionBody : SourceElements opt is evaluated as follows: */

    /* 1. The code of this FunctionBody is strict mode code if it is part of a FunctionDeclaration or
          FunctionExpression that is contained in strict mode code or if the Directive Prologue (14.1)
          of its SourceElements contains a Use Strict Directive or if any of the conditions in 10.1.1 apply.
          If the code of this FunctionBody is strict mode code, SourceElements is evaluated in the following
          steps as strict mode code. Otherwise, SourceElements is evaluated in the following steps as
          non-strict mode code. */
    /* 2. If SourceElements is present return the result of evaluating SourceElements. */
    if (SourceElements != [])
      return JS_Interpreter_SourceElements(SourceElements, scope);
    /* 3. Else return (normal, undefined, empty). */
    else
      return normalEmptyCompletion('undefined);
  }
}

/* TODO Old version that does not follow the standard as-is. To Remove? */
function JS_Interpreter_ObjectInitializer_old(objExpr, scope) {
  /* 11.1.5 Object Initialiser */
  match objExpr : type with
  | { type: "ObjectExpression", properties: PropertyNameAndValueList } -> {
    /* The production ObjectLiteral : { } is evaluated as follows: */
    /* Return a new object created as if by the expression new Object() where Object
        is the standard built-in constructor with that name. */
    if (l_len(PropertyNameAndValueList) == 0)
      return ObjectConstructor(|global|,
                               'null,
                               isContainedInStrictCode(scope),
                               [null]);

    /* The production PropertyNameAndValueList : PropertyAssignment is evaluated as follows: */

    /* 1. Let obj be the result of creating a new object as if by the expression new Object()
          where Object is the standard built-in constructor with that name. */
    obj := ObjectConstructor(|global|,
                             'null,
                             isContainedInStrictCode(scope),
                             [null]);

    /* The production PropertyNameAndValueList : PropertyNameAndValueList , PropertyAssignment is evaluated as follows: */

    /* 1. Let obj be the result of evaluating PropertyNameAndValueList. */
    lPropList := l_len(PropertyNameAndValueList);
    i := 0;
    while (i < lPropList) {
      /* 2. Let propId be the result of evaluating PropertyAssignment. */
      propId := JS_Interpreter_PropertyAssignment(l_nth(PropertyNameAndValueList, i), scope);
      /* 3. Let previous be the result of calling the [[GetOwnProperty]] internal method of obj with argument
            propId.name. */
      previous := {obj.GetOwnProperty}(obj, getPropertyName(propId));
      /* 4. If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true */
      if (previous != 'undefined) {
        /* a. This production is contained in strict code and IsDataDescriptor(previous) is true and
              IsDataDescriptor(propId.descriptor) is true. */
        if (isContainedInStrictCode(scope) &&
            (IsDataPropertyDescriptor(previous) == true) &&
            (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) == true)) {
          throw SyntaxErrorConstructorInternal();
        }
        /* b. IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true. */
        if ((IsDataPropertyDescriptor(previous) == true) &&
            (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) == true)) {
          throw SyntaxErrorConstructorInternal();
        }
        /* c. IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true. */
        if ((IsAccessorPropertyDescriptor(previous) == true) &&
            (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) == true)) {
          throw SyntaxErrorConstructorInternal();
        }
        /* d. IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true and
              either both previous and propId.descriptor have [[Get]] fields or both previous and propId.descriptor
              have [[Set]] fields */
        if ((IsAccessorPropertyDescriptor(previous) == true) &&
            (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) == true) &&
            ((("Get" in_obj previous) && (previous.Get != 'undefined) && ("Get" in_obj getPropertyDescriptor(propId)) && (getPropertyDescriptor(propId).Get != 'undefined)) ||
             (("Set" in_obj previous) && (previous.Set != 'undefined) && ("Set" in_obj getPropertyDescriptor(propId)) && (getPropertyDescriptor(propId).Set != 'undefined)))) {
          throw SyntaxErrorConstructorInternal();
        }
      }

      /* 5. Call the [[DefineOwnProperty]] internal method of obj with arguments propId.name, propId.descriptor, and
            false. */
      {obj.DefineOwnProperty}(obj, getPropertyName(propId), getPropertyDescriptor(propId), false);

      i := i + 1;
    }
    /* 6. Return obj. */
    return obj;
  }
}

function JS_Interpreter_PropertyNameAndValueList(PropertyNameAndValueList, scope) {
  if (l_len(PropertyNameAndValueList) == 1)
    return JS_Interpreter_PropertyNameAndValueList_PropertyAssignment(l_nth(PropertyNameAndValueList, 0), scope);

  PropertyAssignment := l_nth(PropertyNameAndValueList, l_len (PropertyNameAndValueList) - 1);
  PropertyNameAndValueList := l_remove_last (PropertyNameAndValueList);
  return JS_Interpreter_PropertyNameAndValueList_PropertyNameAndValueList_PropertyAssignment(PropertyNameAndValueList, PropertyAssignment, scope);
}

/* The production PropertyNameAndValueList : PropertyAssignment is evaluated as follows: */
function JS_Interpreter_PropertyNameAndValueList_PropertyAssignment(PropertyAssignment, scope) {
  /* 1. Let obj be the result of creating a new object as if by the expression new Object()
        where Object is the standard built-in constructor with that name. */
  obj := ObjectConstructor(|global|, 'null, isContainedInStrictCode(scope), [null]);
  /* 2. Let propId be the result of evaluating PropertyAssignment. */
  propId := JS_Interpreter_PropertyAssignment(PropertyAssignment, scope);
  /* 3. Call the [[DefineOwnProperty]] internal method of obj with arguments propId.name, propId.descriptor, and false. */
  {obj.DefineOwnProperty}(obj, getPropertyName(propId), getPropertyDescriptor(propId), false);
  /* 4. Return obj. */
  return obj;
}

/* The production PropertyNameAndValueList : PropertyNameAndValueList , PropertyAssignment is evaluated as follows: */
function JS_Interpreter_PropertyNameAndValueList_PropertyNameAndValueList_PropertyAssignment(PropertyNameAndValueList, PropertyAssignment, scope) {
  /* 1. Let obj be the result of evaluating PropertyNameAndValueList. */
  obj := JS_Interpreter_PropertyNameAndValueList(PropertyNameAndValueList, scope);
  /* 2. Let propId be the result of evaluating PropertyAssignment. */
  propId := JS_Interpreter_PropertyAssignment(PropertyAssignment, scope);
  /* 3. Let previous be the result of calling the [[GetOwnProperty]] internal method of obj with argument propId.name. */
  previous := {obj.GetOwnProperty}(obj, getPropertyName(propId));
  /* 4. If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true */
  if (previous != 'undefined) {
    /* a. This production is contained in strict code and IsDataDescriptor(previous) is true and
          IsDataDescriptor(propId.descriptor) is true. */
    if (isContainedInStrictCode(scope) &&&
        (IsDataPropertyDescriptor(previous) == true) &&&
        (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) == true)) {
      throw SyntaxErrorConstructorInternal();
    }
    /* b. IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true. */
    if ((IsDataPropertyDescriptor(previous) == true) &&&
        (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) == true)) {
      throw SyntaxErrorConstructorInternal();
    }
    /* c. IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true. */
    if ((IsAccessorPropertyDescriptor(previous) == true) &&&
        (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) == true)) {
      throw SyntaxErrorConstructorInternal();
    }
    /* d. IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true and
          either both previous and propId.descriptor have [[Get]] fields or both previous and propId.descriptor
          have [[Set]] fields */
    if ((IsAccessorPropertyDescriptor(previous) == true) &&&
        (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) == true) &&&
        ((("Get" in_obj previous) &&& (previous.Get != 'undefined) &&& ("Get" in_obj getPropertyDescriptor(propId))
        &&& (getPropertyDescriptor(propId).Get != 'undefined)) |||
          (("Set" in_obj previous) &&& (previous.Set != 'undefined) &&& ("Set" in_obj getPropertyDescriptor(propId))
          &&& (getPropertyDescriptor(propId).Set != 'undefined)))) {
      throw SyntaxErrorConstructorInternal();
    }
  }
  /* 5. Call the [[DefineOwnProperty]] internal method of obj with arguments propId.name, propId.descriptor, and false. */
  {obj.DefineOwnProperty}(obj, getPropertyName(propId), getPropertyDescriptor(propId), false);
  /* 6. Return obj. */
  return obj;
}

function JS_Interpreter_PropertyAssignment (PropertyAssignment, scope) {
  match PropertyAssignment : type with
  /* The production PropertyAssignment : PropertyName : AssignmentExpression is evaluated as follows: */
  | { type: "Property", key: PropertyName, value: AssignmentExpression, kind: "init" } -> {
    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let exprValue be the result of evaluating AssignmentExpression. */
    exprValue := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 3. Let propValue be GetValue(exprValue). */
    propValue := GetValue(exprValue);
    /* 4. Let desc be the Property Descriptor{[[Value]]: propValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newDataPropertyDescriptor(propValue);
    /* 5. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc);
  }
  /* The production PropertyAssignment : get PropertyName ( ) { FunctionBody } is evaluated as follows: */
  | { type: "Property", key: PropertyName, value: FunctionExpression, kind: "get" } -> {
    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let closure be the result of creating a new Function object as specified in 13.2 with an empty parameter list
          and body specified by FunctionBody. Pass in the LexicalEnvironment of the running execution context as the
          Scope. Pass in true as the Strict flag if the PropertyAssignment is contained in strict code or if its
          FunctionBody is strict code. */
    closure := JS_Interpreter_FunctionExpression(FunctionExpression, scope);
    /* 3. Let desc be the Property Descriptor{[[Get]]: closure, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newGetAccessorPropertyDescriptor(closure);
    /* 4. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc);
  }
  /* The production PropertyAssignment : set PropertyName ( PropertySetParameterList ) { FunctionBody } is
      evaluated as follows: */
  | { type: "Property", key: PropertyName, value: FunctionExpression, kind: "set" } -> {
    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by
          PropertySetParameterList and body specified by FunctionBody. Pass in the LexicalEnvironment of the
          running execution context as the Scope. Pass in true as the Strict flag if the PropertyAssignment is contained
          in strict code or if its FunctionBody is strict code. */
    closure := JS_Interpreter_FunctionExpression(FunctionExpression, scope);
    /* 3. Let desc be the Property Descriptor{[[Set]]: closure, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newSetAccessorPropertyDescriptor(closure);
    /* 4. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc);
  }
}

function JS_Interpreter_PropertyName(PropertyName, scope) {
  match PropertyName : type with
  /* The production PropertyName : IdentifierName is evaluated as follows: */
  | { type: "Identifier", name: IdentifierName } -> {
    /* 1. Return the String value containing the same sequence of characters as the IdentifierName. */
    return IdentifierName;
  }
  | { type: "Literal", value: Literal } -> {
    /* The production PropertyName : StringLiteral is evaluated as follows: */
    if (typeof (Literal) == "string") {
      return JS_Interpreter_PropertyName_StringLiteral(Literal);
    }
    /* The production PropertyName : NumericLiteral is evaluated as follows: */
    return JS_Interpreter_PropertyName_NumericLiteral(Literal);
  }
}

/* The production PropertyName : StringLiteral is evaluated as follows: */
function JS_Interpreter_PropertyName_StringLiteral(StringLiteral) {
  /* 1. Return the SV of the StringLiteral. */
  return StringLiteral;
}

/* The production PropertyName : NumericLiteral is evaluated as follows: */
function JS_Interpreter_PropertyName_NumericLiteral(NumericLiteral) {
  /* 1. Let nbr be the result of forming the value of the NumericLiteral. */
  nbr := formingTheValueOfTheNumericLiteral(NumericLiteral);
  /* 2. Return ToString(nbr). */
  return ToString(nbr);
}

function JS_Interpreter_Stmt(s, scope) {
  match s : type with
  /* 12.1 Block */
  | { type: "BlockStatement" } -> {
    return JS_Interpreter_Block(s, scope);
  }
  /* 12.2 Variable Statement */
  | { type: "VariableDeclaration" } -> {
    return JS_Interpreter_VariableStatement(s, scope);
  }
  | default -> {
    return JS_Interpreter_EmptyStatement(s, scope);
  }
}

/* 12.3 Empty Statement */
function JS_Interpreter_EmptyStatement(EmptyStatement, scope) {
  match EmptyStatement : type with
  | { type: "EmptyStatement" } -> {
    return normalEmptyCompletion('empty);
  }
  | default -> {
    return JS_Interpreter_ExpressionStatement(EmptyStatement, scope);
  }
}

/* 12.4 Expression Statement */
function JS_Interpreter_ExpressionStatement(ExpressionStatement, scope) {
  match ExpressionStatement : type with
  | { type: "ExpressionStatement", expression: Expression } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (normal, GetValue(exprRef), empty). */
    return normalEmptyCompletion(GetValue(exprRef));
  }
  | default -> {
    return JS_Interpreter_IfStatement(ExpressionStatement, scope);
  }
}

/* 12.5 The if Statement */
/* Each else for which the choice of associated if is ambiguous shall be associated with the nearest possible
    if that would otherwise have no corresponding else. */
function JS_Interpreter_IfStatement(IfStatement, scope) {
  match IfStatement : type with
  /* The production IfStatement : if ( Expression ) Statement is evaluated as follows: */
  | { type: "IfStatement", test: Expression, consequent: Statement, alternate: null } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. If ToBoolean(GetValue(exprRef)) is false, return (normal, empty, empty). */
    if (ToBoolean(GetValue(exprRef)) == false)
      return normalEmptyCompletion('empty);
    /* 3. Return the result of evaluating Statement. */
    return JS_Interpreter_Stmt(Statement, scope);
  }
  /* The production IfStatement : if ( Expression ) Statement else Statement is evaluated as follows: */
  | { type: "IfStatement", test: Expression, consequent: Statement1, alternate: Statement2 } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. If ToBoolean(GetValue(exprRef)) is true, then */
    if (ToBoolean(GetValue(exprRef)) == true) /*["after-same: then"]*/ {
      /* a. Return the result of evaluating the first Statement. */
      return JS_Interpreter_Stmt(Statement1, scope);
    }
    /* 3. Else, */
    else {
      /* a. Return the result of evaluating the second Statement. */
      return JS_Interpreter_Stmt(Statement2, scope);
    }
  }
  | default -> {
    return JS_Interpreter_IterationStatement(IfStatement, scope);
  }
}

/* 12.6 Iteration Statements */
function JS_Interpreter_IterationStatement(IterationStatement, scope) {
  match IterationStatement : type with
  /* The label set of an IterationStatement or a SwitchStatement initially contains the single element empty. */
  /* 12.6 Iteration Statements */
  | { type: "DoWhileStatement" } -> {
    if (!("labelSet" in_obj IterationStatement))
      IterationStatement.labelSet := [];

    IterationStatement.labelSet := l_add(IterationStatement.labelSet, 'empty);
    return JS_Interpreter_IterationStatement_LabelSet(IterationStatement, scope);
  }
  /* 12.6 Iteration Statements */
  | { type: "WhileStatement" } -> {
    if (!("labelSet" in_obj IterationStatement))
      IterationStatement.labelSet := [];

    IterationStatement.labelSet := l_add(IterationStatement.labelSet, 'empty);
    return JS_Interpreter_IterationStatement_LabelSet(IterationStatement, scope);
  }
  /* 12.6 Iteration Statements */
  | { type: "ForStatement" } -> {
    if (!("labelSet" in_obj IterationStatement))
      IterationStatement.labelSet := [];

    IterationStatement.labelSet := l_add(IterationStatement.labelSet, 'empty);
    return JS_Interpreter_IterationStatement_LabelSet(IterationStatement, scope);
  }
  /* 12.6 Iteration Statements */
  | { type: "ForInStatement" } -> {
    if (!("labelSet" in_obj IterationStatement))
      IterationStatement.labelSet := [];

    IterationStatement.labelSet := l_add(IterationStatement.labelSet, 'empty);
    return JS_Interpreter_IterationStatement_LabelSet(IterationStatement, scope);
  }
  | default -> {
    return JS_Interpreter_ContinueStatement(IterationStatement, scope);
  }
}

/* 12.7 The continue Statement */
function JS_Interpreter_ContinueStatement(ContinueStatement, scope) {
  match ContinueStatement : type with
  /* A ContinueStatement without an Identifier is evaluated as follows: */
  | { type: "ContinueStatement", label: null } -> {
    /* 1. Return (continue, empty, empty). */
    return newCompletion('continue, 'empty, 'empty);
  }
  /* A ContinueStatement with the optional Identifier is evaluated as follows: */
  | { type: "ContinueStatement", label: Identifier } -> {
    /* 1. Return (continue, empty, Identifier). */
    return newCompletion('continue, 'empty, Identifier);
  }
  | default -> {
    return JS_Interpreter_BreakStatement(ContinueStatement, scope);
  }
}

/* 12.8 The break Statement */
function JS_Interpreter_BreakStatement(BreakStatement, scope) {
  match BreakStatement : type with
  /* A BreakStatement without an Identifier is evaluated as follows: */
  | { type: "BreakStatement", label: null } -> {
    /* 1. Return (break, empty, empty). */
    return newCompletion('break, 'empty, 'empty);
  }
  /* A BreakStatement with an Identifier is evaluated as follows: */
  | { type: "BreakStatement", label: Identifier } -> {
    /* 1. Return (break, empty, Identifier). */
    return newCompletion('break, 'empty, Identifier);
  }
  | default -> {
    return JS_Interpreter_ReturnStatement(BreakStatement, scope);
  }
}

/* 12.9 The return Statement */
function JS_Interpreter_ReturnStatement(ReturnStatement, scope) {
  match ReturnStatement : type with
  | { type: "ReturnStatement", argument: Expression } -> {
    /* 1. If the Expression is not present, return (return, undefined, empty). */
    if (Expression == null) {
      return newCompletion('return, 'undefined, 'empty);
    }
    /* 2. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 3. Return (return, GetValue(exprRef), empty). */
    return newCompletion('return, GetValue(exprRef), 'empty);
  }
  | default -> {
    return JS_Interpreter_WithStatement(ReturnStatement, scope);
  }
}

/* 12.10 The with Statement */
/* The with statement adds an object environment record for a computed object to the lexical environment of
    the current execution context. It then executes a statement using this augmented lexical environment.
    Finally, it restores the original lexical environment. */
function JS_Interpreter_WithStatement(WithStatement, scope) {
  match WithStatement : type with
  /* The production WithStatement : with ( Expression ) Statement is evaluated as follows: */
  | { type: "WithStatement", object: Expression, body: Statement } -> {
    /* 1. Let val be the result of evaluating Expression. */
    val := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let obj be ToObject(GetValue(val)). */
    obj := ToObject(GetValue(val));
    /* 3. Let oldEnv be the running execution context‘s LexicalEnvironment. */
    oldEnv := getLexicalEnvironment(scope);
    /* 4. Let newEnv be the result of calling NewObjectEnvironment passing obj and oldEnv as the arguments. */
    newEnv := NewObjectEnvironment(obj, oldEnv);
    /* 5. Set the provideThis flag of newEnv to true. */
    setProvideThis(newEnv, true);
    /* 6. Set the running execution context‘s LexicalEnvironment to newEnv. */
    setLexicalEnvironment(scope, newEnv);
    /* 7. Let C be the result of evaluating Statement but if an exception is thrown during the evaluation, let C be
          (throw, V, empty), where V is the exception. (Execution now proceeds as if no exception were thrown.) */
    C := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
    /* 8. Set the running execution context‘s Lexical Environment to oldEnv. */
    setLexicalEnvironment(scope, oldEnv);
    /* 9. Return C. */
    return C;
  }
  | default -> {
    return JS_Interpreter_SwitchStatement(WithStatement, scope);
  }
}

/* 12.11 The switch Statement */
function JS_Interpreter_SwitchStatement(SwitchStatement, scope) {
  match SwitchStatement : type with
  /* The label set of an IterationStatement or a SwitchStatement initially contains the single element empty. */
  | { type: "SwitchStatement" } -> {
    if (!("labelSet" in_obj SwitchStatement))
      SwitchStatement.labelSet := [];

    SwitchStatement.labelSet := l_add(SwitchStatement.labelSet, 'empty);
    return JS_Interpreter_SwitchStatement_LabelSet(SwitchStatement, scope);
  }
  | default -> {
    return JS_Interpreter_LabeledStatement(SwitchStatement, scope);
  }
}

/* 12.12 Labelled Statements */
function JS_Interpreter_LabeledStatement(LabeledStatement, scope) {
  match LabeledStatement : type with
  | { type: "LabeledStatement", label: Identifier, body: Statement } -> {
    /* The production Identifier : Statement is evaluated by adding Identifier to the label set of Statement
      and then evaluating Statement. */
    if (!("labelSet" in_obj Statement))
      Statement.labelSet := [];

    Statement.labelSet := l_add(Statement.labelSet, Identifier.name);
    /* If the LabelledStatement itself has a non-empty label set, these labels are also added to
       the label set of Statement before evaluating it */
    if ("labelSet" in_obj LabeledStatement)
      Statement.labelSet := l_concat(LabeledStatement.labelSet, Statement.labelSet);

    return JS_Interpreter_Stmt(Statement, scope);
  }
  | default -> {
    return JS_Interpreter_ThrowStatement(LabeledStatement, scope);
  }
}

/* 12.13 The throw Statement */
function JS_Interpreter_ThrowStatement(ThrowStatement, scope) {
  match ThrowStatement : type with
  | { type: "ThrowStatement", argument: Expression } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (throw, GetValue(exprRef), empty). */
    return newCompletion('throw, GetValue(exprRef), 'empty);
  }
  | default -> {
    return JS_Interpreter_TryStatement(ThrowStatement, scope);
  }
}

/* 12.14 The try Statement */
/* The try statement encloses a block of code in which an exceptional condition can occur, such as a runtime
    error or a throw statement. The catch clause provides the exception-handling code. When a catch clause
    catches an exception, its Identifier is bound to that exception. */
function JS_Interpreter_TryStatement(TryStatement, scope) {
  match TryStatement : type with
  /* The production TryStatement : try Block Catch is evaluated as follows: */
  | { type: "TryStatement", block: Block, handler: Catch, finalizer: null } -> {
    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Block(Block, scope);
    /* 2. If B.type is not throw, return B. */
    if (getCompletionType(B) != 'throw)
      return B;
    /* 3. Return the result of evaluating Catch with parameter B.value. */
    return JS_Interpreter_Catch(Catch, getCompletionValue(B), scope);
  }
  /* The production TryStatement : try Block Finally is evaluated as follows: */
  | { type: "TryStatement", block: Block, handler: null, finalizer: Finally } -> {
    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Block(Block, scope);
    /* 2. Let F be the result of evaluating Finally. */
    F := JS_Interpreter_Finally(Finally, scope);
    /* 3. If F.type is normal, return B. */
    if (getCompletionType(F) == 'normal)
      return B;
    /* 4. Return F. */
    return F;
  }
  /* The production TryStatement : try Block Catch Finally is evaluated as follows: */
  | { type: "TryStatement", block: Block, handler: Catch, finalizer: Finally } -> {
    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Block(Block, scope);
    /* 2. If B.type is throw, then */
    if (getCompletionType(B) == 'throw) {
      /* a. Let C be the result of evaluating Catch with parameter B.value. */
      C := JS_Interpreter_Catch(Catch, getCompletionValue(B), scope);
    }
    /* 3. Else, B.type is not throw, */
    else {
      /* a. Let C be B. */
      C := B;
    }
    /* 4. Let F be the result of evaluating Finally. */
    F := JS_Interpreter_Finally(Finally, scope);
    /* 5. If F.type is normal, return C. */
    if (getCompletionType(F) == 'normal) {
      return C;
    }
    /* 6. Return F. */
    return F;
  }
  | default -> {
    return JS_Interpreter_DebuggerStatement(TryStatement, scope);
  }
}

/* 12.15 The debugger statement */
/* Evaluating the DebuggerStatement production may allow an implementation to cause a breakpoint when run
    under a debugger. If a debugger is not present or active this statement has no observable effect. */
function JS_Interpreter_DebuggerStatement(DebuggerStatement, scope) {
  match DebuggerStatement : type with
  /* The production DebuggerStatement : debugger ; is evaluated as follows: */
  | { type: "DebuggerStatement" } -> {
    /* 1. If an implementation defined debugging facility is available and enabled, then */
    if (existsDebuggerImplementation()) {
      /* a. Perform an implementation defined debugging action. */
      implementationDefinedDebuggingAction();
      /* b. Let result be an implementation defined Completion value. */
      result := implementationDefinedCompletionValue();
    }
    /* 2. Else */
    else {
      /* a. Let result be (normal, empty, empty). */
      result := normalEmptyCompletion('empty);
    }
    /* 3. Return result. */
    return result;
  }
}

function JS_Interpreter_Catch(Catch, parameter, scope) {
  match Catch : type with
  | { type: "CatchClause", param: Identifier, body: Block } -> {
    /* The production Catch : catch ( Identifier ) Block is evaluated as follows: */
    Identifier := Identifier.name;

    /* 1. Let C be the parameter that has been passed to this production. */
    C := parameter;
    /* 2. Let oldEnv be the running execution context‘s LexicalEnvironment. */
    oldEnv := getLexicalEnvironment(scope);
    /* 3. Let catchEnv be the result of calling NewDeclarativeEnvironment passing oldEnv as the argument. */
    catchEnv := NewDeclarativeEnvironment(oldEnv);
    envRec := getEnvironmentRecord(catchEnv);
    /* 4. Call the CreateMutableBinding concrete method of catchEnv passing the Identifier String value as the
          argument. */
    CreateMutableBinding(envRec, Identifier, false); /* the third argument is optional as in the method signature */
    /* 5. Call the SetMutableBinding concrete method of catchEnv passing the Identifier, C, and false as arguments.
          Note that the last argument is immaterial in this situation. */
    SetMutableBinding(envRec, Identifier, C, false);
    /* 6. Set the running execution context‘s LexicalEnvironment to catchEnv. */
    setLexicalEnvironment(scope, catchEnv);
    /* 7. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Block(Block, scope);
    /* 8. Set the running execution context‘s LexicalEnvironment to oldEnv. */
    setLexicalEnvironment(scope, oldEnv);
    /* 9. Return B. */
    return B;
  }
}

function JS_Interpreter_Finally(Block, scope) {
  /* 1. Return the result of evaluating Block. */
  return JS_Interpreter_Block(Block, scope);
}

macro PropagateBlockLabelSet(Block, Stmts) {
  if ("labelSet" in_obj Block) {
    labelSet := Block.labelSet;
    s := l_nth(Stmts, 0);
    if ("labelSet" in_obj s) s.labelSet := l_concat(s.labelSet, labelSet); else s.labelSet := labelSet;
  }
}

function JS_Interpreter_Block(Block, scope) {
  match Block : type with
  /* The production Block : {} is evaluated as follows: */
  | { type: "BlockStatement", body: [] } -> {
    /* 1. Return (normal, empty, empty). */
    return normalEmptyCompletion('empty);
  }
  /* The production Block : { StatementList } is evaluated as follows: */
  | { type: "BlockStatement", body: StatementList } -> {
    @PropagateBlockLabelSet(Block, StatementList);
    /* 1. Return the result of evaluating StatementList. */
    return JS_Interpreter_StmtList(StatementList, scope);
  }
}

/* TODO Old version that does not follow the standard as-is. To remove? */
function JS_Interpreter_StmtList_old(stmts, scope) {
  if (l_len(stmts) == 1) {
  Statement := l_nth(stmts, 0);
    /* The production StatementList : Statement is evaluated as follows: */

    /* 1. Let s be the result of evaluating Statement. */
    /* 2. If an exception was thrown, return (throw, V, empty) where V is the exception. (Execution now proceeds as
          if no exception were thrown.) */
    s := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
    /* 3. Return s. */
    return s;
  }

  i := (l_len(stmts)) - 1;
  Statement := l_nth(stmts, i);
  StatementList := [];
  while (i > 0) {
    i := i - 1;
    StatementList := l_prepend(l_nth(stmts, i), StatementList);
  }
  /* The production StatementList : StatementList Statement is evaluated as follows: */

  /* 1. Let sl be the result of evaluating StatementList. */
  sl := JS_Interpreter_StmtList(StatementList, scope);
  /* 2. If sl is an abrupt completion, return sl. */
  if (isAnAbruptCompletion(sl))
    return sl;
  /* 3. Let s be the result of evaluating Statement. */
  /* 4. If an exception was thrown, return (throw, V, empty) where V is the exception. (Execution now proceeds as
        if no exception were thrown.) */
  s := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
  /* 5. If s.value is empty, let (V) = sl.value, otherwise let (V) = s.value. */
  if (getCompletionValue(s) == 'empty) V := getCompletionValue(sl); else V := getCompletionValue(s);
  /* 6. Return (s.type, V, s.target). */
  return newCompletion(getCompletionType(s), V, getCompletionTarget(s));
}

function JS_Interpreter_StmtList(StatementList, scope) {
  if (l_len(StatementList) == 1)
    return JS_Interpreter_StatementList_Statement(l_nth(StatementList, 0), scope);

  Statement := l_nth(StatementList, l_len(StatementList) - 1);
  StatementList := l_remove_last (StatementList);
  return JS_Interpreter_StatementList_StatementList_Statement(StatementList, Statement, scope);
}

/* The production StatementList : Statement is evaluated as follows: */
function JS_Interpreter_StatementList_Statement(Statement, scope) {
  /* 1. Let s be the result of evaluating Statement. */
  /* 2. If an exception was thrown, return (throw, V, empty) where V is the exception.
        (Execution now proceeds as if no exception were thrown.) */
  s := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
  /* 3. Return s */
  return s;
}

/* The production StatementList : StatementList Statement is evaluated as follows: */
function JS_Interpreter_StatementList_StatementList_Statement(StatementList, Statement, scope) {
  /* 1. Let sl be the result of evaluating StatementList. */
  sl := JS_Interpreter_StmtList(StatementList, scope);
  /* 2. If sl is an abrupt completion, return sl. */
  if (isAnAbruptCompletion(sl))
    return sl;
  /* 3. Let s be the result of evaluating Statement. */
  /* 4. If an exception was thrown, return (throw, V, empty) where V is the exception.
        (Execution now proceeds as if no exception were thrown.) */
  s := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
  /* 5. If s.value is empty, let (V) = sl.value, otherwise let (V) = s.value. */
  if (getCompletionValue(s) == 'empty) V := getCompletionValue(sl); else V := getCompletionValue(s);
  /* 6. Return (s.type, V, s.target). */
  return newCompletion(getCompletionType(s), V, getCompletionTarget(s));

  /* NOTE Steps 5 and 6 of the above algoritm ensure that the value of a StatementList is the value of the last value producing
          Statement in the StatementList. For example, the following calls to the eval function all return the value 1: */
  /*      eval("1;;;;;")   */
  /*      eval("1;{}")     */
  /*      eval("1;var a;") */
}

function JS_Interpreter_VariableStatement(VariableStatement, scope) {
  match VariableStatement : type with
  /* The production VariableStatement : var VariableDeclarationList ; is evaluated as follows: */
  | { type: "VariableDeclaration", declarations: VariableDeclarationList } -> {
    /* 1. Evaluate VariableDeclarationList. */
    JS_Interpreter_VariableDeclarationList(VariableDeclarationList, scope);
    /* 2. Return (normal, empty, empty).*/
    return normalEmptyCompletion('empty);
  }
}

function JS_Interpreter_VariableDeclarationList(VariableDeclarationList, scope) {
  if (l_len(VariableDeclarationList) == 1)
    return JS_Interpreter_VariableDeclarationList_VariableDeclaration(l_nth(VariableDeclarationList, 0), scope);

  VariableDeclaration := l_nth(VariableDeclarationList, l_len(VariableDeclarationList) - 1);
  VariableDeclarationList := l_remove_last (VariableDeclarationList);
  return JS_Interpreter_VariableDeclarationList_VariableDeclarationList_VariableDeclaration(VariableDeclarationList, VariableDeclaration, scope);
}

/* The production VariableDeclarationList : VariableDeclaration is evaluated as follows: */
function JS_Interpreter_VariableDeclarationList_VariableDeclaration(VariableDeclaration, scope) {
  /* 1. Evaluate VariableDeclaration. */
  JS_Interpreter_VariableDeclaration(VariableDeclaration, scope);
  return;
}

/* The production VariableDeclarationList : VariableDeclarationList, VariableDeclaration is evaluated as follows: */
function JS_Interpreter_VariableDeclarationList_VariableDeclarationList_VariableDeclaration(VariableDeclarationList, VariableDeclaration, scope) {
  /* 1. Evaluate VariableDeclarationList. */
  JS_Interpreter_VariableDeclarationList(VariableDeclarationList, scope);
  /* 2. Evaluate VariableDeclaration */
  JS_Interpreter_VariableDeclaration(VariableDeclaration, scope);
  return;
}

function JS_Interpreter_VariableDeclaration(VariableDeclaration, scope) {
  match VariableDeclaration : type with
  /* The production VariableDeclaration : Identifier is evaluated as follows: */
  | { type: "VariableDeclarator", id: Identifier, init: null } -> {
    /* 1. Return a String value containing the same sequence of characters as in the Identifier. */
    /* return Identifier.name */
    return Identifier;
  }
  /* The production VariableDeclaration : Identifier Initialiser is evaluated as follows: */
  | { type: "VariableDeclarator", id: Identifier, init: Initialiser } -> {
    /* 1. Let lhs be the result of evaluating Identifier as described in 11.1.2. */
    lhs := JS_Interpreter_Expr(Identifier, scope);
    /* 2. Let rhs be the result of evaluating Initialiser. */
    rhs := JS_Interpreter_Initialiser(Initialiser, scope);
    /* 3. Let value be GetValue(rhs). */
    value := GetValue(rhs);
    /* 4. Call PutValue(lhs, value). */
    PutValue(lhs, value);
    /* 5. Return a String value containing the same sequence of characters as in the Identifier. */
    /* return Identifier.name */
    return Identifier;
  }

  /* NOTE The String value of a VariableDeclaration is used in the evaluation of for-in statements (12.6.4). */

  /* If a VariableDeclaration is nested within a with statement and the Identifierin the VariableDeclaration is the same as
     a property name of the binding object of the with statement‘s object environment record, then step 4 will assign value
     to the property instead of to the VariableEnvironment binding of the Identifier. */
}

/* The production Initialiser := AssignmentExpression is evaluated as follows */
function JS_Interpreter_Initialiser(AssignmentExpression, scope) {
  /* 1. Return the result of evaluating AssignmentExpression. */
  return JS_Interpreter_Expr(AssignmentExpression, scope);

  /* The VariableDeclarationListNoIn, VariableDeclarationNoIn and InitialiserNoIn productions are evaluated in the same manner
     as the VariableDeclarationList, VariableDeclarationand Initialiserproductions except that the contained
     VariableDeclarationListNoIn, VariableDeclarationNoIn, InitialiserNoIn and AssignmentExpressionNoInare evaluated instead of
     the contained VariableDeclarationList, VariableDeclaration, Initialiserand AssignmentExpression, respectively. */
}

/* 12.6 Iteration Statements */
function JS_Interpreter_IterationStatement_LabelSet(iterStmt, scope) {
  match iterStmt : type with
  /* 12.6.1 The do-while Statement */
  | { type: "DoWhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Let iterating be true. */
    iterating := true;
    /* 3. Repeat, while iterating is true */
    while (iterating == true) {
      /* a. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* b. If stmt.value is not empty, let (V) = stmt.value. */
      if (getCompletionValue(stmt) != 'empty)
        V := getCompletionValue(stmt);
      /* c. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if ((getCompletionType(stmt) != 'continue) || (!(in_list(getCompletionTarget(stmt), currentLabelSet)))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
        if ((getCompletionType(stmt) == 'break) && (in_list(getCompletionTarget(stmt), currentLabelSet)))
          return normalEmptyCompletion(V);
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt))
          return stmt;
      }
      /* d. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* e. If ToBoolean(GetValue(exprRef)) is false, set iterating to false. */
      if (ToBoolean(GetValue(exprRef)) == false)
        iterating := false;
    }
    /* 4. Return (normal, V, empty); */
    return normalEmptyCompletion(V);
  }
  /* 12.6.2 The while Statement */
  | { type: "WhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Repeat */
    repeat {
      /* a. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* b. If ToBoolean(GetValue(exprRef)) is false, return (normal, V, empty). */
      if (ToBoolean(GetValue(exprRef)) == false)
        return normalEmptyCompletion(V);
      /* c. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* d. If stmt.value is not empty, let (V) = stmt.value. */
      if (getCompletionValue(stmt) != 'empty)
        V := getCompletionValue(stmt);
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if ((getCompletionType(stmt) != 'continue) || (!(in_list(getCompletionTarget(stmt), currentLabelSet)))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, then */
        if ((getCompletionType(stmt) == 'break) && (in_list(getCompletionTarget(stmt), currentLabelSet)))
          /* 1. Return (normal, V, empty). */
          return normalEmptyCompletion(V);
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt))
          return stmt;
      }
    }
  }
  /* 12.6.3 The for Statement */
  | { type: "ForStatement", init: null } -> {
      return JS_Interpreter_ForStmt_Expr(iterStmt, scope);
  }
  | { type: "ForStatement", init: Expr_or_VarDecl_or_Null } -> {
    match Expr_or_VarDecl_or_Null : type with
    | { type: "VariableDeclaration" } -> return JS_Interpreter_ForStmt_VarDecl(iterStmt, scope);
    | default -> return JS_Interpreter_ForStmt_Expr(iterStmt, scope);
  }
  /* 12.6.4 The for-in Statement */
  | { type: "ForInStatement", left: lhsExpr_or_VarDecl } -> {
    match lhsExpr_or_VarDecl : type with
    | { type: "VariableDeclarator" } -> {
      /* production IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement */
      return JS_Interpreter_ForInStmt_VarDecl(iterStmt, scope);
    }
    | default -> {
      /* production IterationStatement : for ( LeftHandSideExpression in Expression ) Statement */
      return JS_Interpreter_ForInStmt_lhsExpr(iterStmt, scope);
    }
  }
}

function JS_Interpreter_ForInStmt_lhsExpr(forInStmt, scope) {
  match forInStmt : type with
  /* The production IterationStatement : for ( LeftHandSideExpression in Expression ) Statement is evaluated as follows: */
  | { type: "ForInStatement", left: LeftHandSideExpression, right: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 1. Let exprRef be the result of evaluating the Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let experValue be GetValue(exprRef). */
    experValue := GetValue(exprRef);
    /* 3. If experValue is null or undefined, return (normal, empty, empty). */
    if ((experValue == 'null) || (experValue == 'undefined))
      return normalEmptyCompletion('empty);
    /* 4. Let obj be ToObject(experValue). */
    obj := ToObject(experValue);
    /* 5. Let V = empty. */
    V := 'empty;
    i := 0;
    obj_enums := getEnumerableProperties(obj);
    /* 6. Repeat */
    repeat {
      /* a. Let P be the name of the next property of obj whose [[Enumerable]] attribute is true.
            If there is no such property, return (normal, V, empty). */
      P := getNextPropertyName(obj_enums, i);
      i := i + 1;
      if (P == "None")
        return normalEmptyCompletion(V);
      /* b. Let lhsRef be the result of evaluating the LeftHandSideExpression ( it may be evaluated repeatedly). */
      lhsRef := JS_Interpreter_Expr(LeftHandSideExpression, scope);
      /* c. Call PutValue(lhsRef, P). */
      PutValue(lhsRef, P);
      /* d. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* e. If stmt.value is not empty, let (V) = stmt.value. */
      if (getCompletionValue(stmt) != 'empty)
        V := getCompletionValue(stmt);
      /* f. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) == 'break) && (in_list(getCompletionTarget(stmt), currentLabelSet)))
        return normalEmptyCompletion(V);
      /* g. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if ((getCompletionType(stmt) != 'continue) || !(in_list(getCompletionTarget(stmt), currentLabelSet)))
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt))
          return stmt;
    }
  }
}

function JS_Interpreter_ForInStmt_VarDecl(forInStmt, scope) {
  match forInStmt : type with
  /* The production IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement is evaluated as follows: */
  | { type: "ForInStatement", left: VariableDeclarationNoIn, right: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 1. Let varName be the result of evaluating VariableDeclarationNoIn. */
    varName := JS_Interpreter_VariableDeclaration(VariableDeclarationNoIn, scope);
    /* 2. Let exprRef be the result of evaluating the Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 3. Let experValue be GetValue(exprRef). */
    experValue := GetValue(exprRef);
    /* 4. If experValue is null or undefined, return (normal, empty, empty). */
    if ((experValue == 'null) || (experValue == 'undefined))
      return normalEmptyCompletion('empty);
    /* 5. Let obj be ToObject(experValue). */
    obj := ToObject(experValue);
    /* 6. Let V = empty. */
    V := 'empty;
    i := 0;
    obj_enums := getEnumerableProperties(obj);
    /* 7. Repeat */
    repeat {
      /* a. Let P be the name of the next property of obj whose [[Enumerable]] attribute is true.
            If there is no such property, return (normal, V, empty). */
      P := getNextPropertyName(obj_enums, i);
      i := i + 1;
      if (P == "None")
        return normalEmptyCompletion(V);
      /* b. Let varRef be the result of evaluating varName as if it were an Identifier Reference (11.1.2);
            it may be evaluated repeatedly. */
      varRef := JS_Interpreter_Expr(varName, scope);
      /* c. Call PutValue(varRef, P). */
      PutValue(varRef, P);
      /* d. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* e. If stmt.value is not empty, let (V) = stmt.value. */
      if (getCompletionValue(stmt) != 'empty)
        V := getCompletionValue(stmt);
      /* f. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) == 'break) && (in_list(getCompletionTarget(stmt), currentLabelSet)))
        return normalEmptyCompletion(V);
      /* g. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if ((getCompletionType(stmt) != 'continue) || !(in_list(getCompletionTarget(stmt), currentLabelSet)))
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt))
          return stmt;
    }
  }
}

function JS_Interpreter_ForStmt_Expr(forStmt, scope) {
  match forStmt : type with
  | { type: "ForStatement", init: ExpressionNoIn, test: Expression1, update: Expression2, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.3 The for Statement
       The production IterationStatement : for (ExpressionNoIn opt ; Expression opt ; Expression opt ) Statement
       is evaluated as follows: */

    /* 1. If ExpressionNoIn is present, then. */
    if (ExpressionNoIn != null) {
      /* a. Let exprRef be the result of evaluating ExpressionNoIn. */
      exprRef := JS_Interpreter_Expr(ExpressionNoIn, scope);
      /* b. Call GetValue(exprRef). (This value is not used but the call may have side-effects.) */
      GetValue(exprRef);
    }
    /* 2. Let V = empty. */
    V := 'empty;
    /* 3. Repeat */
    repeat {
      /* a. If the first Expression is present, then */
      if (Expression1 != null) {
        /* i. Let testExprRef be the result of evaluating the first Expression. */
        testExprRef := JS_Interpreter_Expr(Expression1, scope);
        /* ii. If ToBoolean(GetValue(testExprRef)) is false, return (normal, V, empty). */
        if (ToBoolean(GetValue(testExprRef)) == false)
          return normalEmptyCompletion(V);
      }
      /* b. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* c. If stmt.value is not empty, let (V) = stmt.value */
      if (getCompletionValue(stmt) != 'empty)
        V := getCompletionValue(stmt);
      /* d. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) == 'break) && (in_list(getCompletionTarget(stmt), currentLabelSet)))
        return normalEmptyCompletion(V);
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if ((getCompletionType(stmt) != 'continue) || !((in_list(getCompletionTarget(stmt), currentLabelSet))))
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt))
          return stmt;
      /* f. If the second Expression is present, then */
      if (Expression2 != null) {
        /* i. Let incExprRef be the result of evaluating the second Expression. */
        incExprRef := JS_Interpreter_Expr(Expression2, scope);
        /* ii. Call GetValue(incExprRef). (This value is not used.) */
        GetValue(incExprRef);
      }
    }
  }
}

function JS_Interpreter_ForStmt_VarDecl(forStmt, scope) {
  match forStmt : type with
  | { type: "ForStatement", init: VariableDeclarationListNoIn, test: Expression1, update: Expression2, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.3 The for Statement
       The production IterationStatement : for ( var VariableDeclarationListNoIn ; Expression opt ; Expression opt ) Statement
       is evaluated as follows: */

    /* 1. Evaluate VariableDeclarationListNoIn. */
    JS_Interpreter_VariableStatement(VariableDeclarationListNoIn, scope);
    /* 2. Let V = empty. */
    V := 'empty;
    /* 3. Repeat */
    repeat {
      /* a. If the first Expression is present, then */
      if (Expression1 != null) {
        /* i. Let testExprRef be the result of evaluating the first Expression. */
        testExprRef := JS_Interpreter_Expr(Expression1, scope);
        /* ii. If ToBoolean(GetValue(testExprRef)) is false, return (normal, V, empty). */
        if (ToBoolean(GetValue(testExprRef)) == false)
          return normalEmptyCompletion(V);
      }
      /* b. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* c. If stmt.value is not empty, let (V) = stmt.value */
      if (getCompletionValue(stmt) != 'empty)
        V := getCompletionValue(stmt);
      /* d. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) == 'break) && (in_list(getCompletionTarget(stmt), currentLabelSet)))
        return normalEmptyCompletion(V);
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if ((getCompletionType(stmt) != 'continue) || !((in_list(getCompletionTarget(stmt), currentLabelSet))))
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt))
          return stmt;
      /* f. If the second Expression is present, then */
      if (Expression2 != null) {
        /* i. Let incExprRef be the result of evaluating the second Expression. */
        incExprRef := JS_Interpreter_Expr(Expression2, scope);
        /* ii. Call GetValue(incExprRef). (This value is not used.) */
        GetValue(incExprRef);
      }
    }
  }
}

/* 12.11 The switch Statement */
function JS_Interpreter_SwitchStatement_LabelSet(switchStmt, scope) {
  match switchStmt : type with
  | { type: "SwitchStatement", discriminant: Expression, cases: CaseBlock, labelSet: currentLabelSet } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let R be the result of evaluating CaseBlock, passing it GetValue(exprRef) as a parameter. */
    R := JS_Interpreter_CaseBlock(CaseBlock, GetValue(exprRef), scope);
    /* 3. If R.type is break and R.target is in the current label set, return (normal, R.value, empty). */
    if ((getCompletionType(R) == 'break) && (in_list(getCompletionTarget(R), currentLabelSet)))
      return normalEmptyCompletion(getCompletionValue(R));
    /* 4. Return R. */
    return R;
  }
}

function JS_Interpreter_CaseBlock(caseBlock, input, scope) {
  /* production CaseBlock : { CaseClauses opt } */
  if (l_nth(caseBlock, 1) == null) {
    casesA := l_nth(caseBlock, 0);
    return JS_Interpreter_CaseBlock_CaseClauses(casesA, input, scope);
  } else {
    /* production CaseBlock : { CaseClauses opt DefaultClause CaseClauses opt } */
    clausesA := l_nth(caseBlock, 0);
    defaultClause := l_nth(caseBlock, 1);
    clausesB := l_nth(caseBlock, 2);
    return JS_Interpreter_CaseBlock_ClausesA_DefaultClause_ClausesB(clausesA, defaultClause, clausesB, input, scope);
  }
}

function JS_Interpreter_CaseBlock_CaseClauses(caseClauses, input, scope) {
  /* 1. Let V = empty. */
  V := 'empty;
  /* 2. Let A be the list of CaseClause items in source text order. */
  A := caseClauses;
  /* 3. Let searching be true. */
  searching := true;
  i := 0;
  /* 4. Repeat, while searching is true */
  while (searching == true) {
    /* a. Let C be the next CaseClause in A. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (C == "None")
      return normalEmptyCompletion(V);
    /* b. Let clauseSelector be the result of evaluating C. */
    clauseSelector := JS_Interpreter_SwitchCase(C, scope);
    /* c. If input is equal to clauseSelector as defined by the === operator, then */
    if (equalToAsDefinedByStrictEqualityComparison(input, clauseSelector)) {
      /* i. Set searching to false. */
      searching := false;
      /* ii. If C has a StatementList, then */
      if (hasStatementList(C)) {
        /* 1. Evaluate C‘s StatementList and let R be the result. */
        R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
        /* 2. If R is an abrupt completion, then return R. */
        if (isAnAbruptCompletion(R))
          return R;
        /* 3. Let V = R.value. */
        V := getCompletionValue(R);
      }
    }
  }
  i := 0;
  /* 5. Repeat */
  repeat {
    /* a. Let C be the next CaseClause in A. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (C == "None")
      return normalEmptyCompletion(V);
    /* b. If C has a StatementList, then */
    if (hasStatementList(C)) {
      /* i. Evaluate C‘s StatementList and let R be the result. */
      R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
      /* ii. If R.value is not empty, then let (V) = R.value. */
      if (getCompletionValue(R) != 'empty)
        V := getCompletionValue(R);
      /* iii. If R is an abrupt completion, then return (R.type, V, R.target). */
      if (isAnAbruptCompletion(R))
        return newCompletion(getCompletionType(R), V, getCompletionTarget(R));
    }
  }
}

function JS_Interpreter_CaseBlock_ClausesA_DefaultClause_ClausesB(clausesA, DefaultClause, clausesB, input, scope) {
  /* 1. Let V = empty. */
  V := 'empty;
  /* 2. Let A be the list of CaseClause items in the first CaseClauses, in source text order. */
  A := clausesA;
  /* 3. Let B be the list of CaseClause items in the second CaseClauses, in source text order. */
  B := clausesB;
  /* 4. Let found be false. */
  found := false;
  i := 0;
  /* 5. Repeat letting C be in order each CaseClause in A */
  while (allElementsHaveNotBeenProcessed(A, i)) {
    C := getNextCaseClause(A, i);
    i := i + 1;
    /* a. If found is false, then */
    if (found == false) {
      /* i. Let clauseSelector be the result of evaluating C. */
      clauseSelector := JS_Interpreter_SwitchCase(C, scope);
      /* ii. If input is equal to clauseSelector as defined by the === operator, then set found to true. */
      if (equalToAsDefinedByStrictEqualityComparison(input, clauseSelector))
        found := true;
    }
    /* b. If found is true, then */
    if (found == true) {
      /* i. If C has a StatementList, then */
      if (hasStatementList(C)) {
        /* 1. Evaluate C‘s StatementList and let R be the result. */
        R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
        /* 2. If R.value is not empty, then let (V) = R.value. */
        if (getCompletionValue(R) != 'empty)
          V := getCompletionValue(R);
        /* 3. R is an abrupt completion, then return (R.type, V, R.target). */
        if (isAnAbruptCompletion(R))
          return newCompletion(getCompletionType(R), V, getCompletionTarget(R));
      }
    }
  }
  /* 6. Let foundInB be false. */
  foundInB := false;
  i := 0;
  /* 7. If found is false, then */
  if (found == false) {
    /* a. Repeat, while foundInB is false and all elements of B have not been processed */
    while (foundInB == false &&& allElementsHaveNotBeenProcessed(B, i)) {
      /* i. Let C be the next CaseClause in B. */
      C := getNextCaseClause(B, i);
      i := i + 1;
      /* ii. Let clauseSelector be the result of evaluating C. */
      clauseSelector := JS_Interpreter_SwitchCase(C, scope);
      /* iii. If input is equal to clauseSelector as defined by the === operator, then */
      if (equalToAsDefinedByStrictEqualityComparison(input, clauseSelector)) {
        /* 1. Set foundInB to true. */
        foundInB := true;
        /* 2. If C has a StatementList, then */
        if (hasStatementList(C)) {
          /* a  Evaluate C‘s StatementList and let R be the result. */
          R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
          /* b  If R.value is not empty, then let (V) = R.value. */
          if (getCompletionValue(R) != 'empty)
            V := getCompletionValue(R);
          /* c  R is an abrupt completion, then return (R.type, V, R.target). */
          if (isAnAbruptCompletion(R))
            return newCompletion(getCompletionType(R), V, getCompletionTarget(R));
        }
      }
    }
  }
  /* 8. If foundInB is false and the DefaultClause has a StatementList, then */
  if ((foundInB == false) && hasStatementList(DefaultClause)) {
    /* a. Evaluate the DefaultClause’s StatementList and let R be the result. */
    R := JS_Interpreter_StmtList(getCaseClauseStatementList(DefaultClause), scope);
    /* b. If R.value is not empty, then let (V) = R.value. */
    if (getCompletionValue(R) != 'empty)
      V := getCompletionValue(R);
    /* c. If R is an abrupt completion, then return (R.type, V, R.target). */
    if (isAnAbruptCompletion(R))
      return newCompletion(getCompletionType(R), V, getCompletionTarget(R));
  }
  /* 9. Repeat (Note that if step 7.a.i has been performed this loop does not start at the beginning of B) */
  repeat {
    /* a. Let C be the next CaseClause in B. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(B, i);
    i := i + 1;
    if (C == "None")
      return normalEmptyCompletion(V);
    /* b. If C has a StatementList, then */
    if (hasStatementList(C)) {
      /* i. Evaluate C‘s StatementList and let R be the result. */
      R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
      /* ii. If R.value is not empty, then let (V) = R.value. */
      if (getCompletionValue(R) != 'empty)
        V := getCompletionValue(R);
      /* iii. If R is an abrupt completion, then return (R.type, V, R.target). */
      if (isAnAbruptCompletion(R))
        return newCompletion(getCompletionType(R), V, getCompletionTarget(R));
    }
  }
}

function JS_Interpreter_SwitchCase(switchCase, scope) {
  match switchCase : type with
  /* The production CaseClause : case Expression : StatementListopt is evaluated as follows: */
  | { type: "SwitchCase", test: Expression } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return GetValue(exprRef). */
    return GetValue(exprRef);
  }
}

function typeofOperatorTable(val) {
  switch(Type(val)) {
    case "Undefined": return "undefined";
    case "Null":      return "object";
    case "Boolean":   return "boolean";
    case "Number":    return "number";
    case "String":    return "string";
    case "Object": {
      /* Object (native and does not implement [[Call]]) | "object" */
      if (!("Call" in_obj val))
        return "object";
      /* Object (native or host and does implement [[Call]]) | "function" */
      else
        return "function";
    }
  }
}
