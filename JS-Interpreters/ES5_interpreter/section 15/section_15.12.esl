/* Auxiliary functions */

/* Sort according to section 9.1.12 of ES6 */
function getSortedPropertiesES6(internalSlotsList) {
  num_list := [];
  str_list := [];
  i := 0;
  len := l_len internalSlotsList;
  while (i < len) {
    P := l_nth(internalSlotsList, i);
    num := ToNumber(P);
    /* Only positive integer numbers are */
    if (!(is_NaN num) &&& (ToUint32(num) = num) &&& !(P in_list num_list)) {
      num_list := l_add(num_list, P)
    } elif (!(P in_list str_list)) {
      str_list := l_add(str_list, P)
    };
    i := i + 1
  };
  num_list := l_sort num_list;
  str_list := l_reverse str_list;
  return l_concat(num_list, str_list)
};
function getOwnEnumerablePropertiesNames(obj) {
  sortedProperties := getSortedPropertiesES6(obj.internalSlotsList); /* ordered properties according to ES6 */

  K := [];
  namedOwnProperties := sortedProperties;
  lnamedOwnProperties := l_len namedOwnProperties;
  index := 0;
  while (index < lnamedOwnProperties) {
    P := l_nth(namedOwnProperties, index);
    P_desc := obj.JSProperties[P];
    if (isEnumerablePropertyDescriptor(P_desc)) {
      K := l_add(K, P)
    };
    index := index + 1
  };
  return K
};
function concatenateListStrElmsWithSeparator(list, separator) {
  j := 0;
  pLen := l_len list;
  properties := "";
  while (j < pLen) {
    el := l_nth(list, j);
    if (el = 'null) {
      el := "null"
    };
    properties := s_concat([properties, el]);
    if (j < (pLen - 1)) {
        properties := s_concat([properties, separator])
    };
    j := j + 1
  };
  return properties
};



function initJsonObject(globalObject, ObjectPrototype, strict) {
  JsonObject := NewECMAScriptObject();
  setAllInternalMethodsOfObject(JsonObject);

  /* The value of the [[Prototype]] internal property of the JSON object is
     the standard built-in Object prototype object (15.2.4).
     The value of the [[Class]] internal property of the JSON object is "JSON".
     The value of the [[Extensible]] internal property of the JSON object is set to true. */
  setInternalProperty(JsonObject, "Prototype", ObjectPrototype);
  setInternalProperty(JsonObject, "Class", "JSON");
  setInternalProperty(JsonObject, "Extensible", true);

  /* The JSON object does not have a [[Construct]] internal property; it is
     not possible to use the JSON object as a constructor with the new operator.

     The JSON object does not have a [[Call]] internal property; it is not possible
     to invoke the JSON object as a function. */

  parse_fo := CreateBuiltInFunctionObject(["text", "reviver"], "jsonParse", globalObject, strict, null);
  setConfigurability(parse_fo, "length", true); /* ES6 */
  setJSProperty(parse_fo, "name", newDataPropertyDescriptorFull("parse", false, false, true));
  descriptor := newDataPropertyDescriptorFull(parse_fo, true, false, true);
  setJSProperty(JsonObject, "parse", descriptor);

  stringify_fo := CreateBuiltInFunctionObject(["value", "replacer", "space"], "jsonStringify", globalObject, strict, null);
  setConfigurability(stringify_fo, "length", true); /* ES6 */
  setJSProperty(stringify_fo, "name", newDataPropertyDescriptorFull("stringify", false, false, true));
  descriptor := newDataPropertyDescriptorFull(stringify_fo, true, false, true);
  setJSProperty(JsonObject, "stringify", descriptor);

  return JsonObject
};



/**
 * ES6: ECMA-404: https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf
 */
function parseJSONText(global, this, strict, args) {

  JText := l_nth(args, 0);

  if (s_len JText = 0) {
    throw SyntaxErrorConstructor(global, this, strict, ["JSON.parse: Unexpected end of JSON input"])
  };
  tokens := getTokens(global, this, strict, [JText]);

  ret := parseJSONValue(global, this, strict, tokens);

  tokens := l_nth(ret, 1);

  if (!((l_len tokens) = 0)) {
    throw SyntaxErrorConstructor(global, this, strict, ["JSON.parse: Invalid syntax."])
  } else {
    return l_nth(ret, 0)
  }
};

function isDigit(c) {
  c_code := to_char_code_u c;
  return ((c_code >= 48) &&& (c_code <= 57))
};

function unescapeJSONString(S) {
  i := 0;
  len := s_len_u(S);
  S2 := "";
  while (i < len) {
    c := s_nth_u(S, i);
    if (c = "\\") {
      if (i < (len - 1)) {
        c2 := s_nth_u(S, i + 1);
        if (c2 = "u") {
          if (i < (len - 5)) {
            str := s_substr_u(S, i, 6);
            u := utf8_decode str;
            S2 := s_concat([S2, u]);
            i := i + 4
          } else {
            throw SyntaxErrorConstructor(global, this, strict,
              ["JSON.parse: Invalid unicode escape sequence."])
          }
        } elif ((c2 = "\\") ||| (c2 = "/") ||| (c2 = "\"")) {
          S2 := s_concat([S2, c2])
        } elif (c2 = "b") {
          S2 := s_concat([S2, "\b"])
        } elif (c2 = "f") {
          S2 := s_concat([S2, "\f"])
        } elif (c2 = "n") {
          S2 := s_concat([S2, "\n"])
        } elif (c2 = "r") {
          S2 := s_concat([S2, "\r"])
        } elif (c2 = "t") {
          S2 := s_concat([S2, "\t"])
        };
        i := i + 2
      }
    } else {
      S2 := s_concat([S2, c]);
      i := i + 1
    }
  };
  return S2
};

function getTokens(global, this, strict, args) {
  JText := l_nth(args, 0);

  whitespaces := ["\x20", "\t", "\r", "\n"];
  structural_tokens := ["{", "}", "[", "]", ",", ":"];

  tokens := [];
  i := 0;
  len := s_len_u JText;
  while (i < len) {
    c := s_nth_u(JText, i);

    /* allowed white-spaces */
    if (c in_list whitespaces) {
      /* ignore */
      i := i + 1
    }
    /* structural tokens */
    elif (c in_list structural_tokens) {
      tokens := l_add(tokens, c);
      i := i + 1
    }
    /* numbers */
    elif ((c = "-") ||| isDigit(c)) {
      /**
       * JSON number regex: https://stackoverflow.com/a/13340826/3049315
       * -?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?
       *
       * Recognized Regexp constructs in OCaml Str: https://ocaml.org/api/Str.html
       * - \d not recognized in OCaml regexp
       * - non-capturing groups not recognized
       * - (, ) and | must be escaped
       */
      /*re := "-?\\(0\\|[1-9][0-9]*\\)\\(\\.[0-9]+\\)?\\([eE][+-]?[0-9]+\\)?";
      number := re_exec (re, JText, i);*/
      number := parse_number (s_substr_u (JText, i, (s_len_u JText) - i));
      num_len := s_len_u number;
      if (num_len = 0) {
        throw SyntaxErrorConstructor(global, this, strict,
          [s_concat(["JSON.parse: Unexpected token ", c, " in JSON at position ", (int_to_string i)])])
      };
      i := i + num_len;
      tokens := l_add(tokens, number)
    }
    /* Strings. */
    elif (c = "\"") {
      /**
       * JSON string regex: https://stackoverflow.com/a/32155765/3049315
       * "(\\(["\\\/bfnrt]|u[a-fA-F0-9]{4})|[^"\\\0-\x1F\x7F]+)*"
       */
      /*re := "\x22\\(\\\\\\([\x22\\\/bfnrt]\\|u[a-fA-F0-9]{4}\\)\\|[^\x22\\\0-\x1F\x7F]+\\)*\x22";
      string := re_exec (re, JText, i);*/
      string := parse_string (s_substr_u (JText, i, (s_len_u JText) - i));
      str_len := s_len_u string;

      if (str_len = 0) {
        throw SyntaxErrorConstructor(global, this, strict,
          [s_concat(["JSON.parse: Unexpected token ", c, " in JSON at position ", (int_to_string i)])])
      };
      i := i + str_len;
      string := unescapeJSONString(string);
      tokens := l_add(tokens, string)
    }
    /* literal name tokens */
    else {
      /*re := "true\\|false\\|null";
      tok := re_exec (re, JText, i);*/

      valid_tok := false;
      len := s_len_u JText;
      if (i < (len - 4)) {
        tok := s_substr_u (JText, i, 4);
        if ((tok = "true") ||| (tok = "null")) {
          i := i + 4;
          tokens := l_add(tokens, tok);
          valid_tok := true
        }
      };
      if (!valid_tok &&& (i < (len - 5))) {
        tok := s_substr_u (JText, i, 5);
        if (tok = "false") {
          i := i + 5;
          tokens := l_add(tokens, tok);
          valid_tok := true
        }
      };

      if (!valid_tok) {
        throw SyntaxErrorConstructor(global, this, strict,
          [s_concat(["JSON.parse: Unexpected token ", c, " in JSON at position ", (int_to_string i)])])
      }
    }
  };
  return tokens
};

function parseJSONValue(global, this, strict, tokens) {
  token := hd tokens;
  tokens := tl tokens;

  if (token = "null") {
    return ['null, tokens]
  } elif (token = "true") {
    return [true, tokens]
  } elif (token = "false") {
    return [false, tokens]
  } elif (!(is_NaN ToNumber(token))) {
    num := ToNumber(token);
    return [num, tokens]
  } elif ((s_nth_u(token, 0)) = "\"") {
    str := ToString(s_substr_u(token, 1, ((s_len_u token) - 2)));
    return [str, tokens]
  } elif (token = "{") {
    ret := findClosingCurlyBracket(tokens);
    obj_tokens := l_nth(ret, 0);
    tokens := l_nth(ret, 1);
    obj := parseJSONObject(global, this, strict, obj_tokens);
    return [obj, tokens]
  } elif (token = "[") {
    ret := findClosingSquareBracket(tokens);
    arr_tokens := l_nth(ret, 0);
    tokens := l_nth(ret, 1);
    arr := parseJSONArray(global, this, strict, arr_tokens);
    return [arr, tokens]
  } else {
    return []
  }
};

function parseJSONObject(global, this, strict, tokens) {
  obj := ObjectConstructor(global, this, strict, [null]);
  keys := [];

  while ((l_len tokens) > 2) {

    key := ToString(hd tokens);
    key := ToString(s_substr_u(key, 1, ((s_len_u key) - 2)));
    
    colon := hd (tl tokens);
    if (!(colon = ":")) {
      throw SyntaxErrorConstructor(global, this, strict, [s_concat(["JSON.parse: Invalid syntax. Expected colon after object key."])])
    };
    tokens := tl (tl tokens);

    ret := parseJSONValue(global, this, strict, tokens);

    if ((l_len ret) = 0) {
      throw SyntaxErrorConstructor(global, this, strict, [s_concat(["JSON.parse: Invalid syntax. Invalid value for JSON key: ", key])])
    };
    value := l_nth (ret, 0);

    {obj.DefineOwnProperty}(obj, key, {
      Value: value,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }, false);

    if ((l_len ret) = 2) {
      tokens := l_nth (ret, 1);
      if ((l_len tokens) > 0) {
        comma := hd tokens;
        if (!(comma = ",")) {
          throw SyntaxErrorConstructor(global, this, strict, ["JSON.parse: Expected comma after JSON array value."])
        };
        tokens := tl tokens
      }
    } else {
      tokens := []
    }

  };
  tokens_len := l_len tokens;
  if (tokens_len > 0) {
    throw SyntaxErrorConstructor(global, this, strict, [s_concat(["JSON.parse: Invalid syntax. Incomplete JSON object"])])
  };
  return obj
};

function parseJSONArray(global, this, strict, tokens) {
  arr := ArrayConstructor(global, this, strict, []);
  i := 0.;
  while ((l_len tokens) > 0) {
    ret := parseJSONValue(global, this, strict, tokens);
    if ((l_len ret) = 0) {
      throw SyntaxErrorConstructor(global, this, strict, ["JSON.parse: Invalid syntax. Invalid value in JSON array."])
    };
    value := l_nth (ret, 0);

    {arr.DefineOwnProperty}(arr, ToString(i), {
      Value: value,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }, false);
    i := i + 1.;

    if ((l_len ret) = 2) {
      tokens := l_nth (ret, 1);
      if ((l_len tokens) > 0) {
        comma := hd tokens;
        if (!(comma = ",")) {
          throw SyntaxErrorConstructor(global, this, strict, ["JSON.parse: Expected comma after JSON array value."])
        };
        tokens := tl tokens
      }
    } else {
      tokens := []
    }
  };
  return arr
};

function findClosingCurlyBracket(tokens) {
  obj_tokens := [];
  bracketCounter := 1;
  while ((bracketCounter > 0) &&& ((l_len tokens) > 0)) {
    token := hd tokens;
    tokens := tl tokens;
    if (token = "{") {
      bracketCounter := bracketCounter + 1
    } elif (token = "}") {
      bracketCounter := bracketCounter - 1
    };
    if (bracketCounter > 0) {
      obj_tokens := l_add (obj_tokens, token)
    }
  };
  return [obj_tokens, tokens]
};

function findClosingSquareBracket(tokens) {
  arr_tokens := [];
  bracketCounter := 1;
  while ((bracketCounter > 0) &&& ((l_len tokens) > 0)) {
    token := hd tokens;
    tokens := tl tokens;
    if (token = "[") {
      bracketCounter := bracketCounter + 1
    } elif (token = "]") {
      bracketCounter := bracketCounter - 1
    };
    if (bracketCounter > 0) {
      arr_tokens := l_add (arr_tokens, token)
    }
  };
  return [arr_tokens, tokens]
};

/**
 * 5.12.2 parse ( text [ , reviver ] )
 *
 * The parse function parses a JSON text (a JSON-formatted String) and produces
 * an ECMAScript value. The JSON format is a restricted form of ECMAScript literal.
 * JSON objects are realized as ECMAScript objects. JSON arrays are realized as
 * ECMAScript arrays. JSON strings, numbers, booleans, and null are realized as
 * ECMAScript Strings, Numbers, Booleans, and null. JSON uses a more limited set
 * of white space characters than WhiteSpace and allows Unicode code points U+2028
 * and U+2029 to directly appear in JSONString literals without using an escape
 * sequence. The process of parsing is similar to 11.1.4 and 11.1.5 as constrained
 * by the JSON grammar.
 *
 * The optional reviver parameter is a function that takes two parameters, (key
 * and value). It can filter and transform the results. It is called with each of
 * the key/value pairs produced by the parse, and its return value is used instead
 * of the original value. If it returns what it received, the structure is not
 * modified. If it returns undefined then the property is deleted from the result.
 */
function jsonParse(global, this, strict, args) {
  text := l_nth(args, 0);
  reviver := getOptionalParam(args, 1); /* - not passing 'null*/
  /*reviver := l_nth(args, 1);*/

  /* 1. Let JText be ToString(text). */
  JText := ToString(text);
  /* 2. Parse JText using the grammars in 15.12.1. Throw a SyntaxError exception
        if JText did not conform to the JSON grammar for the goal symbol JSONText. */
  objJSON := parseJSONText(global, this, strict, [JText]);

  /* 3. Let unfiltered be the result of parsing and evaluating JText as if it
        was the source text of an ECMAScript Program but using JSONString in place
        of StringLiteral. Note that since JText conforms to the JSON grammar this
        result will be either a primitive value or an object that is defined by
        either an ArrayLiteral or an ObjectLiteral. */

  unfiltered := objJSON;
  
  /* 4. If IsCallable(reviver) is true, then */
  if (IsCallable(reviver) = true) {
    /* a. Let root be a new object created as if by the expression new Object(),
          where Object is the standard built-in constructor with that name. */
    root := ObjectConstructor(|global|, 'null, strict, [null]);
    /* b. Call the [[DefineOwnProperty]] internal method of root with the empty
          String, the PropertyDescriptor {[[Value]]: unfiltered, [[Writable]]: true,
          [[Enumerable]]: true, [[Configurable]]: true}, and false as arguments. */
    descriptor := newDataPropertyDescriptorFull(unfiltered, true, true, true);
    {root.DefineOwnProperty}(root, "", descriptor, false);
    /* c. Return the result of calling the abstract operation Walk, passing root and
          the empty String. The abstract operation Walk is described below. */
    return Walk(root, "", reviver)
  }
  /* 5. Else */
  else {
  /* a. Return unfiltered. */
    return unfiltered
  }
};
/**
 * It is not permitted for a conforming implementation of JSON.parse to extend
 * the JSON grammars. If an implementation wishes to support a modified or extended
 * JSON interchange format it must do so by defining a different parse function.
 *
 * NOTE In the case where there are duplicate name Strings within an object,
 * lexically preceding values for the same key shall be overwritten.
 */




/**
 * The abstract operation Walk is a recursive abstract operation that takes two
 * parameters: a holder object and the String name of a property in that object.
 * Walk uses the value of reviver that was originally passed to the above parse
 * function.
 */
function Walk(holder, name, reviver) {
  /* 1. Let val be the result of calling the [[Get]] internal method of
        holder with argument name. */
  val := {holder.Get}(holder, name);
  /* 2. If val is an object, then */
  if (Type(val) = "Object") { /* TODO */
    /* a. If the [[Class]] internal property of val is "Array" */
    if (val.Class = "Array") {
      /* i. Set I to 0. */
      I := 0.;
      /* ii. Let len be the result of calling the [[Get]] internal method
            of val with argument "length". */
      len := {val.Get}(val, "length");
      /* iii. Repeat while I < len, */
      while (I < len) {
        /* 1. Let newElement be the result of calling the abstract operation
              Walk, passing val and ToString(I). */
        newElement := Walk(val, ToString(I), reviver);
        /* 2. If newElement is undefined, then */
        if (newElement = 'undefined) {
          /* a. Call the [[Delete]] internal method of val with ToString(I)
                and false as arguments. */
          {val.Delete}(val, ToString(I), false)
        }
        /* 3. Else */
        else {
          /* a. Call the [[DefineOwnProperty]] internal method of val with arguments
                ToString(I), the Property Descriptor {[[Value]]: newElement,
                [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
          descriptor := newDataPropertyDescriptorFull(newElement, true, true, true);
          {val.DefineOwnProperty}(val, ToString(I), descriptor, false)
        };
        /* 4. Add 1 to I. */
        I := I + 1.
      }
    }
    /* b. Else */
    else {
      /* i. Let keys be an internal List of String values consisting of the
            names of all the own properties of val whose [[Enumerable]] attribute
            is true. The ordering of the Strings should be the same as that used
            by the Object.keys standard built-in function. */
      keys := getOwnEnumerablePropertiesNames(val);
      /* ii. For each String P in keys do, */
      keysLen := l_len keys;
      index := 0;
      while(index < keysLen) {
        P := l_nth(keys, index);
        /* 1. Let newElement be the result of calling the abstract operation
              Walk, passing val and P. */
        newElement := Walk(val, P, reviver);
        /* 2. If newElement is undefined, then */
        if (newElement = 'undefined) {
          /* a. Call the [[Delete]] internal method of val with P and false
                as arguments. */
          {val.Delete}(val, P, false)
        }
        /* 3. Else */
        else {
          /* a. Call the [[DefineOwnProperty]] internal method of val with
                arguments P, the Property Descriptor {[[Value]]: newElement,
                [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]:
                true}, and false. */
          descriptor := newDataPropertyDescriptorFull(newElement, true, true, true);
          {val.DefineOwnProperty}(val, P, descriptor, false)
        };
        index := index + 1
      }
    }
  };
  /* 3. Return the result of calling the [[Call]] internal method of reviver
        passing holder as the this value and with an argument list consisting
        of name and val. */
  return {reviver.Call}(null, null, reviver, holder, [name, val])
};




/**
 * 15.12.3 stringify ( value [ , replacer [ , space ] ] )
 *
 * The stringify function returns a String in JSON format representing
 * an ECMAScript value. It can take three parameters. The first parameter
 * is required. The value parameter is an ECMAScript value, which is usually
 * an object or array, although it can also be a String, Boolean, Number or
 * null. The optional replacer parameter is either a function that alters
 * the way objects and arrays are stringified, or an array of Strings and
 * Numbers that acts as a white list for selecting the object properties
 * that will be stringified. The optional space parameter is a String or
 * Number that allows the result to have white space injected into it to
 * improve human readability.
 *
 * These are the steps in stringifying an object:
 */
function jsonStringify(global, this, strict, args) {
  value := l_nth(args, 0);

  replacer := getOptionalParam(args, 1);
  space := getOptionalParam(args, 2);

  /* 1. Let stack be an empty List. */
  stack := [];
  /* 2. Let indent be the empty String. */
  indent := "";
  /* 3. Let PropertyList and ReplacerFunction be undefined. */
  PropertyList := 'undefined;
  ReplacerFunction := 'undefined;
  /* 4. If Type(replacer) is Object, then */
  if (Type(replacer) = "Object") {
    /* a. If IsCallable(replacer) is true, then */
    if (IsCallable(replacer) = true) {
      /* i. Let ReplacerFunction be replacer. */
      ReplacerFunction := replacer
    } else {
      /* b. Else if the [[Class]] internal property of replacer is "Array", then */
      if (replacer.Class = "Array") {
        /* i. Let PropertyList be an empty internal List */
        PropertyList := [];
        /* ii. For each value v of a property of replacer that has an array
               index property name. The properties are enumerated in the
               ascending array index order of their names. */
        arrayLen := {replacer.Get}(replacer, "length");
        len := ToUint32(arrayLen);
        k := 0.;
        while (k < len) {

          v := {replacer.Get}(replacer, ToString(k));

          if (!(v = 'undefined) && !(v = 'null)) {

            /* 1. Let item be undefined. */
            item := 'undefined;
            /* 2. If Type(v) is String then let item be v. */
            if (Type(v) = "String") {
              item := v
            }
            /* 3. Else if Type(v) is Number then let item be ToString(v). */
            else {
              if (Type(v) = "Number") {
                item := ToString(v)
              }
              /* 4. Else if Type(v) is Object then, */
              else {
                if (Type(v) = "Object") {
                  /* a. If the [[Class]] internal property of v is "String" or
                        "Number" then let item be ToString(v). */
                  if ((v.Class = "String") ||| (v.Class = "Number")) {
                    item := ToString(v)
                  }
                }
              }
            };
            /* 5. If item is not undefined and item is not currently an element
                  of PropertyList then, */
            if (!(item = 'undefined) && !(item in_list PropertyList)) {
              /* a. Append item to the end of PropertyList. */
              PropertyList := l_add(PropertyList, item)
            }
          };

          k := k + 1.
        }
      }
    }
  };
  /* 5. If Type(space) is Object then, */
  if (Type(space) = "Object") {
    /* a. If the [[Class]] internal property of space is "Number" then, */
    if (space.Class = "Number") {
      /* i. Let space be ToNumber(space). */
      space := ToNumber(space)
    } else {
    /* b. Else if the [[Class]] internal property of space is "String" then, */
      if (space.Class = "String") {
        /* i. Let space be ToString(space). */
        space := ToString(space)
      }
    }
  };
  /* 6. If Type(space) is Number */
  if (Type(space) = "Number") {
    /* a. Let space be min(10, ToInteger(space)). */
    space := min(10., ToInteger(space));
    /* b. Set gap to a String containing space space characters. This will be
          the empty String if space is less than 1. */
    i := 0.;
    lst := [];
    while (i < space) {
      lst := l_prepend(" ", lst);
      i := i + 1.
    };
    gap := s_concat(lst)
  }
  /* 7. Else if Type(space) is String */
  else {
    if (Type(space) = "String") {
      /* a. If the number of characters in space is 10 or less, set gap to space
            otherwise set gap to a String consisting of the first 10 characters of space. */
      spaceLen := s_len_u space;
      if (spaceLen <= 10) {
        gap := space
      } else {
        gap := s_substr_u(space, 0, 10)
      }
    }
    /* 8. Else */
    else {
      /* a. Set gap to the empty String. */
      gap := ""
    }
  };
  /* 9. Let wrapper be a new object created as if by the expression new Object(),
        where Object is the standard built-in constructor with that name. */
  wrapper := ObjectConstructor(|global|, 'null, strict, [null]);
  /* 10. Call the [[DefineOwnProperty]] internal method of wrapper with arguments
         the empty String, the Property Descriptor {[[Value]]: value, [[Writable]]:
         true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */

  descA := newDataPropertyDescriptorFull(value, true, true, true);
  {wrapper.DefineOwnProperty}(wrapper, "", descA, false);

  /* 11. Return the result of calling the abstract operation Str with the empty
         String and wrapper. */
  return Str("", wrapper, stack, indent, gap, PropertyList, space, ReplacerFunction)
};
/**
 * NOTE 1 JSON structures are allowed to be nested to any depth, but they must be
 * acyclic. If value is or contains a cyclic structure, then the stringify function
 * must throw a TypeError exception. This is an example of a value that cannot be stringified:
 *
 * a = [];
 * a[0] = a;
 * my_text = JSON.stringify(a); // This must throw an TypeError.
 *
 * NOTE 2 Symbolic primitive values are rendered as follows:
 * - The null value is rendered in JSON text as the String null.
 * - The undefined value is not rendered.
 * - The true value is rendered in JSON text as the String true.
 * - The false value is rendered in JSON text as the String false.
 *
 * NOTE 3 String values are wrapped in double quotes. The characters " and \ are
 * escaped with \ prefixes. Control characters are replaced with escape sequences
 * \uHHHH, or with the shorter forms, \b (backspace), \f (formfeed), \n (newline),
 * \r (carriage return), \t (tab).
 *
 * NOTE 4 Finite numbers are stringified as if by calling ToString(number).
 * NaN and Infinity regardless of sign are represented as the String null.
 *
 * NOTE 5 Values that do not have a JSON representation (such as undefined and
 * functions) do not produce a String. Instead they produce the undefined value.
 * In arrays these values are represented as the String null. In objects an
 * unrepresentable value causes the property to be excluded from stringification.
 *
 * NOTE 6 An object is rendered as an opening left brace followed by zero or more
 * properties, separated with commas, closed with a right brace. A property is a
 * quoted String representing the key or property name, a colon, and then the
 * stringified property value. An array is rendered as an opening left bracket
 * followed by zero or more values, separated with commas, closed with a right bracket.
 */




/* The abstract operation Str(key, holder) has access to ReplacerFunction
   from the invocation of the stringify method. Its algorithm is as follows: */
function Str(key, holder, stack, indent, gap, PropertyList, space, ReplacerFunction) {
  /* 1. Let value be the result of calling the [[Get]] internal method
        of holder with argument key. */
  value := {holder.Get}(holder, key);
  /*value := value.Value;*/
  
  /* 2. If Type(value) is Object, then */
  if (Type(value) = "Object") {
    /* a. Let toJSON be the result of calling the [[Get]] internal
          method of value with argument "toJSON". */
    toJSON := {value.Get}(value, "toJSON");
    /* b. If IsCallable(toJSON) is true */
    if (IsCallable(toJSON) = true) {
      /* i. Let value be the result of calling the [[Call]] internal
            method of toJSON passing value as the this value and with
            an argument list consisting of key. */
      value := {toJSON.Call}(null, null, toJSON, value, [key])
    }
  };
  /* 3. If ReplacerFunction is not undefined, then */
  if (!(ReplacerFunction = 'undefined)) {
    /* a. Let value be the result of calling the [[Call]] internal
          method of ReplacerFunction passing holder as the this value
          and with an argument list consisting of key and value. */
    value := {ReplacerFunction.Call}(null, null, ReplacerFunction, holder, [key, value])
  };
  /* 4. If Type(value) is Object then, */
  if (Type(value) = "Object") {
    /* a. If the [[Class]] internal property of value is "Number" then, */
    if (value.Class = "Number") {
      /* i. Let value be ToNumber(value). */
      value := ToNumber(value)
    }
    /* b. Else if the [[Class]] internal property of value is "String" then, */
    elif (value.Class = "String") {
      /* i. Let value be ToString(value). */
      value := ToString(value)
      /* c. Else if the [[Class]] internal property of value is "Boolean" then, */
    } elif (value.Class = "Boolean") {
      /* i. Let value be the value of the [[PrimitiveValue]] internal property of value. */
      value := value.PrimitiveValue
    }
  };
  /* 5. If value is null then return "null". */
  if (value = 'null) {
    return "null"
  };
  /* 6. If value is true then return "true". */
  if (value = true) {
    return "true"
  };
  /* 7. If value is false then return "false". */
  if (value = false) {
    return "false"
  };
  /* 8. If Type(value) is String, then return the result of calling
        the abstract operation Quote with argument value. */
  if (Type(value) = "String") {
    return Quote(value)
  };
  /* 9. If Type(value) is Number */
  if (Type(value) = "Number") {
    /* a. If value is finite then return ToString(value). */
    if (!((is_NaN value) ||| (value = Infinity) ||| (value = -Infinity))) {
      return ToString(value)
    }
    /* b. Else, return "null". */
    else {
      return "null"
    }
  };
  /* 10. If Type(value) is Object, and IsCallable(value) is false */
  if ((Type(value) = "Object") && (IsCallable(value) = false)) {
    /* a. If the [[Class]] internal property of value is "Array" then */
    if (value.Class = "Array") {
      /* i. Return the result of calling the abstract operation JA with argument value. */
      return JA(value, stack, indent, gap, PropertyList, ReplacerFunction, space)
    }
    /* b. Else, return the result of calling the abstract operation JO with argument value. */
    else {
      return JO(value, stack, indent, gap, PropertyList, ReplacerFunction, space)
    }
  };
  /* 11. Return undefined. */
  return 'undefined
};


 /**
  * In section 6.1.4 of ECMA 2019
  * every code unit with a numeric value in the inclusive range 0xD800 to 0xDBFF (defined
  * by the Unicode Standard as a leading surrogate, or more formally as a high-surrogate
  * code unit) and every code unit with a numeric value in the inclusive range 0xDC00 to
  * 0xDFFF (defined as a trailing surrogate, or more formally as a low-surrogate code unit) 
  */
function isUnicodeSurrogate(code) {
  start := to_char_code_u "\u{D800}";
  end := to_char_code_u "\u{DFFF}";
  if ((code >= start) &&& (code <= end)) {
    return true
  } else {
    return false
  }
};



/**
 * The abstract operation Quote(value) wraps a String value in double quotes
 * and escapes characters within it.
 */
function Quote(value) {
  /* 1. Let product be the double quote character. */
  product := "\"";
  /* 2. For each character C in value */
  valueLen := s_len_u value;
  i := 0;
  while (i < valueLen) {
    C := s_nth_u(value, i);
    C_code := to_char_code_u C;

    /* a. If C is the double quote character or the backslash character */
    if ((C = "\"") ||| (C = "\\")) {
      /* i. Let product be the concatenation of product and the backslash character. */
      product := s_concat([product, "\\"]);
      /* ii. Let product be the concatenation of product and C. */
      product := s_concat([product, C])
    }
    /* b. Else if C is backspace, formfeed, newline, carriage return, or tab */
    elif ((C = "\b") ||| (C = "\f") ||| (C = "\n") ||| (C = "\r") ||| (C = "\t")) {
      /* i. Let product be the concatenation of product and the backslash character. */
      product := s_concat([product, "\\"]);
      /* ii. Let abbrev be the character corresponding to the value of C as follows: */
        /*  backspace        "b" */
        /*  formfeed         "f" */
        /*  newline          "n" */
        /*  carriage return  "r" */
        /*  tab              "t" */
      if (C = "\b") {
        abbrev := "b"
      } elif (C = "\f") {
        abbrev := "f"
      } elif (C = "\n") {
        abbrev := "n"
      } elif (C = "\r") {
        abbrev := "r"
      } elif (C = "\t") {
        abbrev := "t"
      };
      /* iii. Let product be the concatenation of product and abbrev. */
      product := s_concat([product, abbrev])
    }
    /* ES5: c. Else if C is a control character having a code unit value less than the space character */
    /* ES 2019: Else if C has a numeric value less than 0x0020 (SPACE), or
       if C has the same numeric value as a leading surrogate or trailing surrogate, then */
    elif ((C_code < 32) ||| isUnicodeSurrogate(C_code)) {
      print "INSIDE QUOTE";
      print C_code;
      /* i. Let product be the concatenation of product and the backslash character. */
      product := s_concat([product, "\\"]);
      /* ii. Let product be the concatenation of product and "u". */
      product := s_concat([product, "u"]);
      /* iii. Let hex be the result of converting the numeric code unit value of
              C to a String of four hexadecimal digits. */
      hex := int_to_four_hex (to_char_code_u C);
      /* iv. Let product be the concatenation of product and hex. */
      product := s_concat([product, hex])
    }
    /* d. Else */
    else {
      /* i. Let product be the concatenation of product and C. */
      product := s_concat([product, C])
    };

    i := i + 1
  };
  /* 3. Let product be the concatenation of product and the double quote character. */
  product := s_concat([product, "\""]);
  /* 4. Return product. */
  return product
};




/**
 * The abstract operation JO(value) serializes an object. It has access to
 * the stack, indent, gap, PropertyList, ReplacerFunction, and space of the
 * invocation of the stringify method.
 */
function JO(value, stack, indent, gap, PropertyList, ReplacerFunction, space) {
  /* 1. If stack contains value then throw a TypeError exception because
        the structure is cyclical. */
  if (value in_list stack) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Append value to stack. */
  stack := l_add(stack, value);
  /* 3. Let stepback be indent. */
  stepback := indent;
  /* 4. Let indent be the concatenation of indent and gap. */
  indent := s_concat([indent, gap]);
  /* 5. If PropertyList is not undefined, then */
  if (!(PropertyList = 'undefined)) {
    /* a. Let K be PropertyList. */
    K := PropertyList
  }
  /* 6. Else */
  else {
    /* a. Let K be an internal List of Strings consisting of the names of
          all the own properties of value whose [[Enumerable]] attribute
          is true. The ordering of the Strings should be the same as that
          used by the Object.keys standard built-in function. */
    K := getOwnEnumerablePropertiesNames(value)
  };
  /* 7. Let partial be an empty List. */
  partial := [];
  /* 8. For each element P of K. */
  i := 0;
  kLen := l_len K;
  while (i < kLen) {
    P := l_nth(K, i);
    /* a. Let strP be the result of calling the abstract operation Str
          with arguments P and value. */
    strP := Str(P, value, stack, indent, gap, PropertyList, space, ReplacerFunction);
    /* b. If strP is not undefined */
    if (!(strP = 'undefined)) {
      /* i. Let member be the result of calling the abstract operation
            Quote with argument P. */
      member := Quote(P);
      /* ii. Let member be the concatenation of member and the colon character. */
      member := s_concat([member, ":"]);
      /* iii. If gap is not the empty String */
      if (!(gap = "")) {
        /* 1. Let member be the concatenation of member and the space character. */
        member := s_concat([member, " "])
      };
      /* iv. Let member be the concatenation of member and strP. */
      member := s_concat([member, strP]);
      /* v. Append member to partial. */
      partial := l_add(partial, member)
    };
    i := i + 1
  };
  /* 9. If partial is empty, then */
  if ((l_len partial) = 0) {
    /* a. Let final be "{}". */
    final := "{}"
  }
  /* 10. Else */
  else {
    /* a. If gap is the empty String */
    if (gap = "") {
      /* i. Let properties be a String formed by concatenating all the
            element Strings of partial with each adjacent pair of Strings
            separated with the comma character. A comma is not inserted either
            before the first String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, ",");
      /* ii. Let final be the result of concatenating "{", properties, and "}". */
      final := s_concat(["{", properties, "}"])
    }
    /* b. Else gap is not the empty String */
    else {
      /* i. Let separator be the result of concatenating the comma character,
            the line feed character, and indent. */
      separator := s_concat([",", "\n", indent]);
      /* ii. Let properties be a String formed by concatenating all the element
             Strings of partial with each adjacent pair of Strings separated
             with separator. The separator String is not inserted either before
             the first String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, separator);
      /* iii. Let final be the result of concatenating "{", the line feed
              character, indent, properties, the line feed character, stepback, and "}". */
      final := s_concat(["{", "\n", indent, properties, "\n", stepback, "}"])
    }
  };
  /* 11. Remove the last element of stack. */
  l_remove_last stack;
  /* 12. Let indent be stepback. */
  indent := stepback;
  /* 13. Return final. */
  return final
};




/**
 * The abstract operation JA(value) serializes an array. It has access to the
 * stack, indent, gap, and space of the invocation of the stringify method. The
 * representation of arrays includes only the elements between zero and
 * array.length â€“ 1 inclusive. Named properties are excluded from the
 * stringification. An array is stringified as an open left bracket, elements
 * separated by comma, and a closing right bracket.
 */
function JA(value, stack, indent, gap, PropertyList, ReplacerFunction, space) {
  /* 1. If stack contains value then throw a TypeError exception because
        the structure is cyclical. */
  if (value in_list stack) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Append value to stack. */
  stack := l_add(stack, value);
  /* 3. Let stepback be indent. */
  stepback := indent;
  /* 4. Let indent be the concatenation of indent and gap. */
  indent := s_concat([indent, gap]);
  /* 5. Let partial be an empty List. */
  partial := [];
  /* 6. Let len be the result of calling the [[Get]] internal method of
        value with argument "length". */
  len := {value.Get}(value, "length");
  /* 7. Let index be 0. */
  index := 0.;
  /* 8. Repeat while index < len */
  while (index < len) {
    /* a. Let strP be the result of calling the abstract operation Str
          with arguments ToString(index) and value. */
    strP := Str(ToString(index), value, stack, indent, gap, PropertyList, space, ReplacerFunction);
    /* b. If strP is undefined */
    if (strP = 'undefined) {
      /* i. Append "null" to partial. */
      partial := l_add(partial, 'null)
    }
    /* c. Else */
    else {
      /* i. Append strP to partial. */
      partial := l_add(partial, strP)
    };
    /* d. Increment index by 1. */
    index := index + 1.
  };
  /* 9. If partial is empty ,then */
  if ((l_len partial) = 0) {
    /* a. Let final be "[]". */
    final := "[]"
  }
  /* 10. Else */
  else {
    /* a. If gap is the empty String */
    if (gap = "") {
      /* i. Let properties be a String formed by concatenating all the element
            Strings of partial with each adjacent pair of Strings separated with
            the comma character. A comma is not inserted either before the first
            String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, ",");
      /* ii. Let final be the result of concatenating "[", properties, and "]". */
      final := s_concat(["[", properties, "]"])
    }
    /* b. Else */
    else {
      /* i. Let separator be the result of concatenating the comma character,
            the line feed character, and indent. */
      separator := s_concat([",", "\n", indent]);
      /* ii. Let properties be a String formed by concatenating all the element
             Strings of partial with each adjacent pair of Strings separated with
             separator. The separator String is not inserted either before the
             first String or after the last String. */
      properties := concatenateListStrElmsWithSeparator(partial, separator);
      /* iii. Let final be the result of concatenating "[", the line feed character,
              indent, properties, the line feed character, stepback, and "]". */
      final := s_concat(["[", "\n", indent, properties, "\n", stepback, "]"])
    }
  };
  /* 11. Remove the last element of stack. */
  l_remove_last stack;
  /* 12. Let indent be stepback. */
  indent := stepback;
  /* 13. Return final. */
  return final
}
