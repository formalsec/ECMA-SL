
/**
 * 7.3.3 Set (O, P, V, Throw)
 * The abstract operation Set is used to set the value of a specific property of an object. 
 * The operation is called with arguments O, P, V, and Throw where O is the object, P is the property key,
 * V is the new value for the property and Throw is a Boolean flag. 
 * 
 * This abstract operation performs the following steps:
*/
function SetNew(O, P, V, Throw) {
	/* Assert: Type(O) is Object. */
	assert(Type(O) = "Object");

	/* Assert: IsPropertyKey(P) is true. */
	assert( IsPropertyKey(P) = true );

	/* Assert: Type(Throw) is Boolean. */
	assert( Type(Throw) = "Boolean" );


	/* Let success be O.[[Set]](P, V, O). */
	success := {O.Put}(O, P, V, O);

	/* ReturnIfAbrupt(success). */
	/*
  @ReturnIfAbrupt(success);
  */

	/* If success is false and Throw is true, throw a TypeError exception. */
	if ( (success = false) &&& (Throw = true) ) {
		throw TypeErrorConstructorInternal()
	};

	/* Return success. */
	return success
};

/**
 *  7.3.4 CreateDataProperty (O, P, V)
 * The abstract operation CreateDataProperty is used to create a new own property of an object.
 * The operation is called with arguments O, P, and V where O is the object, P is the property key,
 * and V is the value for the property.
 * 
 * This abstract operation performs the following steps:
*/
function CreateDataPropertyNew(O,P,V) {
	/* Assert: Type(O) is Object. */
	assert( Type(O) = "Object" );

	/* Assert: IsPropertyKey(P) is true. */
	assert( IsPropertyKey(P) = true );

	/* Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}. */
	newDesc := newDataPropertyDescriptorFull(V, true, true, true);

	/* Return O.[[DefineOwnProperty]](P, newDesc). */
	return {O.DefineOwnProperty}(O, P, newDesc)  
};


/**
 * 7.2.3 IsCallable ( argument )
 * 
 * The abstract operation IsCallable determines if argument, which must be an ECMAScript language value or a
 * Completion Record, is a callable function with a [[Call]] internal method.
*/
function IsCallableNew( argument ) {
	/* ReturnIfAbrupt(argument). */
	@ReturnIfAbrupt(argument);

	/* If Type(argument) is not Object, return false. */
	if ( !(Type(argument) = "Object") ) {
		return false
	};

	/* If argument has a [[Call]] internal method, return true. */
	if ( "Call" in_obj argument ) {
		return true
	};

	/* Return false. */
	return false
};


/**
 * 7.3.13 Construct (F, [argumentsList], [newTarget]) 
 * The abstract operation Construct is used to call the [[Construct]] internal method of a function object.
 * The operation is called with arguments F, and optionally argumentsList, and newTarget where F is the function object.
 * argumentsList and newTarget are the values to be passed as the corresponding arguments of the internal method. 
 * If argumentsList is not present, an empty List is used as its value. If newTarget is not present, F is used as its value. 
 * 
 * This abstract operation performs the following steps:
*/
function ConstructNew(F, argumentsList, newTarget) {
	/* If newTarget was not passed, let newTarget be F. */
 	if ( newTarget = null ) { 
 		newTarget := F
 	};

 	/* If argumentsList was not passed, let argumentsList be a new empty List. */
 	if ( argumentsList = null ) {
 		argumentsList := []
 	};

 	/* Assert: IsConstructor (F) is true. */
 	assert( IsConstructor(F) = true ); 

 	/* Assert: IsConstructor (newTarget) is true. */
 	assert( IsConstructor(newTarget) = true);

 	/* Return F.[[Construct]](argumentsList, newTarget). */
 	/* return {F.Construct}(F, argumentsList, newTarget) */
  return {F.Construct}(null, null, F, argumentsList)
};

/**
 * 7.3.1 Get (O, P)
 * The abstract operation Get is used to retrieve the value of a specific property of an object. 
 * The operation is called with arguments O and P where O is the object and P is the property key. 
 * 
 * This abstract operation performs the following steps:
 * 
*/
function GetNew(O, P) {
	/* Assert: Type(O) is Object. */
	assert( Type(O) = "Object" );

	/* Assert: IsPropertyKey(P) is true. */
	assert( IsPropertyKey(P) = true );

	/* Return O.[[Get]](P, O). */
	return {O.Get}(O, P)
};

function WrappedGet(O, P) {
  getResult := Get(O, P) catch GetHandler;

  if (!(Type(getResult) = "Completion")) {
    return normalEmptyCompletion(getResult)
  };

  return getResult
};

function GetHandler(x) {
  return throwEmptyCompletion(x)
};

function StringValue(value){
	return value
};

/**
 * 9.1.1 [[GetPrototypeOf]]()
 *
 * When the [[GetPrototypeOf]] internal method of O is called the following 
 * steps are taken: 
 */
function GetPrototypeOf(O) {
  /* 1. Return the value of the [[Prototype]] internal slot of O. */
  return getInternalProperty(O, "Prototype")
};

/**
 * 9.2.11 SetFunctionName (F, name, prefix)
 *
 * The abstract operation SetFunctionName requires a Function argument F, a 
 * String or Symbol argument name and optionally a String argument prefix. This 
 * operation adds a name property to F by performing the following steps: 
 */
function SetFunctionName(F, name, prefix) {

  /* 1. Assert: F is an extensible object that does not have a name own 
     property. */
  /* assert(ObjectIsExtensible(F) &&& !(HasProperty(F, "name"))); TO-DO */

  /* 2. Assert: Type(name) is either Symbol or String. */
  type := Type(name);
  assert(type = "Symbol" ||| type = "String");

  /* 3. Assert: If prefix was passed then Type(prefix) is String. */
  assert(prefix = null ||| Type(prefix) = "String");

  /* 4. If Type(name) is Symbol, then */
  if (type = "Symbol") {

    /* a. Let description be name’s [[Description]] value. */
    description := name.Description;

    /* b. If description is undefined, */
    if (description = 'undefined) {
      /* let name be the empty String */
      name := ""
    }

    /* c. Else, */
    else {
      /* let name be the concatenation of "[", description, and "]" */
      name := s_concat ["[", description, "]"]
    }
  };

  /* 5. If prefix was passed, then */
  if (!(prefix = null)) {
    /* a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and 
       name. */
    name := s_concat [prefix, " ", name]
  };

  /* 6. Return DefinePropertyOrThrow(F, "name", PropertyDescriptor{[[Value]]: 
     name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: 
     true}). */
  return DefinePropertyOrThrow(F, "name", newDataPropertyDescriptorFull(name, false, false, true));

  /* 7. Assert: the result is never an abrupt completion. */
  assert(!(isAnAbruptCompletion(result)));
  return
};

/**
 * 9.2.8 MakeConstructor (F, writablePrototype, prototype)
 *
 * The abstract operation MakeConstructor requires a Function argument F and 
 * optionally, a Boolean writablePrototype and an object prototype. If prototype 
 * is provided it is assumed to already contain, if needed, a "constructor" 
 * property whose value is F. This operation converts F into a constructor by 
 * performing the following steps: 
 */
function MakeConstructor(F, writablePrototype, prototype) {

  /* 1. Assert: F is an ECMAScript function object. */
  assert(isFunctionObject(F));

  /* 2. Assert: F has a [[Construct]] internal method. */
  assert("Construct" in_obj F);

  /* 3. Assert: F is an extensible object that does not have a prototype own 
     property. */
  /* assert(InternalObjectIsExtensible(F) &&& !(HasProperty(F, "prototype"))); TO-DO */

  /* 4. If the writablePrototype argument was not provided, let writablePrototype be true */
  if (writablePrototype = null) {
    writablePrototype := true
  };

  /* 5. If the prototype argument was not provided, then */
  if (prototype = null) {

    /* a. Let prototype be ObjectCreate(%ObjectPrototype%). */
    prototype := ObjectCreate(|ObjectPrototype|, null);

    /* b. Let status be DefinePropertyOrThrow(prototype, "constructor", 
       PropertyDescriptor{[[Value]]: F, [[Writable]]: writablePrototype, 
       [[Enumerable]]: false, [[Configurable]]: true }). */
    status := DefinePropertyOrThrow(prototype, "constructor", newDataPropertyDescriptorFull(F, writablePrototype, false, true));
    
	  /* c. Assert: status is not an abrupt completion. */
    assert(!isAnAbruptCompletion(status))
  };

  /* 6. Let status be DefinePropertyOrThrow(F, "prototype", 
     PropertyDescriptor{[[Value]]: prototype, [[Writable]]: 
     writablePrototype, [[Enumerable]]: false, [[Configurable]]: false}). */
  status := DefinePropertyOrThrow(F, "prototype", newDataPropertyDescriptorFull(prototype, writablePrototype, false, false));

  /* 7. Assert: status is not an abrupt completion. */
  assert(!isAnAbruptCompletion(status));

  /* 8. Return NormalCompletion(undefined). */
  return NormalCompletion('undefined)
};


/**
 * 9.2.10 MakeMethod (F, homeObject)
 *
 * The abstract operation MakeMethod with arguments F and homeObject configures 
 * F as a method by performing the following steps: 
 */
function MakeMethod(F, homeObject) {

  /* 1. Assert: F is an ECMAScript function object. */
  assert(isFunctionObject(F));

  /* 2. Assert: Type(homeObject ) is Object. */
  assert(Type(homeObject) = "Object");

  /* 3. Set the [[HomeObject]] internal slot of F to homeObject. */
  F.HomeObject := homeObject;

  /* 4. Return NormalCompletion(undefined). */
  return NormalCompletion('undefined)
};


function InternalObjectIsExtensible(O){
  return ObjectIsExtensible(|global|, |objectConstructor|, false, [O])
};

/*9.2.9 MakeClassConstructor (F)

  The abstract operation MakeClassConstructor with argument F performs the following steps:*/

function MakeClassConstructor(F){
  F.FunctionKind := "classConstructor";
  return NormalCompletion('undefined)
};

/**
 * NOTE This abstract operation creates a property whose attributes are set to 
 * the same defaults used for built-in methods and methods defined using class 
 * declaration syntax. Normally, the property will not already exist. If it does 
 * exist and is not configurable or if O is not extensible, 
 * [[DefineOwnProperty]] will return false. 
 */

/* 8.1.1.4.4 */
function GlobalInitializeBinding(envRec, N, V) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;

  /* If DclRec.HasBinding(N) is true, then */
  if (HasBinding(DclRec, N)) {
      /* Return DclRec.InitializeBinding(N, V). */
      return InitializeBindingObjectRecord(DclRec, N, V)
  };

  /* Assert: If the binding exists it must be in the object Environment Record. */
  assert(isObjectEnvRec(envRec));

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;

  /* Return ObjRec.InitializeBinding(N, V). */
  return InitializeBindingObjectRecord(ObjRec, N, V)
};

function InitializeBindingDeclarativeRecordTemp(env, N, V) {
  env := env.EnvRec;
	varAlreadyDeclared := HasBinding(env, N);
  /* c. If varAlreadyDeclared is false, then */
  if (varAlreadyDeclared = false) {
    /* i. Call env’s CreateMutableBinding concrete method passing dn and configurableBindings as
          the arguments. */
    CreateMutableBinding(env, N, true);
    /* ii. Call env’s SetMutableBinding concrete method passing dn, undefined, and strict as the
            arguments.*/
    SetMutableBinding(env, N, V, true)
  };
  return 'undefined
};


function InitializeBoundName(className, value, env){
  CreateMutableBindingDeclarative(env, className, value);
  return true
};

function newSetAccessorPropertyDescriptorFull(set, enumerable, configurable) {
  desc := NewPropertyDescriptor();
  desc.Set := set;
  desc.Enumerable := enumerable;
  desc.Configurable := configurable;

  return desc
};

function temporaryInternalGetPrototypeOf (O) {
	return O.Prototype
};

/* Used GetIterator function as reference. */
function IsIterable(obj) {
  iterator := GetMethod(obj, "Symbol(iterator)");
  return !(iterator = 'undefined)
};

function GuardedDelete(O, P) {
  status := {O.Delete}(O, P, true) catch deleteWrapper;
  return status
};

function deleteWrapper(error) {
    return false
}
