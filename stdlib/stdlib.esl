/* TODO: Separate this into smaller files */

/* Int operators */
function int_to_four_hex(n : int) : string {
  return extern int_to_four_hex_external(n)
}

function octal_to_decimal(n: int) : int{
  return extern octal_to_decimal_external(n)
}

/* Float operators */
function is_int(f : float) : boolean {
  return (trunc f) = f
}

/* FIXME: to replace `is_NaN` */
function is_nan(n : float) : boolean {
  return n != n
}

function is_inf(n : float) : boolean {
  return 1.0 / n = 0.0
}

/* FIXME: to replace `to_int` */
function to_int_(n : float) : float {
  if (is_nan(n)) {
    return 0.0
  } elif (n = 0.0 || is_inf(n)) {
    return n
  };
  sign := n < 0.0 ? -(1.0) : 1.0;
  return sign * (floor (abs n))
}

/* FIXME: to replace `to_int32` */
function to_int32_(n : float) : float {
  if (is_nan(n) || n = 0.0 || is_inf(n)) {
    return 0.0
  };
  sign := n < 0.0 ? -(1.0) : 1.0;
  posInt := sign * (floor (abs n));
  int32bit := posInt % 4294967296.0;
  return ((int32bit >= 2147483648.0) ? int32bit - 4294967296.0 : int32bit)
}

/* FIXME: to replace `to_uint32` */
function to_uint32_(n : float) : float {
  if (is_nan(n) || n = 0.0 || is_inf(n)) {
    return 0.0
  };
  sign := n < 0.0 ? -(1.0) : 1.0;
  posInt := sign * (floor (abs n));
  return (posInt % 4294967296.0)
}

/* FIXME: to replace `to_uint16` */
function to_uint16_(n : float) : float {
  if (is_nan(n) || n = 0.0 || is_inf(n)) {
    return 0.0
  };
  sign := n < 0.0 ? -(1.0) : 1.0;
  posInt := sign * (floor (abs n));
  return (posInt % 65536.0)
}

function to_precision(x : float, y : int) : string {
  return extern to_precision_external(x, y)
}

function to_exponential(x : float, y : int) : string {
  return extern to_exponential_external(x, y)
}

function to_fixed(x : float, y : int) : string {
  return extern to_fixed_external(x, y)
}

/* String operators */
function from_char_code_u(n : int) : string {
  return extern from_char_code_u_external(n)
}

function to_char_code_u(s : string) : int {
  return extern to_char_code_u_external(s)
}

function to_lower_case(s : string) : string {
  return extern to_lower_case_external(s)
}

function to_upper_case(s : string) : string {
  return extern to_upper_case_external(s)
}

function trim(s : string) : string {
  return extern trim_external(s)
}

function s_len_u(s : string) : int {
  return extern s_len_u_external(s)
}

function s_nth_u(s : string, n : int) : string {
  return extern s_nth_u_external(s, n)
}

function s_split(s1 : string, s2 : string) : string {
  return extern s_split_external(s1, s2)
}

function s_substr_u(s : string, n1 : int, n2 : int) : string {
  return extern s_substr_u_external(s, n1, n2)
}

/* Math operators */
/* FIXME: to replace `min` */
function min_(x : float, y : float) : float {
  if (y > x) {
    return (is_nan(y) ? y : x)
  };
  return (is_nan(x) ? x : y)
}

/* FIXME: to replace `max` */
function max_(x : float, y : float) : float {
  if (y > x) {
    return (is_nan(x) ? x : y)
  };
  return (is_nan(y) ? y : x)
}

/* List operatos */
function iter(f, lst) : void {
  foreach (v : lst) {
    {f}(v)
  };
  return
}

function map(f, lst) : list {
  result := [];
  foreach (v : lst) {
    result := l_concat(result, [ {f}(v) ])
  };
  return result
}

function bind(f, lst) : list {
  result := [];
  foreach (elt : lst) {
    result := l_concat(result, {f}(elt))
  };
  return result
}

function fold(f, initial, lst) {
  result := initial;
  foreach (elt : lst) {
    result := {f}(result, elt)
  };
  return result
}

function filter(f, lst) {
  result := [];
  foreach (elt : lst) {
    if ({f}(elt)) {
      result := l_prepend(elt, result)
    }
  };
  return result
}
